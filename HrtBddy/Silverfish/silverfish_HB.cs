using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using Triton.Bot;
using Triton.Common;
using Triton.Game;
using Triton.Game.Mapping;

//using System.Linq;

namespace Silverfish
{

    internal class Settings
    {

        public void setSettings()
        {
            // play with these settings###################################
            this.enfacehp = 15;  // hp of enemy when your hero is allowed to attack the enemy face with his weapon
            this.maxwide = 3000;   // numer of boards which are taken to the next deep-lvl
            this.twotsamount = 0;          // number of boards where the next turn is simulated
            this.simEnemySecondTurn = true; // if he simulates the next players-turn, he also simulates the enemys respons

            this.playarround = false;  //play around some enemys aoe-spells?
            //these two probs are >= 0 and <= 100
            this.playaroundprob = 50;    //probability where the enemy plays the aoe-spell, but your minions will not die through it
            this.playaroundprob2 = 80;   // probability where the enemy plays the aoe-spell, and your minions can die!

            this.enemyTurnMaxWide = 40; // bords calculated in enemys-first-turn in first AI step (lower than enemySecondTurnMaxWide)
            this.enemyTurnMaxWideSecondTime = 200; // bords calculated in enemys-first-turn BUT in the second AI step (higher than enemyTurnMaxWide)
            this.enemySecondTurnMaxWide = 20; // number of enemy-board calculated in enemys second TURN

            this.nextTurnDeep = 6; //maximum combo-deep in your second turn (dont change this!)
            this.nextTurnMaxWide = 20; //maximum boards calculated in one second-turn-"combo-step"
            this.nextTurnTotalBoards = 200;//maximum boards calculated in second turn simulation

            this.useSecretsPlayArround = false; // playing arround enemys secrets

            this.alpha = 50; // weight of the second turn in calculation (0<= alpha <= 100)

            this.simulatePlacement = false;  // set this true, and ai will simulate all placements, whether you have a alpha/flametongue/argus
            //use this only with useExternalProcess = true !!!!

            this.useExternalProcess = false; // use silver.exe for calculations a lot faster than turning it off (true = recomended)
            this.passiveWaiting = false; // process will wait passive for silver.exe to finish

            //###########################################################

            this.setWeights(alpha);

            Mulligan.Instance.setAutoConcede(Settings.Instance.concede);
            Helpfunctions.Instance.ErrorLog("set enemy-face-hp to: " + this.enfacehp);
            ComboBreaker.Instance.attackFaceHP = this.enfacehp;
            Ai.Instance.setMaxWide(this.maxwide);
            Helpfunctions.Instance.ErrorLog("set maxwide to: " + this.maxwide);

            Ai.Instance.setTwoTurnSimulation(false, this.twotsamount);
            Helpfunctions.Instance.ErrorLog("calculate the second turn of the " + this.twotsamount + " best boards");
            if (this.twotsamount >= 1)
            {
                if (this.simEnemySecondTurn) Helpfunctions.Instance.ErrorLog("simulates the enemy turn on your second turn");
            }
            if (this.useSecretsPlayArround)
            {
                Helpfunctions.Instance.ErrorLog("playing arround secrets is " + this.useSecretsPlayArround);
            }
            if (this.playarround)
            {
                Ai.Instance.setPlayAround();
                Helpfunctions.Instance.ErrorLog("activated playaround AOE Spells");
            }
            if (this.writeToSingleFile) Helpfunctions.Instance.ErrorLog("write log to single file");


        }


        private Settings()
        {
            this.writeToSingleFile = false;
        }


        public int maxwide = 3000;
        public int twotsamount = 0;

        public bool useExternalProcess = false;
        public bool passiveWaiting = false;

        public int alpha = 50;
        public float firstweight = 0.5f;
        public float secondweight = 0.5f;

        public int numberOfThreads = 32;
        public bool useSecretsPlayArround = false;

        public bool simulatePlacement = true;

        public bool simulateEnemysTurn = true;
        public int enemyTurnMaxWide = 20;
        public int enemyTurnMaxWideSecondTime = 200;

        public int secondTurnAmount = 256;
        public bool simEnemySecondTurn = true;
        public int enemySecondTurnMaxWide = 20;

        public int nextTurnDeep = 6;
        public int nextTurnMaxWide = 20;
        public int nextTurnTotalBoards = 50;

        public bool playarround = false;
        public int playaroundprob = 50;
        public int playaroundprob2 = 80;

        public int enfacehp = 15;

        public string path = "";
        public string logpath = "";
        public string logfile = "Logg.txt";

        public bool concede = false;
        public bool enemyConcede = false;
        public bool writeToSingleFile = false;

        public bool learnmode = true;
        public bool printlearnmode = true;

        private static Settings instance;

        public static Settings Instance
        {
            get
            {
                return instance ?? (instance = new Settings());
            }
        }

        public void setWeights(int alpha)
        {
            float a = ((float)alpha) / 100f;
            this.firstweight = 1f - a;
            this.secondweight = a;
            Helpfunctions.Instance.ErrorLog("current alpha is " + this.secondweight);
        }

        public void setFilePath(string path)
        {
            this.path = path;
        }
        public void setLoggPath(string path)
        {
            this.logpath = path;
        }

        public void setLoggFile(string path)
        {
            this.logfile = path;
        }
    }

    public class Control : ICustomDeck
    {
        private int dirtyTargetSource = -1;
        
        private int dirtytarget = -1;
        private int dirtychoice = -1;
        private string choiceCardId = "";

        private int stopAfterWins = 30;
        private int concedeLvl = 5; // the rank, till you want to concede

        DateTime starttime = DateTime.Now;
        Silverfish sf;

        
        Behavior behave = new BehaviorControl();//change this to new BehaviorRush() for rush mode

        //crawlerstuff
        bool isgoingtoconcede = false;
        int wins = 0;
        int loses = 0;

        public Control()
        {

            Settings set = Settings.Instance;
            this.sf = Silverfish.Instance;
            set.setSettings();
            sf.setnewLoggFile();
            CardDB cdb = CardDB.Instance;
            if (cdb.installedWrong)
            {
                Helpfunctions.Instance.ErrorLog("cant find CardDB");
                return;
            }

            bool teststuff = false; // set to true, to run a testfile (requires test.txt file in folder where _cardDB.txt file is located)
            bool printstuff = false; // if true, the best board of the tested file is printet stepp by stepp

            Helpfunctions.Instance.ErrorLog("----------------------------");
            Helpfunctions.Instance.ErrorLog("you are running uai V" + sf.versionnumber);
            Helpfunctions.Instance.ErrorLog("----------------------------");

            if (Settings.Instance.useExternalProcess) Helpfunctions.Instance.ErrorLog("YOU USE SILVER.EXE FOR CALCULATION, MAKE SURE YOU STARTED IT!");
            if (Settings.Instance.useExternalProcess) Helpfunctions.Instance.ErrorLog("SILVER.EXE IS LOCATED IN: " + Settings.Instance.path);

            

            if (teststuff)//run autotester for developpers
            {
                Ai.Instance.autoTester(printstuff);
            }
        }

        // you may have to out-comment the code in this function (its for conceding)
        /*
     private void concede()
      {
          int curlvl = HRPlayer.GetLocalPlayer().GetRank();
          if (HREngine.API.Utilities.HRSettings.Get.SelectedGameMode != HRGameMode.RANKED_PLAY) return;
          if (curlvl < this.concedeLvl)
          {
              Helpfunctions.Instance.ErrorLog("not today!");
              HRGame.ConcedeGame();
          }
      }

        


        // HC mulligan
      private HREngine.API.Actions.ActionBase HandleBattleMulliganPhase()
      {
          Helpfunctions.Instance.ErrorLog("handle mulligan");

          if (HRMulligan.IsMulliganActive())
          {
              var list = HRCard.GetCards(HRPlayer.GetLocalPlayer(), HRCardZone.HAND);
              if (Mulligan.Instance.hasmulliganrules())
              {
                  HRPlayer enemyPlayer = HRPlayer.GetEnemyPlayer();
                  string enemName = Hrtprozis.Instance.heroIDtoName(enemyPlayer.GetHeroCard().GetEntity().GetCardId());
                  List<Mulligan.CardIDEntity> celist = new List<Mulligan.CardIDEntity>();
                  foreach (var item in list)
                  {
                      if (item.GetEntity().GetCardId() != "GAME_005")// dont mulligan coin
                      {
                          celist.Add(new Mulligan.CardIDEntity(item.GetEntity().GetCardId(), item.GetEntity().GetEntityId()));
                      }
                  }
                  List<int> mullientitys = Mulligan.Instance.whatShouldIMulligan(celist, enemName);
                  foreach (var item in list)
                  {
                      if (mullientitys.Contains(item.GetEntity().GetEntityId()))
                      {
                          Helpfunctions.Instance.ErrorLog("Rejecting Mulligan Card " + item.GetEntity().GetName() + " because of your rules");
                          HRMulligan.ToggleCard(item);
                      }
                  }


              }
              else
              {
                  foreach (var item in list)
                  {
                      if (item.GetEntity().GetCost() >= 4)
                      {
                          Helpfunctions.Instance.ErrorLog("Rejecting Mulligan Card " + item.GetEntity().GetName() + " because it cost is >= 4.");
                          HRMulligan.ToggleCard(item);
                      }
                      if (item.GetEntity().GetCardId() == "EX1_308" || item.GetEntity().GetCardId() == "EX1_622" || item.GetEntity().GetCardId() == "EX1_005")
                      {
                          Helpfunctions.Instance.ErrorLog("Rejecting Mulligan Card " + item.GetEntity().GetName() + " because it is soulfire or shadow word: death");
                          HRMulligan.ToggleCard(item);
                      }
                  }
              }


              sf.setnewLoggFile();

              if (Mulligan.Instance.loserLoserLoser)
              {
                  concede();
              }
              return null;
              //HRMulligan.EndMulligan();
          }
          return null;
      }

       */

        /// <summary>
        ///     [EN]
        ///     This handler is executed when the local player turn is active.
        /// </summary>
        public IEnumerator SelectCard()
        {
            if (Settings.Instance.passiveWaiting && sf.waitingForSilver)
            {
                if (!this.sf.readActionFile(true))
                {
                    yield return Coroutine.Sleep(50);
                    yield break;
                }
            }

            if (Settings.Instance.learnmode && (TritonHS.IsInTargetMode() || TritonHS.IsInChoiceMode()))
            {
                yield return Coroutine.Sleep(50);
                yield break;
            }

            if (TritonHS.IsInTargetMode())
            {
                if (dirtytarget >= 0)
                {
                    Logging.Write("targeting...");
                    HSCard source = null;
                    if (dirtyTargetSource == 9000) // 9000 = ability
                    {
                        source = TritonHS.OurHeroPowerCard;
                    }
                    else
                    {
                        source = getEntityWithNumber(dirtyTargetSource);
                    }
                    HSCard target = getEntityWithNumber(dirtytarget);

                    if (target == null) Logging.Write("error: target is null...");

                    dirtytarget = -1;
                    dirtyTargetSource = -1;

                    if (source == null) TritonHS.DoTarget(target);
                    else source.DoTarget(target);

                    yield break;
                }
                Logging.Write("target failure...");
                TritonHS.CancelTargetingMode();
            }

            if (TritonHS.IsInChoiceMode())
            {
                if (dirtychoice >= 1)
                {
                    //dirtychoice == 1 -> choose left card, 
                    // dirty choice == 2 -> right card

                    Helpfunctions.Instance.logg("chooses the card: " + dirtychoice);
                    if (dirtychoice == 1)
                    {
                        TritonHS.ChooseOneClickLeft();
                    }
                    else
                    {
                        TritonHS.ChooseOneClickRight();
                    }
                    dirtychoice = -1;
                    yield break;
                }
                //Todo: ultimate tracking-simulation!
                var r = new Random();
                int choice = r.Next(0, 2);
                Helpfunctions.Instance.logg("chooses a random card");
                TritonHS.ChooseOneClickLeft();
                yield break;
            }

            bool templearn = sf.updateEverything(behave, Settings.Instance.useExternalProcess, Settings.Instance.passiveWaiting);
            if (templearn == true) this.printlearnmode = true;

            if (Settings.Instance.passiveWaiting && sf.waitingForSilver)
            {
                yield return Coroutine.Sleep(50);
                yield break;
            }

            if (Settings.Instance.learnmode)
            {
                if (Settings.Instance.printlearnmode)
                {
                    Ai.Instance.simmulateWholeTurnandPrint();
                }
                Settings.Instance.printlearnmode = false;

                //do nothing
                yield return Coroutine.Sleep(50);
                yield break;
            }

            Action moveTodo = Ai.Instance.bestmove;
            if (moveTodo == null || moveTodo.actionType == actionEnum.endturn)
            {
                Helpfunctions.Instance.ErrorLog("end turn");
                TritonHS.EndTurn();
                yield break;
            }
            Helpfunctions.Instance.ErrorLog("play action");
            moveTodo.print();

            //play the move#########################################################################

            //play a card form hand
            if (moveTodo.actionType == actionEnum.playcard)
            {
                HSCard cardtoplay = getCardWithNumber(moveTodo.card.entity);
                if (moveTodo.target != null)
                {
                    HSCard target = getEntityWithNumber(moveTodo.target.entitiyID);
                    Helpfunctions.Instance.ErrorLog("play: " + cardtoplay.Name + " target: " + target.Name + " targetEnt " + target.EntityId);
                    Helpfunctions.Instance.logg("play: " + cardtoplay.Name + " target: " + target.Name + " choice: " +
                                                moveTodo.druidchoice);

                    if (moveTodo.druidchoice >= 1)
                    {
                        dirtytarget = moveTodo.target.entitiyID;
                        dirtychoice = moveTodo.druidchoice; //1=leftcard, 2= rightcard
                        choiceCardId = moveTodo.card.card.cardIDenum.ToString();
                    }

                    //safe targeting stuff for hsbuddy
                    dirtyTargetSource = moveTodo.card.entity;
                    dirtytarget = moveTodo.target.entitiyID;


                    //we can place mobs (if api supports it)
                    /*
                if (moveTodo.handcard.card.type == CardDB.cardtype.MOB)
                {
                    //moveTodo.owntarget (maybe +1 (depends on api)) is the place, where the mob should be placed
                    //return;
                }
                */

                    cardtoplay.DoGrab();

                    if (moveTodo.card.card.type == CardDB.cardtype.MOB)
                    {
                        int place = this.localPosToGlobalPos(moveTodo.place - 1, Hrtprozis.Instance.ownMinions.Count);
                        TritonHS.SetCursorPos(place);
                    }

                    yield return Coroutine.Sleep(500);
                    cardtoplay.DoDrop();
                    yield break;
                }
                Helpfunctions.Instance.ErrorLog("play: " + cardtoplay.Name + " target nothing");
                Helpfunctions.Instance.logg("play: " + cardtoplay.Name + " choice: " + moveTodo.druidchoice);
                if (moveTodo.druidchoice >= 1)
                {
                    dirtychoice = moveTodo.druidchoice; //1=leftcard, 2= rightcard
                    choiceCardId = moveTodo.card.card.cardIDenum.ToString();
                }

                dirtyTargetSource = -1;
                dirtytarget = -1;

                //mob placement...
                /*
                if (moveTodo.handcard.card.type == CardDB.cardtype.MOB)
                {
                    //moveTodo.owntarget (maybe +1 (depends on api)) is the place, where the mob should be placed
                    //return;
                }*/

                cardtoplay.DoGrab();

                if (moveTodo.card.card.type == CardDB.cardtype.MOB)
                {
                    int place = this.localPosToGlobalPos(moveTodo.place - 1, Hrtprozis.Instance.ownMinions.Count);
                    TritonHS.SetCursorPos(place);
                }

                yield return Coroutine.Sleep(500);
                cardtoplay.DoDrop();
                yield break;
            }

            //attack with minion
            if (moveTodo.actionType == actionEnum.attackWithMinion)
            {
                HSCard attacker = getEntityWithNumber(moveTodo.own.entitiyID);
                HSCard target = getEntityWithNumber(moveTodo.target.entitiyID);
                Helpfunctions.Instance.ErrorLog("minion attack: " + attacker.Name + " target: " + target.Name);
                Helpfunctions.Instance.logg("minion attack: " + attacker.Name + " target: " + target.Name);
                attacker.DoAttack(target);
                yield break;
            }
            //attack with hero
            if (moveTodo.actionType == actionEnum.attackWithHero)
            {
                HSCard attacker = getEntityWithNumber(moveTodo.own.entitiyID);
                HSCard target = getEntityWithNumber(moveTodo.target.entitiyID);
                dirtytarget = moveTodo.target.entitiyID;
                Helpfunctions.Instance.ErrorLog("heroattack: " + attacker.Name + " target: " + target.Name);
                Helpfunctions.Instance.logg("heroattack: " + attacker.Name + " target: " + target.Name);

                //safe targeting stuff for hsbuddy
                dirtyTargetSource = moveTodo.own.entitiyID;
                dirtytarget = moveTodo.target.entitiyID;
                attacker.DoAttack(target);
                yield break;
            }

            //use ability
            if (moveTodo.actionType == actionEnum.useHeroPower)
            {
                HSCard cardtoplay = TritonHS.OurHeroPowerCard;

                if (moveTodo.target != null)
                {
                    HSCard target = getEntityWithNumber(moveTodo.target.entitiyID);
                    dirtyTargetSource = 9000;
                    dirtytarget = moveTodo.target.entitiyID;

                    Helpfunctions.Instance.ErrorLog("use ablitiy: " + cardtoplay.Name + " target " + target.Name);
                    Helpfunctions.Instance.logg("use ablitiy: " + cardtoplay.Name + " target " + target.Name);
                }
                else
                {
                    Helpfunctions.Instance.ErrorLog("use ablitiy: " + cardtoplay.Name + " target nothing");
                    Helpfunctions.Instance.logg("use ablitiy: " + cardtoplay.Name + " target nothing");
                }
                cardtoplay.DoGrab();
                yield return Coroutine.Sleep(500);
                cardtoplay.DoDrop();
                yield break;
            }

            TritonHS.EndTurn();
        }

        private int localPosToGlobalPos(int lp, int numMins)
        {
            int gp = lp;
            string place = "left of your first minion";
            if (lp == 1) place = "right of your first minion";
            if (lp == 2) place = "right of your second minion";
            if (lp == 3) place = "right of your third minion";
            if (lp == 4) place = "right of your 4th minion";
            if (lp == 5) place = "right of your 5th minion";
            if (lp == 6) place = "right of your 6th minion";
            if (lp == 7) place = "right of your 7th minion";


            if (numMins == 6)
            {
                gp = lp;
                if (lp == 0) gp = 0;
                if (lp == 1) gp = 1;
                if (lp == 2) gp = 2;
                if (lp == 3) gp = 4;
                if (lp == 4) gp = 6;
                if (lp == 5) gp = 7;
                if (lp == 6) gp = 9;

            }
            if (numMins == 4)
            {
                gp = lp + 1;
                if (lp == 0) gp = 0;
                if (lp == 1) gp = 2;
                if (lp == 2) gp = 4;
                if (lp == 3) gp = 6;
                if (lp == 4) gp = 7;
            }
            if (numMins == 2)
            {
                gp = lp + 2;
                if (lp == 0) gp = 2;
                if (lp == 1) gp = 4;
                if (lp == 2) gp = 6;
            }
            if (numMins == 1)
            {
                gp = lp + 2;
                if (lp == 0) gp = 2;
                if (lp == 1) gp = 6;

            }
            if (numMins == 3)
            {
                gp = lp + 1;
                if (lp == 0) gp = 1;
                if (lp == 1) gp = 3;
                if (lp == 2) gp = 5;
                if (lp == 3) gp = 7;

            }
            if (numMins == 5)
            {
                gp = lp + 0;
                if (lp == 0) gp = 0;
                if (lp == 1) gp = 1;
                if (lp == 2) gp = 3;
                if (lp == 3) gp = 5;
                if (lp == 4) gp = 7;
                if (lp == 5) gp = 9;

            }
            if (numMins == 0) { gp = 4; }
            Helpfunctions.Instance.ErrorLog("should place minion " + place + " (" + lp + " " + numMins + ") ");
            Helpfunctions.Instance.logg("should place minion " + place + " (" + lp + " " + numMins + ") ");
            return gp;
        }

        private HSCard getEntityWithNumber(int number)
        {
            foreach (HSCard e in getallEntitys())
            {
                if (number == e.EntityId) return e;
            }
            return null;
        }

        private HSCard getCardWithNumber(int number)
        {
            foreach (HSCard e in getallHandCards())
            {
                if (number == e.EntityId) return e;
            }
            return null;
        }

        private List<HSCard> getallEntitys()
        {
            var result = new List<HSCard>();
            HSCard ownhero = TritonHS.OurHero;
            HSCard enemyhero = TritonHS.EnemyHero;
            HSCard ownHeroAbility = TritonHS.OurHeroPowerCard;
            List<HSCard> list2 = TritonHS.GetCards(CardZone.Battlefield, true);
            List<HSCard> list3 = TritonHS.GetCards(CardZone.Battlefield, false);

            result.Add(ownhero);
            result.Add(enemyhero);
            result.Add(ownHeroAbility);

            result.AddRange(list2);
            result.AddRange(list3);

            return result;
        }

        private List<HSCard> getallHandCards()
        {
            List<HSCard> list = TritonHS.GetCards(CardZone.Hand, true);
            return list;
        }

        protected virtual void SafeHandleBattleLocalPlayerTurnHandler()
        {
        }

        protected virtual HSCard GetMinionByPriority(HSCard lastMinion = null)
        {
            return null;
        }
    }

    public class Rush : ICustomDeck
    {
        private int dirtyTargetSource = -1;

        private int dirtytarget = -1;
        private int dirtychoice = -1;
        private string choiceCardId = "";

        private int stopAfterWins = 30;
        private int concedeLvl = 5; // the rank, till you want to concede

        DateTime starttime = DateTime.Now;
        Silverfish sf;


        Behavior behave = new BehaviorControl();//change this to new BehaviorRush() for rush mode

        //crawlerstuff
        bool isgoingtoconcede = false;
        int wins = 0;
        int loses = 0;

        public Rush()
        {

            Settings set = Settings.Instance;
            this.sf = Silverfish.Instance;
            set.setSettings();
            sf.setnewLoggFile();
            CardDB cdb = CardDB.Instance;
            if (cdb.installedWrong)
            {
                Helpfunctions.Instance.ErrorLog("cant find CardDB");
                return;
            }

            bool teststuff = false; // set to true, to run a testfile (requires test.txt file in folder where _cardDB.txt file is located)
            bool printstuff = false; // if true, the best board of the tested file is printet stepp by stepp

            Helpfunctions.Instance.ErrorLog("----------------------------");
            Helpfunctions.Instance.ErrorLog("you are running uai V" + sf.versionnumber);
            Helpfunctions.Instance.ErrorLog("----------------------------");

            if (Settings.Instance.useExternalProcess) Helpfunctions.Instance.ErrorLog("YOU USE SILVER.EXE FOR CALCULATION, MAKE SURE YOU STARTED IT!");
            if (Settings.Instance.useExternalProcess) Helpfunctions.Instance.ErrorLog("SILVER.EXE IS LOCATED IN: " + Settings.Instance.path);



            if (teststuff)//run autotester for developpers
            {
                Ai.Instance.autoTester(printstuff);
            }
        }

        // you may have to out-comment the code in this function (its for conceding)
        /*
     private void concede()
      {
          int curlvl = HRPlayer.GetLocalPlayer().GetRank();
          if (HREngine.API.Utilities.HRSettings.Get.SelectedGameMode != HRGameMode.RANKED_PLAY) return;
          if (curlvl < this.concedeLvl)
          {
              Helpfunctions.Instance.ErrorLog("not today!");
              HRGame.ConcedeGame();
          }
      }

        


        // HC mulligan
      private HREngine.API.Actions.ActionBase HandleBattleMulliganPhase()
      {
          Helpfunctions.Instance.ErrorLog("handle mulligan");

          if (HRMulligan.IsMulliganActive())
          {
              var list = HRCard.GetCards(HRPlayer.GetLocalPlayer(), HRCardZone.HAND);
              if (Mulligan.Instance.hasmulliganrules())
              {
                  HRPlayer enemyPlayer = HRPlayer.GetEnemyPlayer();
                  string enemName = Hrtprozis.Instance.heroIDtoName(enemyPlayer.GetHeroCard().GetEntity().GetCardId());
                  List<Mulligan.CardIDEntity> celist = new List<Mulligan.CardIDEntity>();
                  foreach (var item in list)
                  {
                      if (item.GetEntity().GetCardId() != "GAME_005")// dont mulligan coin
                      {
                          celist.Add(new Mulligan.CardIDEntity(item.GetEntity().GetCardId(), item.GetEntity().GetEntityId()));
                      }
                  }
                  List<int> mullientitys = Mulligan.Instance.whatShouldIMulligan(celist, enemName);
                  foreach (var item in list)
                  {
                      if (mullientitys.Contains(item.GetEntity().GetEntityId()))
                      {
                          Helpfunctions.Instance.ErrorLog("Rejecting Mulligan Card " + item.GetEntity().GetName() + " because of your rules");
                          HRMulligan.ToggleCard(item);
                      }
                  }


              }
              else
              {
                  foreach (var item in list)
                  {
                      if (item.GetEntity().GetCost() >= 4)
                      {
                          Helpfunctions.Instance.ErrorLog("Rejecting Mulligan Card " + item.GetEntity().GetName() + " because it cost is >= 4.");
                          HRMulligan.ToggleCard(item);
                      }
                      if (item.GetEntity().GetCardId() == "EX1_308" || item.GetEntity().GetCardId() == "EX1_622" || item.GetEntity().GetCardId() == "EX1_005")
                      {
                          Helpfunctions.Instance.ErrorLog("Rejecting Mulligan Card " + item.GetEntity().GetName() + " because it is soulfire or shadow word: death");
                          HRMulligan.ToggleCard(item);
                      }
                  }
              }


              sf.setnewLoggFile();

              if (Mulligan.Instance.loserLoserLoser)
              {
                  concede();
              }
              return null;
              //HRMulligan.EndMulligan();
          }
          return null;
      }

       */

        /// <summary>
        ///     [EN]
        ///     This handler is executed when the local player turn is active.
        /// </summary>
        public IEnumerator SelectCard()
        {
            if (Settings.Instance.passiveWaiting && sf.waitingForSilver)
            {
                if (!this.sf.readActionFile(true))
                {
                    yield return Coroutine.Sleep(50);
                    yield break;
                }
            }

            if (Settings.Instance.learnmode && (TritonHS.IsInTargetMode() || TritonHS.IsInChoiceMode()))
            {
                yield return Coroutine.Sleep(50);
                yield break;
            }

            if (TritonHS.IsInTargetMode())
            {
                if (dirtytarget >= 0)
                {
                    Logging.Write("targeting...");
                    HSCard source = null;
                    if (dirtyTargetSource == 9000) // 9000 = ability
                    {
                        source = TritonHS.OurHeroPowerCard;
                    }
                    else
                    {
                        source = getEntityWithNumber(dirtyTargetSource);
                    }
                    HSCard target = getEntityWithNumber(dirtytarget);

                    if (target == null) Logging.Write("error: target is null...");

                    dirtytarget = -1;
                    dirtyTargetSource = -1;

                    if (source == null) TritonHS.DoTarget(target);
                    else source.DoTarget(target);

                    yield break;
                }
                Logging.Write("target failure...");
                TritonHS.CancelTargetingMode();
            }

            if (TritonHS.IsInChoiceMode())
            {
                if (dirtychoice >= 1)
                {
                    //dirtychoice == 1 -> choose left card, 
                    // dirty choice == 2 -> right card

                    Helpfunctions.Instance.logg("chooses the card: " + dirtychoice);
                    if (dirtychoice == 1)
                    {
                        TritonHS.ChooseOneClickLeft();
                    }
                    else
                    {
                        TritonHS.ChooseOneClickRight();
                    }
                    dirtychoice = -1;
                    yield break;
                }
                //Todo: ultimate tracking-simulation!
                var r = new Random();
                int choice = r.Next(0, 2);
                Helpfunctions.Instance.logg("chooses a random card");
                TritonHS.ChooseOneClickLeft();
                yield break;
            }

            bool templearn = sf.updateEverything(behave, Settings.Instance.useExternalProcess, Settings.Instance.passiveWaiting);
            if (templearn == true) this.printlearnmode = true;

            if (Settings.Instance.passiveWaiting && sf.waitingForSilver)
            {
                yield return Coroutine.Sleep(50);
                yield break;
            }

            if (Settings.Instance.learnmode)
            {
                if (Settings.Instance.printlearnmode)
                {
                    Ai.Instance.simmulateWholeTurnandPrint();
                }
                Settings.Instance.printlearnmode = false;

                //do nothing
                yield return Coroutine.Sleep(50);
                yield break;
            }

            Action moveTodo = Ai.Instance.bestmove;
            if (moveTodo == null || moveTodo.actionType == actionEnum.endturn)
            {
                Helpfunctions.Instance.ErrorLog("end turn");
                TritonHS.EndTurn();
                yield break;
            }
            Helpfunctions.Instance.ErrorLog("play action");
            moveTodo.print();

            //play the move#########################################################################

            //play a card form hand
            if (moveTodo.actionType == actionEnum.playcard)
            {
                HSCard cardtoplay = getCardWithNumber(moveTodo.card.entity);
                if (moveTodo.target != null)
                {
                    HSCard target = getEntityWithNumber(moveTodo.target.entitiyID);
                    Helpfunctions.Instance.ErrorLog("play: " + cardtoplay.Name + " target: " + target.Name + " targetEnt " + target.EntityId);
                    Helpfunctions.Instance.logg("play: " + cardtoplay.Name + " target: " + target.Name + " choice: " +
                                                moveTodo.druidchoice);

                    if (moveTodo.druidchoice >= 1)
                    {
                        dirtytarget = moveTodo.target.entitiyID;
                        dirtychoice = moveTodo.druidchoice; //1=leftcard, 2= rightcard
                        choiceCardId = moveTodo.card.card.cardIDenum.ToString();
                    }

                    //safe targeting stuff for hsbuddy
                    dirtyTargetSource = moveTodo.card.entity;
                    dirtytarget = moveTodo.target.entitiyID;


                    //we can place mobs (if api supports it)
                    /*
                if (moveTodo.handcard.card.type == CardDB.cardtype.MOB)
                {
                    //moveTodo.owntarget (maybe +1 (depends on api)) is the place, where the mob should be placed
                    //return;
                }
                */

                    cardtoplay.DoGrab();

                    if (moveTodo.card.card.type == CardDB.cardtype.MOB)
                    {
                        int place = this.localPosToGlobalPos(moveTodo.place - 1, Hrtprozis.Instance.ownMinions.Count);
                        TritonHS.SetCursorPos(place);
                    }

                    yield return Coroutine.Sleep(500);
                    cardtoplay.DoDrop();
                    yield break;
                }
                Helpfunctions.Instance.ErrorLog("play: " + cardtoplay.Name + " target nothing");
                Helpfunctions.Instance.logg("play: " + cardtoplay.Name + " choice: " + moveTodo.druidchoice);
                if (moveTodo.druidchoice >= 1)
                {
                    dirtychoice = moveTodo.druidchoice; //1=leftcard, 2= rightcard
                    choiceCardId = moveTodo.card.card.cardIDenum.ToString();
                }

                dirtyTargetSource = -1;
                dirtytarget = -1;

                //mob placement...
                /*
                if (moveTodo.handcard.card.type == CardDB.cardtype.MOB)
                {
                    //moveTodo.owntarget (maybe +1 (depends on api)) is the place, where the mob should be placed
                    //return;
                }*/

                cardtoplay.DoGrab();

                if (moveTodo.card.card.type == CardDB.cardtype.MOB)
                {
                    int place = this.localPosToGlobalPos(moveTodo.place - 1, Hrtprozis.Instance.ownMinions.Count);
                    TritonHS.SetCursorPos(place);
                }

                yield return Coroutine.Sleep(500);
                cardtoplay.DoDrop();
                yield break;
            }

            //attack with minion
            if (moveTodo.actionType == actionEnum.attackWithMinion)
            {
                HSCard attacker = getEntityWithNumber(moveTodo.own.entitiyID);
                HSCard target = getEntityWithNumber(moveTodo.target.entitiyID);
                Helpfunctions.Instance.ErrorLog("minion attack: " + attacker.Name + " target: " + target.Name);
                Helpfunctions.Instance.logg("minion attack: " + attacker.Name + " target: " + target.Name);
                attacker.DoAttack(target);
                yield break;
            }
            //attack with hero
            if (moveTodo.actionType == actionEnum.attackWithHero)
            {
                HSCard attacker = getEntityWithNumber(moveTodo.own.entitiyID);
                HSCard target = getEntityWithNumber(moveTodo.target.entitiyID);
                dirtytarget = moveTodo.target.entitiyID;
                Helpfunctions.Instance.ErrorLog("heroattack: " + attacker.Name + " target: " + target.Name);
                Helpfunctions.Instance.logg("heroattack: " + attacker.Name + " target: " + target.Name);

                //safe targeting stuff for hsbuddy
                dirtyTargetSource = moveTodo.own.entitiyID;
                dirtytarget = moveTodo.target.entitiyID;
                attacker.DoAttack(target);
                yield break;
            }

            //use ability
            if (moveTodo.actionType == actionEnum.useHeroPower)
            {
                HSCard cardtoplay = TritonHS.OurHeroPowerCard;

                if (moveTodo.target != null)
                {
                    HSCard target = getEntityWithNumber(moveTodo.target.entitiyID);
                    dirtyTargetSource = 9000;
                    dirtytarget = moveTodo.target.entitiyID;

                    Helpfunctions.Instance.ErrorLog("use ablitiy: " + cardtoplay.Name + " target " + target.Name);
                    Helpfunctions.Instance.logg("use ablitiy: " + cardtoplay.Name + " target " + target.Name);
                }
                else
                {
                    Helpfunctions.Instance.ErrorLog("use ablitiy: " + cardtoplay.Name + " target nothing");
                    Helpfunctions.Instance.logg("use ablitiy: " + cardtoplay.Name + " target nothing");
                }
                cardtoplay.DoGrab();
                yield return Coroutine.Sleep(500);
                cardtoplay.DoDrop();
                yield break;
            }

            TritonHS.EndTurn();
        }

        private int localPosToGlobalPos(int lp, int numMins)
        {
            int gp = lp;
            string place = "left of your first minion";
            if (lp == 1) place = "right of your first minion";
            if (lp == 2) place = "right of your second minion";
            if (lp == 3) place = "right of your third minion";
            if (lp == 4) place = "right of your 4th minion";
            if (lp == 5) place = "right of your 5th minion";
            if (lp == 6) place = "right of your 6th minion";
            if (lp == 7) place = "right of your 7th minion";


            if (numMins == 6)
            {
                gp = lp;
                if (lp == 0) gp = 0;
                if (lp == 1) gp = 1;
                if (lp == 2) gp = 2;
                if (lp == 3) gp = 4;
                if (lp == 4) gp = 6;
                if (lp == 5) gp = 7;
                if (lp == 6) gp = 9;

            }
            if (numMins == 4)
            {
                gp = lp + 1;
                if (lp == 0) gp = 0;
                if (lp == 1) gp = 2;
                if (lp == 2) gp = 4;
                if (lp == 3) gp = 6;
                if (lp == 4) gp = 7;
            }
            if (numMins == 2)
            {
                gp = lp + 2;
                if (lp == 0) gp = 2;
                if (lp == 1) gp = 4;
                if (lp == 2) gp = 6;
            }
            if (numMins == 1)
            {
                gp = lp + 2;
                if (lp == 0) gp = 2;
                if (lp == 1) gp = 6;

            }
            if (numMins == 3)
            {
                gp = lp + 1;
                if (lp == 0) gp = 1;
                if (lp == 1) gp = 3;
                if (lp == 2) gp = 5;
                if (lp == 3) gp = 7;

            }
            if (numMins == 5)
            {
                gp = lp + 0;
                if (lp == 0) gp = 0;
                if (lp == 1) gp = 1;
                if (lp == 2) gp = 3;
                if (lp == 3) gp = 5;
                if (lp == 4) gp = 7;
                if (lp == 5) gp = 9;

            }
            if (numMins == 0) { gp = 4; }
            Helpfunctions.Instance.ErrorLog("should place minion " + place + " (" + lp + " " + numMins + ") ");
            Helpfunctions.Instance.logg("should place minion " + place + " (" + lp + " " + numMins + ") ");
            return gp;
        }

        private HSCard getEntityWithNumber(int number)
        {
            foreach (HSCard e in getallEntitys())
            {
                if (number == e.EntityId) return e;
            }
            return null;
        }

        private HSCard getCardWithNumber(int number)
        {
            foreach (HSCard e in getallHandCards())
            {
                if (number == e.EntityId) return e;
            }
            return null;
        }

        private List<HSCard> getallEntitys()
        {
            var result = new List<HSCard>();
            HSCard ownhero = TritonHS.OurHero;
            HSCard enemyhero = TritonHS.EnemyHero;
            HSCard ownHeroAbility = TritonHS.OurHeroPowerCard;
            List<HSCard> list2 = TritonHS.GetCards(CardZone.Battlefield, true);
            List<HSCard> list3 = TritonHS.GetCards(CardZone.Battlefield, false);

            result.Add(ownhero);
            result.Add(enemyhero);
            result.Add(ownHeroAbility);

            result.AddRange(list2);
            result.AddRange(list3);

            return result;
        }

        private List<HSCard> getallHandCards()
        {
            List<HSCard> list = TritonHS.GetCards(CardZone.Hand, true);
            return list;
        }

        protected virtual void SafeHandleBattleLocalPlayerTurnHandler()
        {
        }

        protected virtual HSCard GetMinionByPriority(HSCard lastMinion = null)
        {
            return null;
        }
    }

    public class HBMulligan : ICustomMulligan
    {
        private const int MaximumCost = 3;
        public IEnumerator DoMulligan()
        {
            Helpfunctions.Instance.ErrorLog("handle mulligan");
            List<HSCard> list = TritonHS.GetMulliganCards();

            HSCard enemyPlayer = TritonHS.EnemyHero;
            HSCard ownPlayer = TritonHS.OurHero;
            string enemName = Hrtprozis.Instance.heroIDtoName(enemyPlayer.Id);
            string ownName = Hrtprozis.Instance.heroIDtoName(ownPlayer.Id);

            if (Mulligan.Instance.hasmulliganrules(ownName, enemName))
            {
                
                List<Mulligan.CardIDEntity> celist = new List<Mulligan.CardIDEntity>();
                foreach (HSCard item in list)
                {
                    if (item.Id != "GAME_005")// dont mulligan coin
                    {
                        celist.Add(new Mulligan.CardIDEntity(item.Id, item.EntityId));
                    }
                }
                List<int> mullientitys = Mulligan.Instance.whatShouldIMulligan(celist, ownName, enemName);
                foreach (HSCard item in list)
                {
                    if (mullientitys.Contains(item.EntityId))
                    {
                        Helpfunctions.Instance.ErrorLog("Rejecting Mulligan Card " + item.Name + " because of your rules");
                        TritonHS.ToggleMulliganCard(item);
                        yield return Coroutine.Sleep(1000);
                    }
                }


            }
            else
            {
                foreach (HSCard item in list)
                {
                    if (item.Cost >= 4)
                    {
                        Helpfunctions.Instance.ErrorLog("Rejecting Mulligan Card " + item.Name + " because it cost is >= 4.");
                        TritonHS.ToggleMulliganCard(item);
                        yield return Coroutine.Sleep(1000);
                        continue;
                    }
                    if (item.Id == "EX1_308" || item.Id == "EX1_622" || item.Id == "EX1_005")
                    {
                        Helpfunctions.Instance.ErrorLog("Rejecting Mulligan Card " + item.Name + " because it is soulfire or shadow word: death");
                        TritonHS.ToggleMulliganCard(item);
                        yield return Coroutine.Sleep(1000);
                    }
                }
            }



            yield return Coroutine.Sleep(1000);
            TritonHS.EndMulligan();
        }



    }

    public class Silverfish
    {
        public string versionnumber = "114.0";
        private bool singleLog = false;
        private string botbehave = "rush";
        public bool waitingForSilver = false;

        Playfield lastpf;
        Settings sttngs = Settings.Instance;

        List<Minion> ownMinions = new List<Minion>();
        List<Minion> enemyMinions = new List<Minion>();
        List<Handmanager.Handcard> handCards = new List<Handmanager.Handcard>();
        int ownPlayerController = 0;
        List<string> ownSecretList = new List<string>();
        int enemySecretCount = 0;
        List<int> enemySecretList = new List<int>();

        int currentMana = 0;
        int ownMaxMana = 0;
        int numOptionPlayedThisTurn = 0;
        int numMinionsPlayedThisTurn = 0;
        int cardsPlayedThisTurn = 0;
        int ueberladung = 0;

        int enemyMaxMana = 0;

        string ownHeroWeapon = "";
        int heroWeaponAttack = 0;
        int heroWeaponDurability = 0;

        string enemyHeroWeapon = "";
        int enemyWeaponAttack = 0;
        int enemyWeaponDurability = 0;

        string heroname = "";
        string enemyHeroname = "";

        CardDB.Card heroAbility = new CardDB.Card();
        bool ownAbilityisReady = false;
        CardDB.Card enemyAbility = new CardDB.Card();

        int anzcards = 0;
        int enemyAnzCards = 0;

        int ownHeroFatigue = 0;
        int enemyHeroFatigue = 0;
        int ownDecksize = 0;
        int enemyDecksize = 0;

        Minion ownHero;
        Minion enemyHero;

        private static Silverfish instance;

        public static Silverfish Instance
        {
            get
            {
                return instance ?? (instance = new Silverfish());
            }
        }

        private Silverfish()
        {
            this.singleLog = Settings.Instance.writeToSingleFile;
            Helpfunctions.Instance.ErrorLog("init Silverfish");
            string p = "." + System.IO.Path.DirectorySeparatorChar + "CustomDecks" + System.IO.Path.DirectorySeparatorChar + "Silverfish" + System.IO.Path.DirectorySeparatorChar;
            string path = p + "UltimateLogs" + Path.DirectorySeparatorChar;
            Directory.CreateDirectory(path);
            sttngs.setFilePath(p + "Data" + Path.DirectorySeparatorChar);

            if (!singleLog)
            {
                sttngs.setLoggPath(path);
            }
            else
            {
                sttngs.setLoggPath(p);
                sttngs.setLoggFile("UILogg.txt");
                Helpfunctions.Instance.createNewLoggfile();
            }
            PenalityManager.Instance.setCombos();
            Mulligan m = Mulligan.Instance; // read the mulligan list
        }

        public void setnewLoggFile()
        {
            if (!singleLog)
            {
                sttngs.setLoggFile("UILogg" + DateTime.Now.ToString("_yyyy-MM-dd_HH-mm-ss") + ".txt");
                Helpfunctions.Instance.createNewLoggfile();
                Helpfunctions.Instance.ErrorLog("#######################################################");
                Helpfunctions.Instance.ErrorLog("fight is logged in: " + sttngs.logpath + sttngs.logfile);
                Helpfunctions.Instance.ErrorLog("#######################################################");
            }
            else
            {
                sttngs.setLoggFile("UILogg.txt");
            }
        }

        public bool updateEverything(Behavior botbase, bool runExtern = false, bool passiveWait = false)
        {
            this.updateBehaveString(botbase);


            ownPlayerController = TritonHS.OurHero.ControllerId;


            // create hero + minion data
            getHerostuff();

            //small fix for not knowing when to mulligan:
            if (ownMaxMana == 1 && currentMana == 1 && numMinionsPlayedThisTurn == 0 && cardsPlayedThisTurn == 0)
            {
                setnewLoggFile();
                getHerostuff();
            }

            getMinions();
            getHandcards();
            getDecks();

            // send ai the data:
            Hrtprozis.Instance.clearAll();
            Handmanager.Instance.clearAll();

            Hrtprozis.Instance.setOwnPlayer(ownPlayerController);
            Handmanager.Instance.setOwnPlayer(ownPlayerController);

            this.numOptionPlayedThisTurn = 0;
            this.numOptionPlayedThisTurn += this.cardsPlayedThisTurn + this.ownHero.numAttacksThisTurn;
            foreach (Minion m in this.ownMinions)
            {
                if (m.Hp >= 1) this.numOptionPlayedThisTurn += m.numAttacksThisTurn;
            }

            Hrtprozis.Instance.updatePlayer(this.ownMaxMana, this.currentMana, this.cardsPlayedThisTurn, this.numMinionsPlayedThisTurn, this.numOptionPlayedThisTurn, this.ueberladung, TritonHS.OurHero.EntityId, TritonHS.EnemyHero.EntityId);
            Hrtprozis.Instance.updateSecretStuff(this.ownSecretList, this.enemySecretCount);

            Hrtprozis.Instance.updateOwnHero(this.ownHeroWeapon, this.heroWeaponAttack, this.heroWeaponDurability, this.heroname, this.heroAbility, this.ownAbilityisReady, this.ownHero);
            Hrtprozis.Instance.updateEnemyHero(this.enemyHeroWeapon, this.enemyWeaponAttack, this.enemyWeaponDurability, this.enemyHeroname, this.enemyMaxMana, this.enemyAbility, this.enemyHero);

            Hrtprozis.Instance.updateMinions(this.ownMinions, this.enemyMinions);
            Handmanager.Instance.setHandcards(this.handCards, this.anzcards, this.enemyAnzCards);

            Hrtprozis.Instance.updateFatigueStats(this.ownDecksize, this.ownHeroFatigue, this.enemyDecksize, this.enemyHeroFatigue);

            Probabilitymaker.Instance.getEnemySecretGuesses(this.enemySecretList, Hrtprozis.Instance.heroNametoEnum(this.enemyHeroname));
            //learnmode :D

            Playfield p = new Playfield();

            if (lastpf != null)
            {
                if (lastpf.isEqualf(p))
                {
                    return false;
                }

                //board changed we update secrets!
                //if(Ai.Instance.nextMoveGuess!=null) Probabilitymaker.Instance.updateSecretList(Ai.Instance.nextMoveGuess.enemySecretList);
                Probabilitymaker.Instance.updateSecretList(p, lastpf);
                lastpf = p;
            }
            else
            {
                lastpf = p;
            }

            p = new Playfield();//secrets have updated :D
            // calculate stuff
            Helpfunctions.Instance.ErrorLog("calculating stuff... " + DateTime.Now.ToString("HH:mm:ss.ffff"));
            if (runExtern)
            {
                Helpfunctions.Instance.logg("recalc-check###########");
                if (p.isEqual(Ai.Instance.nextMoveGuess, true))
                {
                    printstuff(false);
                    Ai.Instance.doNextCalcedMove();
                }
                else
                {
                    printstuff(true);
                    readActionFile(passiveWait);
                }
            }
            else
            {
                printstuff(false);
                Ai.Instance.dosomethingclever(botbase);
            }

            Helpfunctions.Instance.ErrorLog("calculating ended! " + DateTime.Now.ToString("HH:mm:ss.ffff"));
            return true;
        }

        private void getHerostuff()
        {
            List<HSCard> allcards = TritonHS.GetAllCards();

            HSCard ownHeroCard = TritonHS.OurHero;
            HSCard enemHeroCard = TritonHS.EnemyHero;
            int ownheroentity = TritonHS.OurHero.EntityId;
            int enemyheroentity = TritonHS.EnemyHero.EntityId;
            foreach (HSCard ent in allcards)
            {
                if (ent.EntityId == enemyheroentity)
                {
                    enemHeroCard = ent;
                }
                if (ent.EntityId == ownheroentity)
                {
                    ownHeroCard = ent;
                }
            }

            //player stuff#########################
            //this.currentMana =ownPlayer.GetTag(HRGameTag.RESOURCES) - ownPlayer.GetTag(HRGameTag.RESOURCES_USED) + ownPlayer.GetTag(HRGameTag.TEMP_RESOURCES);
            this.currentMana = TritonHS.CurrentMana;
            this.ownMaxMana = TritonHS.Resources;
            this.enemyMaxMana = ownMaxMana;

            //count own secrets
            ownSecretList = new List<string>(); // the CARDIDS of the secrets
            enemySecretCount = 0;
            //count enemy secrets:
            enemySecretList.Clear();
            foreach (HSCard ent in allcards)
            {
                if (ent.IsSecret && ent.ControllerId != ownPlayerController && ent.GetTag(GAME_TAG.ZONE) == 7)
                {
                    enemySecretCount++;
                    enemySecretList.Add(ent.GetTag(GAME_TAG.ENTITY_ID));

                }
                if (ent.IsSecret && ent.ControllerId == ownPlayerController && ent.GetTag(GAME_TAG.ZONE) == 7)
                {
                    ownSecretList.Add(ent.Id);
                    
                }
            }


            int ourSecretsCount = ownSecretList.Count;

            numMinionsPlayedThisTurn = TritonHS.NumMinionsPlayedThisTurn;
            cardsPlayedThisTurn = TritonHS.NumCardsPlayedThisTurn;
            ueberladung = TritonHS.RecallOwed;

            //get weapon stuff
            this.ownHeroWeapon = "";
            this.heroWeaponAttack = 0;
            this.heroWeaponDurability = 0;

            this.ownHeroFatigue = ownHeroCard.GetTag(GAME_TAG.FATIGUE);
            this.enemyHeroFatigue = enemHeroCard.GetTag(GAME_TAG.FATIGUE);

            this.ownDecksize = 0;
            this.enemyDecksize = 0;
            //count decksize
            foreach (HSCard ent in allcards)
            {
                if (ent.ControllerId == ownPlayerController && ent.GetTag(GAME_TAG.ZONE) == 2) ownDecksize++;
                if (ent.ControllerId != ownPlayerController && ent.GetTag(GAME_TAG.ZONE) == 2) enemyDecksize++;
            }

            //own hero stuff###########################
            int heroAtk = ownHeroCard.GetTag(GAME_TAG.ATK);
            int heroHp = ownHeroCard.GetTag(GAME_TAG.HEALTH) - ownHeroCard.GetTag(GAME_TAG.DAMAGE);
            int heroDefence = ownHeroCard.GetTag(GAME_TAG.ARMOR);
            this.heroname = Hrtprozis.Instance.heroIDtoName(TritonHS.OurHero.Id);

            bool heroImmuneToDamageWhileAttacking = false;
            bool herofrozen = (ownHeroCard.GetTag(GAME_TAG.FROZEN) == 0) ? false : true;
            int heroNumAttacksThisTurn = ownHeroCard.GetTag(GAME_TAG.NUM_ATTACKS_THIS_TURN);
            bool heroHasWindfury = (ownHeroCard.GetTag(GAME_TAG.WINDFURY) == 0) ? false : true;
            bool heroImmune = (ownHeroCard.GetTag(GAME_TAG.CANT_BE_DAMAGED) == 0) ? false : true;

            //Helpfunctions.Instance.ErrorLog(ownhero.GetName() + " ready params ex: " + exausted + " " + heroAtk + " " + numberofattacks + " " + herofrozen);


            if (TritonHS.DoWeHaveWeapon)
            {
                HSCard weapon = TritonHS.OurWeaponCard;
                ownHeroWeapon = CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(weapon.Id)).name.ToString();
                heroWeaponAttack = weapon.GetTag(GAME_TAG.ATK);
                heroWeaponDurability = weapon.GetTag(GAME_TAG.DURABILITY) - weapon.GetTag(GAME_TAG.DAMAGE); //weapon.GetDurability();
                if (ownHeroWeapon == "gladiatorslongbow")
                {
                    heroImmuneToDamageWhileAttacking = true;
                }
                if (this.ownHeroWeapon == "doomhammer")
                {
                    heroHasWindfury = true;
                }

                //Helpfunctions.Instance.ErrorLog("weapon: " + ownHeroWeapon + " " + heroWeaponAttack + " " + heroWeaponDurability);
            }



            //enemy hero stuff###############################################################
            this.enemyHeroname = Hrtprozis.Instance.heroIDtoName(TritonHS.EnemyHero.Id);

            int enemyAtk = enemHeroCard.GetTag(GAME_TAG.ATK); //lol should be zero :D
            int enemyHp = enemHeroCard.GetTag(GAME_TAG.HEALTH) - enemHeroCard.GetTag(GAME_TAG.DAMAGE);
            int enemyDefence = enemHeroCard.GetTag(GAME_TAG.ARMOR);
            bool enemyfrozen = (enemHeroCard.GetTag(GAME_TAG.FROZEN) == 0) ? false : true;
            bool enemyHeroImmune = (enemHeroCard.GetTag(GAME_TAG.CANT_BE_DAMAGED) == 0) ? false : true;

            this.enemyHeroWeapon = "";
            this.enemyWeaponAttack = 0;
            this.enemyWeaponDurability = 0;
            if (TritonHS.DoesEnemyHasWeapon)
            {
                HSCard weapon = TritonHS.EnemyWeaponCard;
                enemyHeroWeapon = CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(weapon.Id)).name.ToString();
                enemyWeaponAttack = weapon.GetTag(GAME_TAG.ATK);
                enemyWeaponDurability = weapon.GetTag(GAME_TAG.DURABILITY) - weapon.GetTag(GAME_TAG.DAMAGE);
            }


            //own hero ablity stuff###########################################################

            this.heroAbility = CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(TritonHS.OurHeroPowerCard.Id));
            this.ownAbilityisReady = (TritonHS.OurHeroPowerCard.GetTag(GAME_TAG.EXHAUSTED) == 0) ? true : false;
            this.enemyAbility = CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(TritonHS.OurHeroPowerCard.Id));
            int ownHeroAbilityEntity = TritonHS.OurHeroPowerCard.EntityId;
            foreach (HSCard ent in allcards)
            {
                if (ent.EntityId != ownHeroAbilityEntity && ent.GetTag(GAME_TAG.CARDTYPE) == 10)
                {
                    enemyAbility = CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(ent.Id));
                    break;
                }
            }

            //generate Heros
            this.ownHero = new Minion();
            this.enemyHero = new Minion();
            this.ownHero.isHero = true;
            this.enemyHero.isHero = true;
            this.ownHero.own = true;
            this.enemyHero.own = false;
            this.ownHero.maxHp = ownHeroCard.GetTag(GAME_TAG.HEALTH);
            this.enemyHero.maxHp = enemHeroCard.GetTag(GAME_TAG.HEALTH);
            this.ownHero.entitiyID = ownHeroCard.EntityId;
            this.enemyHero.entitiyID = enemHeroCard.EntityId;

            this.ownHero.Angr = heroAtk;
            this.ownHero.Hp = heroHp;
            this.ownHero.armor = heroDefence;
            this.ownHero.frozen = herofrozen;
            this.ownHero.immuneWhileAttacking = heroImmuneToDamageWhileAttacking;
            this.ownHero.immune = heroImmune;
            this.ownHero.numAttacksThisTurn = heroNumAttacksThisTurn;
            this.ownHero.windfury = heroHasWindfury;

            this.enemyHero.Angr = enemyAtk;
            this.enemyHero.Hp = enemyHp;
            this.enemyHero.frozen = enemyfrozen;
            this.enemyHero.armor = enemyDefence;
            this.enemyHero.immune = enemyHeroImmune;
            this.enemyHero.Ready = false;

            this.ownHero.updateReadyness();


            //load enchantments of the heros
            List<miniEnch> miniEnchlist = new List<miniEnch>();
            foreach (HSCard ent in allcards)
            {
                if (ent.GetTag(GAME_TAG.ATTACHED) == this.ownHero.entitiyID && ent.GetTag(GAME_TAG.ZONE) == 1) //1==play
                {
                    CardDB.cardIDEnum id = CardDB.Instance.cardIdstringToEnum(ent.Id);
                    int controler = ent.GetTag(GAME_TAG.CONTROLLER);
                    int creator = ent.GetTag(GAME_TAG.CREATOR);
                    miniEnchlist.Add(new miniEnch(id, creator, controler));
                }

            }

            this.ownHero.loadEnchantments(miniEnchlist, ownHeroCard.GetTag(GAME_TAG.CONTROLLER));

            miniEnchlist.Clear();

            foreach (HSCard ent in allcards)
            {
                if (ent.GetTag(GAME_TAG.ATTACHED) == this.enemyHero.entitiyID && ent.GetTag(GAME_TAG.ZONE) == 1) //1==play
                {
                    CardDB.cardIDEnum id = CardDB.Instance.cardIdstringToEnum(ent.Id);
                    int controler = ent.GetTag(GAME_TAG.CONTROLLER);
                    int creator = ent.GetTag(GAME_TAG.CREATOR);
                    miniEnchlist.Add(new miniEnch(id, creator, controler));
                }

            }

            this.enemyHero.loadEnchantments(miniEnchlist, enemHeroCard.GetTag(GAME_TAG.CONTROLLER));
            //fastmode weapon correction:
            if (this.ownHero.Angr < this.heroWeaponAttack) this.ownHero.Angr = this.heroWeaponAttack;
            if (this.enemyHero.Angr < this.enemyWeaponAttack) this.enemyHero.Angr = this.enemyWeaponAttack;
        }

        private void getMinions()
        {
            // ALL minions on Playfield:
            List<HSCard> list = TritonHS.GetCards(CardZone.Battlefield, true);
            list.AddRange(TritonHS.GetCards(CardZone.Battlefield, false));

            var enchantments = new List<HSCard>();
            ownMinions.Clear();
            enemyMinions.Clear();
            List<HSCard> allcards = TritonHS.GetAllCards();

            foreach (HSCard entiti in list)
            {
                int zp = entiti.GetTag(GAME_TAG.ZONE_POSITION);

                if (entiti.IsMinion && zp >= 1)
                {

                    HSCard entitiy = entiti;

                    foreach (HSCard ent in allcards)
                    {
                        if (ent.EntityId == entiti.EntityId)
                        {
                            entitiy = ent;
                            break;
                        }
                    }

                    //Helpfunctions.Instance.ErrorLog("zonepos " + zp);
                    CardDB.Card c = CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(entitiy.Id));
                    Minion m = new Minion();
                    m.name = c.name;
                    m.handcard.card = c;

                    m.Angr = entitiy.GetTag(GAME_TAG.ATK);
                    m.maxHp = entitiy.GetTag(GAME_TAG.HEALTH);
                    m.Hp = entitiy.GetTag(GAME_TAG.HEALTH) - entitiy.GetTag(GAME_TAG.DAMAGE);
                    if (m.Hp <= 0) continue;
                    m.wounded = false;
                    if (m.maxHp > m.Hp) m.wounded = true;


                    m.exhausted = (entitiy.GetTag(GAME_TAG.EXHAUSTED) == 0) ? false : true;

                    m.taunt = (entitiy.GetTag(GAME_TAG.TAUNT) == 0) ? false : true;

                    m.numAttacksThisTurn = entitiy.GetTag(GAME_TAG.NUM_ATTACKS_THIS_TURN);

                    int temp = entitiy.GetTag(GAME_TAG.NUM_TURNS_IN_PLAY);
                    m.playedThisTurn = (temp == 0) ? true : false;

                    m.windfury = (entitiy.GetTag(GAME_TAG.WINDFURY) == 0) ? false : true;

                    m.frozen = (entitiy.GetTag(GAME_TAG.FROZEN) == 0) ? false : true;

                    m.divineshild = (entitiy.GetTag(GAME_TAG.DIVINE_SHIELD) == 0) ? false : true;

                    m.stealth = (entitiy.GetTag(GAME_TAG.STEALTH) == 0) ? false : true;

                    m.poisonous = (entitiy.GetTag(GAME_TAG.POISONOUS) == 0) ? false : true;

                    m.immune = (entitiy.GetTag(GAME_TAG.IMMUNE_WHILE_ATTACKING) == 0) ? false : true;

                    m.silenced = (entitiy.GetTag(GAME_TAG.SILENCED) == 0) ? false : true;

                    m.charge = 0;

                    if (!m.silenced && m.name == CardDB.cardName.southseadeckhand && entitiy.GetTag(GAME_TAG.CHARGE) == 1) m.charge = 1;
                    if (!m.silenced && m.handcard.card.Charge) m.charge++;

                    m.zonepos = zp;

                    m.entitiyID = entitiy.EntityId;


                    //Helpfunctions.Instance.ErrorLog(  m.name + " ready params ex: " + m.exhausted + " charge: " +m.charge + " attcksthisturn: " + m.numAttacksThisTurn + " playedthisturn " + m.playedThisTurn );


                    List<miniEnch> enchs = new List<miniEnch>();
                    foreach (HSCard ent in allcards)
                    {
                        if (ent.GetTag(GAME_TAG.ATTACHED) == m.entitiyID && ent.GetTag(GAME_TAG.ZONE) == 1) //1==play
                        {
                            CardDB.cardIDEnum id = CardDB.Instance.cardIdstringToEnum(ent.Id);
                            int controler = ent.GetTag(GAME_TAG.CONTROLLER);
                            int creator = ent.GetTag(GAME_TAG.CREATOR);
                            enchs.Add(new miniEnch(id, creator, controler));
                        }

                    }

                    m.loadEnchantments(enchs, entitiy.GetTag(GAME_TAG.CONTROLLER));

                    m.Ready = false; // if exhausted, he is NOT ready

                    m.updateReadyness();


                    if (entitiy.GetTag(GAME_TAG.CONTROLLER) == this.ownPlayerController) // OWN minion
                    {
                        m.own = true;
                        this.ownMinions.Add(m);
                    }
                    else
                    {
                        m.own = false;
                        this.enemyMinions.Add(m);
                    }

                }



            }


        }

        private void getHandcards()
        {
            handCards.Clear();
            anzcards = 0;
            enemyAnzCards = 0;
            List<HSCard> list = TritonHS.GetCards(CardZone.Hand);
            //List<HRCard> list = HRCard.GetCards(HRPlayer.GetLocalPlayer(), HRCardZone.HAND);

            foreach (HSCard entitiy in list)
            {
                if (entitiy.ZonePosition >= 1) // own handcard 
                {
                    CardDB.Card c = CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(entitiy.Id));
                    //c.cost = entitiy.GetCost();
                    //c.entityID = entitiy.GetEntityId();

                    var hc = new Handmanager.Handcard();
                    hc.card = c;
                    hc.position = entitiy.ZonePosition;
                    hc.entity = entitiy.EntityId;
                    hc.manacost = entitiy.Cost;
                    hc.addattack = 0;
                    if (c.name == CardDB.cardName.bolvarfordragon)
                    {
                        hc.addattack = entitiy.GetTag(GAME_TAG.ATK) -1; // -1 because it starts with 1, we count only the additional attackvalue
                    }
                    handCards.Add(hc);
                    anzcards++;
                }
            }

            List<HSCard> allcards = TritonHS.GetAllCards();
            enemyAnzCards = 0;
            foreach (HSCard hs in allcards)
            {
                if (hs.GetTag(GAME_TAG.ZONE) == 3 && hs.ControllerId != ownPlayerController && hs.GetTag(GAME_TAG.ZONE_POSITION) >= 1) enemyAnzCards++;
            }
            // dont know if you can count the enemys-handcars in this way :D
        }

        private void getDecks()
        {
            List<HSCard> allEntitys = TritonHS.GetAllCards();
            int owncontroler = TritonHS.OurHero.GetTag(GAME_TAG.CONTROLLER);
            int enemycontroler = TritonHS.EnemyHero.GetTag(GAME_TAG.CONTROLLER);
            List<CardDB.cardIDEnum> ownCards = new List<CardDB.cardIDEnum>();
            List<CardDB.cardIDEnum> enemyCards = new List<CardDB.cardIDEnum>();
            List<GraveYardItem> graveYard = new List<GraveYardItem>();

            foreach (HSCard ent in allEntitys)
            {
                if (ent.GetTag(GAME_TAG.ZONE) == 7 && ent.GetTag(GAME_TAG.CONTROLLER) == enemycontroler) continue; // cant know enemy secrets :D
                if (ent.GetTag(GAME_TAG.ZONE) == 2) continue;
                if (ent.GetTag(GAME_TAG.CARDTYPE) == 4 || ent.GetTag(GAME_TAG.CARDTYPE) == 5 || ent.GetTag(GAME_TAG.CARDTYPE) == 7)//is minion, weapon or spell
                {
                    CardDB.cardIDEnum cardid = CardDB.Instance.cardIdstringToEnum(ent.Id);
                    //Helpfunctions.Instance.logg("found " + cardid);

                    if (ent.GetTag(GAME_TAG.ZONE) == 4) // 4 == graveyard
                    {
                        GraveYardItem gyi = new GraveYardItem(cardid, ent.EntityId, ent.GetTag(GAME_TAG.CONTROLLER) == owncontroler);
                        graveYard.Add(gyi);
                    }

                    int creator = ent.GetTag(GAME_TAG.CREATOR);
                    if (creator != 0 && creator != owncontroler && creator != enemycontroler) continue; //if creator is someone else, it was not played

                    if (ent.GetTag(GAME_TAG.CONTROLLER) == owncontroler)
                    {
                        if (ent.GetTag(GAME_TAG.ZONE) == 4) // 4 == graveyard
                        {
                            ownCards.Add(cardid);
                        }
                    }
                    else
                    {
                        if (ent.GetTag(GAME_TAG.ZONE) == 4) // 4 == graveyard
                        {
                            enemyCards.Add(cardid);
                        }
                    }
                }

            }

            Probabilitymaker.Instance.setOwnCards(ownCards);
            Probabilitymaker.Instance.setEnemyCards(enemyCards);
            bool isTurnStart = false;
            if (Ai.Instance.nextMoveGuess.mana == -100)
            {
                isTurnStart = true;
                Ai.Instance.updateTwoTurnSim();
            }
            Probabilitymaker.Instance.setGraveYard(graveYard, isTurnStart);

        }

        private void updateBehaveString(Behavior botbase)
        {
            this.botbehave = "rush";
            if (botbase is BehaviorControl) this.botbehave = "control";
            if (botbase is BehaviorMana) this.botbehave = "mana";
            this.botbehave += " " + Ai.Instance.maxwide;
            this.botbehave += " face " + ComboBreaker.Instance.attackFaceHP;
            if (Settings.Instance.secondTurnAmount > 0)
            {
                if (Ai.Instance.nextMoveGuess.mana == -100)
                {
                    Ai.Instance.updateTwoTurnSim();
                }
                this.botbehave += " twoturnsim " + Settings.Instance.secondTurnAmount + " ntss " + Settings.Instance.nextTurnDeep + " " + Settings.Instance.nextTurnMaxWide + " " + Settings.Instance.nextTurnTotalBoards;
            }

            if (Settings.Instance.playarround)
            {
                this.botbehave += " playaround";
                this.botbehave += " " + Settings.Instance.playaroundprob + " " + Settings.Instance.playaroundprob2;
            }

            this.botbehave += " ets " + Settings.Instance.enemyTurnMaxWide;

            if (Settings.Instance.simEnemySecondTurn)
            {
                this.botbehave += " ets2 " + Settings.Instance.enemyTurnMaxWideSecondTime;
                this.botbehave += " ents " + Settings.Instance.enemySecondTurnMaxWide;
            }

            if (Settings.Instance.useSecretsPlayArround)
            {
                this.botbehave += " secret";
            }

            if (Settings.Instance.secondweight != 0.5f)
            {
                this.botbehave += " weight " + (int)(Settings.Instance.secondweight * 100f);
            }

            if (Settings.Instance.simulatePlacement)
            {
                this.botbehave += " plcmnt";
            }


        }

        public static int getLastAffected(int entityid)
        {

            List<HSCard> allEntitys = TritonHS.GetAllCards();

            foreach (HSCard ent in allEntitys)
            {
                if (ent.GetTag(GAME_TAG.LAST_AFFECTED_BY) == entityid) return ent.GetTag(GAME_TAG.ENTITY_ID);
            }

            return 0;
        }

        public static int getCardTarget(int entityid)
        {

            List<HSCard> allEntitys = TritonHS.GetAllCards();

            foreach (HSCard ent in allEntitys)
            {
                if (ent.GetTag(GAME_TAG.ENTITY_ID) == entityid) return ent.GetTag(GAME_TAG.CARD_TARGET);
            }

            return 0;

        }

        private void printstuff(bool runEx)
        {
            int ownsecretcount = ownSecretList.Count;
            string dtimes = DateTime.Now.ToString("HH:mm:ss:ffff");
            string enemysecretIds = "";
            enemysecretIds = Probabilitymaker.Instance.getEnemySecretData();
            Helpfunctions.Instance.logg("#######################################################################");
            Helpfunctions.Instance.logg("#######################################################################");
            Helpfunctions.Instance.logg("start calculations, current time: " + DateTime.Now.ToString("HH:mm:ss") + " V" + this.versionnumber + " " + this.botbehave);
            Helpfunctions.Instance.logg("#######################################################################");
            Helpfunctions.Instance.logg("mana " + currentMana + "/" + ownMaxMana);
            Helpfunctions.Instance.logg("emana " + enemyMaxMana);
            Helpfunctions.Instance.logg("own secretsCount: " + ownsecretcount);
            Helpfunctions.Instance.logg("enemy secretsCount: " + enemySecretCount + " ;" + enemysecretIds);

            Ai.Instance.currentCalculatedBoard = dtimes;

            if (runEx)
            {
                Helpfunctions.Instance.resetBuffer();
                Helpfunctions.Instance.writeBufferToActionFile();
                Helpfunctions.Instance.resetBuffer();

                Helpfunctions.Instance.writeToBuffer("#######################################################################");
                Helpfunctions.Instance.writeToBuffer("#######################################################################");
                Helpfunctions.Instance.writeToBuffer("start calculations, current time: " + dtimes + " V" + this.versionnumber + " " + this.botbehave);
                Helpfunctions.Instance.writeToBuffer("#######################################################################");
                Helpfunctions.Instance.writeToBuffer("mana " + currentMana + "/" + ownMaxMana);
                Helpfunctions.Instance.writeToBuffer("emana " + enemyMaxMana);
                Helpfunctions.Instance.writeToBuffer("own secretsCount: " + ownsecretcount);
                Helpfunctions.Instance.writeToBuffer("enemy secretsCount: " + enemySecretCount + " ;" + enemysecretIds);
            }
            Hrtprozis.Instance.printHero(runEx);
            Hrtprozis.Instance.printOwnMinions(runEx);
            Hrtprozis.Instance.printEnemyMinions(runEx);
            Handmanager.Instance.printcards(runEx);
            Probabilitymaker.Instance.printTurnGraveYard(runEx);
            Probabilitymaker.Instance.printGraveyards(runEx);

            if (runEx) Helpfunctions.Instance.writeBufferToFile();

        }

        public bool readActionFile(bool passiveWaiting = false)
        {
            bool readed = true;
            List<string> alist = new List<string>();
            float value = 0f;
            string boardnumm = "-1";
            this.waitingForSilver = true;
            while (readed)
            {
                try
                {
                    string data = System.IO.File.ReadAllText(Settings.Instance.path + "actionstodo.txt");
                    if (data != "" && data != "<EoF>" && data.EndsWith("<EoF>"))
                    {
                        data = data.Replace("<EoF>", "");
                        //Helpfunctions.Instance.ErrorLog(data);
                        Helpfunctions.Instance.resetBuffer();
                        Helpfunctions.Instance.writeBufferToActionFile();
                        alist.AddRange(data.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries));
                        string board = alist[0];
                        if (board.StartsWith("board "))
                        {
                            boardnumm = (board.Split(' ')[1].Split(' ')[0]);
                            alist.RemoveAt(0);
                            if (boardnumm != Ai.Instance.currentCalculatedBoard)
                            {
                                if (passiveWaiting)
                                {
                                    System.Threading.Thread.Sleep(10);
                                    return false;
                                }
                                continue;
                            }
                        }
                        string first = alist[0];
                        if (first.StartsWith("value "))
                        {
                            value = float.Parse((first.Split(' ')[1].Split(' ')[0]));
                            alist.RemoveAt(0);
                        }
                        readed = false;
                    }
                    else
                    {
                        System.Threading.Thread.Sleep(10);
                        if (passiveWaiting)
                        {
                            return false;
                        }
                    }

                }
                catch
                {
                    System.Threading.Thread.Sleep(10);
                }

            }
            this.waitingForSilver = false;
            Helpfunctions.Instance.logg("received " + boardnumm + " actions to do:");
            Ai.Instance.currentCalculatedBoard = "0";
            Playfield p = new Playfield();
            List<Action> aclist = new List<Action>();

            foreach (string a in alist)
            {
                aclist.Add(new Action(a, p));
                Helpfunctions.Instance.logg(a);
            }

            Ai.Instance.setBestMoves(aclist, value);

            return true;
        }

    }

    public class Helpfunctions
    {

        public static List<T> TakeList<T>(IEnumerable<T> source, int limit)
        {
            List<T> retlist = new List<T>();
            int i = 0;

            foreach (T item in source)
            {
                retlist.Add(item);
                i++;

                if (i >= limit) break;
            }
            return retlist;
        }


        public bool runningbot = false;

        private static Helpfunctions instance;

        public static Helpfunctions Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new Helpfunctions();
                }
                return instance;
            }
        }

        private Helpfunctions()
        {

            System.IO.File.WriteAllText(Settings.Instance.logpath + Settings.Instance.logfile, "");
        }

        private bool writelogg = true;
        public void loggonoff(bool onoff)
        {
            //writelogg = onoff;
        }

        public void createNewLoggfile()
        {
            System.IO.File.WriteAllText(Settings.Instance.logpath + Settings.Instance.logfile, "");
        }

        public void logg(string s)
        {


            if (!writelogg) return;
            try
            {
                using (StreamWriter sw = File.AppendText(Settings.Instance.logpath + Settings.Instance.logfile))
                {
                    sw.WriteLine(s);
                }
            }
            catch { }
        }

        public DateTime UnixTimeStampToDateTime(int unixTimeStamp)
        {
            // Unix timestamp is seconds past epoch
            System.DateTime dtDateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
            dtDateTime = dtDateTime.AddSeconds(unixTimeStamp).ToLocalTime();
            return dtDateTime;
        }

        public void ErrorLog(string s)
        {
            Logging.Write(s);
        }

        string sendbuffer = "";
        public void resetBuffer()
        {
            this.sendbuffer = "";
        }

        public void writeToBuffer(string data)
        {
            this.sendbuffer += "\r\n" + data;
        }

        public void writeBufferToFile()
        {
            bool writed = true;
            this.sendbuffer += "<EoF>";
            while (writed)
            {
                try
                {
                    System.IO.File.WriteAllText(Settings.Instance.path + "crrntbrd.txt", this.sendbuffer);
                    writed = false;
                }
                catch
                {
                    writed = true;
                }
            }
            this.sendbuffer = "";
        }

        public void writeBufferToActionFile()
        {
            bool writed = true;
            this.sendbuffer += "<EoF>";
            while (writed)
            {
                try
                {
                    System.IO.File.WriteAllText(Settings.Instance.path + "actionstodo.txt", this.sendbuffer);
                    writed = false;
                }
                catch
                {
                    writed = true;
                }
            }
            this.sendbuffer = "";

        }
   
    }


    // the ai :D
    //please ask/write me if you use this in your project


    public enum actionEnum
    {
        endturn = 0,
        playcard,
        attackWithHero,
        useHeroPower,
        attackWithMinion
    }
    //todo make to struct

    public class Action
    {

        public actionEnum actionType;
        public Handmanager.Handcard card;
        //public int cardEntitiy;
        public int place; //= target where card/minion is placed
        public Minion own;
        public Minion target;
        public int druidchoice; // 1 left card, 2 right card
        public int penalty;

        public Action(actionEnum type, Handmanager.Handcard hc, Minion ownCardEntity, int place, Minion target, int pen, int choice)
        {
            this.actionType = type;
            this.card = hc;
            this.own = ownCardEntity;
            this.place = place;
            this.target = target;
            this.penalty = pen;
            this.druidchoice = choice;

        }

        public Action(string s, Playfield p)
        {
            if (s.StartsWith("play "))
            {
                this.actionType = actionEnum.playcard;

                int cardEnt = Convert.ToInt32(s.Split(new string[] { "id " }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                int targetEnt = -1;
                if (s.Contains("target ")) targetEnt = Convert.ToInt32(s.Split(new string[] { "target " }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                int place = 0;
                if (s.Contains("pos ")) place = Convert.ToInt32(s.Split(new string[] { "pos " }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                int choice = 0;
                if (s.Contains("choice ")) choice = Convert.ToInt32(s.Split(new string[] { "choice " }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);

                this.own = null;

                this.card = new Handmanager.Handcard { entity = cardEnt };

                if (targetEnt >= 0)
                {
                    Minion m = new Minion { entitiyID = targetEnt };
                    this.target = m;
                }
                else
                {
                    this.target = null;
                }

                this.place = place;
                this.druidchoice = choice;

            }

            if (s.StartsWith("attack "))
            {
                this.actionType = actionEnum.attackWithMinion;

                int ownEnt = Convert.ToInt32(s.Split(' ')[1].Split(' ')[0]);
                int targetEnt = Convert.ToInt32(s.Split(' ')[3].Split(' ')[0]);

                this.place = 0;
                this.druidchoice = 0;

                this.card = null;

                Minion m = new Minion { entitiyID = targetEnt };
                this.target = m;

                Minion o = new Minion();
                o.entitiyID = ownEnt;
                this.own = o;
            }

            if (s.StartsWith("heroattack "))
            {
                this.actionType = actionEnum.attackWithHero;

                int targetEnt = Convert.ToInt32(s.Split(' ')[1].Split(' ')[0]);

                this.place = 0;
                this.druidchoice = 0;

                this.card = null;

                Minion m = new Minion { entitiyID = targetEnt };
                this.target = m;

                this.own = p.ownHero;

            }

            if (s.StartsWith("useability on target "))
            {
                this.actionType = actionEnum.useHeroPower;

                int targetEnt = Convert.ToInt32(s.Split(' ')[3].Split(' ')[0]);

                this.place = 0;
                this.druidchoice = 0;

                this.card = null;

                Minion m = new Minion { entitiyID = targetEnt };
                this.target = m;

                this.own = null;

            }

            if (s == "useability")
            {
                this.actionType = actionEnum.useHeroPower;
                this.place = 0;
                this.druidchoice = 0;
                this.card = null;
                this.own = null;
                this.target = null;
            }

        }

        public Action(Action a)
        {
            this.actionType = a.actionType;
            this.card = a.card;
            this.place = a.place;
            this.own = a.own;
            this.target = a.target;
            this.druidchoice = a.druidchoice;
            this.penalty = a.penalty;
        }

        public void print(bool tobuffer = false)
        {
            Helpfunctions help = Helpfunctions.Instance;
            if (tobuffer)
            {
                if (this.actionType == actionEnum.playcard)
                {
                    string playaction = "play ";

                    playaction += "id " + this.card.entity;
                    if (this.target != null)
                    {
                        playaction += " target " + this.target.entitiyID;
                    }

                    if (this.place >= 0)
                    {
                        playaction += " pos " + this.place;
                    }

                    if (this.druidchoice >= 1) playaction += " choice " + this.druidchoice;

                    help.writeToBuffer(playaction);
                }
                if (this.actionType == actionEnum.attackWithMinion)
                {
                    help.writeToBuffer("attack " + this.own.entitiyID + " enemy " + this.target.entitiyID);
                }
                if (this.actionType == actionEnum.attackWithHero)
                {
                    help.writeToBuffer("heroattack " + this.target.entitiyID);
                }
                if (this.actionType == actionEnum.useHeroPower)
                {

                    if (this.target != null)
                    {
                        help.writeToBuffer("useability on target " + this.target.entitiyID);
                    }
                    else
                    {
                        help.writeToBuffer("useability");
                    }
                }
                return;
            }
            if (this.actionType == actionEnum.playcard)
            {
                string playaction = "play ";

                playaction += "id " + this.card.entity;
                if (this.target != null)
                {
                    playaction += " target " + this.target.entitiyID;
                }

                if (this.place >= 0)
                {
                    playaction += " pos " + this.place;
                }

                if (this.druidchoice >= 1) playaction += " choice " + this.druidchoice;

                help.logg(playaction);
            }
            if (this.actionType == actionEnum.attackWithMinion)
            {
                help.logg("attacker: " + this.own.entitiyID + " enemy: " + this.target.entitiyID);
            }
            if (this.actionType == actionEnum.attackWithHero)
            {
                help.logg("attack with hero, enemy: " + this.target.entitiyID);
            }
            if (this.actionType == actionEnum.useHeroPower)
            {
                help.logg("useability ");
                if (this.target != null)
                {
                    help.logg("on enemy: " + this.target.entitiyID);
                }
            }
            help.logg("");
        }

    }

    public struct triggerCounter
    {
        public int minionsGotHealed;

        public int charsGotHealed;

        public int ownMinionsGotDmg;
        public int enemyMinionsGotDmg;

        public int ownHeroGotDmg;
        public int enemyHeroGotDmg;

        public int ownMinionsDied;
        public int enemyMinionsDied;
        public int ownBeastDied;
        public int enemyBeastDied;
        public int ownMechanicDied;
        public int enemyMechanicDied;
        public int ownMurlocDied;
        public int enemyMurlocDied;

        public bool ownMinionsChanged;
        public bool enemyMininsChanged;
    }

    //todo save "started" variables outside (they doesnt change)

    public class Playfield
    {
        //Todo: delete all new list<minion>
        //TODO: graveyard change (list <card,owner>)
        //Todo: vanish clear all auras/buffs (NEW1_004)

        public bool logging = false;
        public bool complete = false;

        public int nextEntity = 70;

        public triggerCounter tempTrigger = new triggerCounter();

        //aura minions##########################
        //todo reduce buffing vars
        public int anzOwnRaidleader = 0;
        public int anzEnemyRaidleader = 0;
        public int anzOwnStormwindChamps = 0;
        public int anzEnemyStormwindChamps = 0;
        public int anzOwnTundrarhino = 0;
        public int anzEnemyTundrarhino = 0;
        public int anzOwnTimberWolfs = 0;
        public int anzEnemyTimberWolfs = 0;
        public int anzMurlocWarleader = 0;
        public int anzGrimscaleOracle = 0;
        public int anzOwnAuchenaiSoulpriest = 0;
        public int anzEnemyAuchenaiSoulpriest = 0;
        public int anzOwnsorcerersapprentice = 0;
        public int anzOwnsorcerersapprenticeStarted = 0;
        public int anzEnemysorcerersapprentice = 0;
        public int anzEnemysorcerersapprenticeStarted = 0;
        public int anzOwnSouthseacaptain = 0;
        public int anzEnemySouthseacaptain = 0;
        public int anzOwnMalGanis = 0;
        public int anzEnemyMalGanis = 0;

        public int anzOwnMechwarper = 0;
        public int anzOwnMechwarperStarted = 0;
        public int anzEnemyMechwarper = 0;
        public int anzEnemyMechwarperStarted = 0;

        public bool feugenDead = false;
        public bool stalaggDead = false;

        public bool weHavePlayedMillhouseManastorm = false;
        public bool weHaveSteamwheedleSniper = false;
        public bool enemyHaveSteamwheedleSniper = false;

        public bool needGraveyard = false;


        public int doublepriest = 0;
        public int enemydoublepriest = 0;


        public int ownBaronRivendare = 0;
        public int enemyBaronRivendare = 0;
        //#########################################

        public int tempanzOwnCards = 0; // for Goblin Sapper
        public int tempanzEnemyCards = 0;// for Goblin Sapper

        public bool isOwnTurn = true; // its your turn?
        public int turnCounter = 0;
        public bool sEnemTurn = false;//should the enemy turn be simulated?

        public bool attacked = false;
        public int attackFaceHP = 15;

        public int evaluatePenality = 0;
        public int ownController = 0;

        //public int ownHeroEntity = -1;
        //public int enemyHeroEntity = -1;

        public int hashcode = 0;
        public float value = Int32.MinValue;
        public int guessingHeroHP = 30;

        public int mana = 0;
        public int manaTurnEnd = 0;



        public List<CardDB.cardIDEnum> ownSecretsIDList = new List<CardDB.cardIDEnum>();
        public List<SecretItem> enemySecretList = new List<SecretItem>();

        public int enemySecretCount = 0;

        public Minion ownHero;
        public Minion enemyHero;
        public HeroEnum ownHeroName = HeroEnum.druid;
        public HeroEnum enemyHeroName = HeroEnum.druid;

        public CardDB.cardName ownWeaponName = CardDB.cardName.unknown;
        public int ownWeaponAttack = 0;
        public int ownWeaponDurability = 0;

        public CardDB.cardName enemyWeaponName = CardDB.cardName.unknown;
        public int enemyWeaponAttack = 0;
        public int enemyWeaponDurability = 0;

        public List<Minion> ownMinions = new List<Minion>();
        public List<Minion> enemyMinions = new List<Minion>();
        public List<GraveYardItem> diedMinions = null;

        public List<Handmanager.Handcard> owncards = new List<Handmanager.Handcard>();
        public int owncarddraw = 0;

        public List<Action> playactions = new List<Action>();

        public int enemycarddraw = 0;
        public int enemyAnzCards = 0;

        public int spellpower = 0;
        public int enemyspellpower = 0;

        public bool playedmagierinderkirintor = false;
        public bool playedPreparation = false;

        public bool loatheb = false;
        public int winzigebeschwoererin = 0;
        public int startedWithWinzigebeschwoererin = 0;
        public int managespenst = 0;
        public int startedWithManagespenst = 0;
        public int soeldnerDerVenture = 0;
        public int startedWithsoeldnerDerVenture = 0;
        public int beschwoerungsportal = 0;
        public int startedWithbeschwoerungsportal = 0;
        public int nerubarweblord = 0;
        public int startedWithnerubarweblord = 0;

        public bool startedWithDamagedMinions = false; // needed for manacalculation of the spell "Crush"

        public int ownWeaponAttackStarted = 0;
        public int ownMobsCountStarted = 0;
        public int ownCardsCountStarted = 0;
        public int enemyCardsCountStarted = 0;
        public int ownHeroHpStarted = 30;
        public int enemyHeroHpStarted = 30;

        public int mobsplayedThisTurn = 0;
        public int startedWithMobsPlayedThisTurn = 0;

        public int optionsPlayedThisTurn = 0;
        public int cardsPlayedThisTurn = 0;
        public int ueberladung = 0; //=recall

        public int enemyOptionsDoneThisTurn = 0;

        public int ownMaxMana = 0;
        public int enemyMaxMana = 0;

        public int lostDamage = 0;
        public int lostHeal = 0;
        public int lostWeaponDamage = 0;

        public int ownDeckSize = 30;
        public int enemyDeckSize = 30;
        public int ownHeroFatigue = 0;
        public int enemyHeroFatigue = 0;

        public bool ownAbilityReady = false;
        public Handmanager.Handcard ownHeroAblility;

        public bool enemyAbilityReady = false;
        public Handmanager.Handcard enemyHeroAblility;

        // just for saving which minion to revive with secrets (=the first one that died);
        public CardDB.cardIDEnum revivingOwnMinion = CardDB.cardIDEnum.None;
        public CardDB.cardIDEnum revivingEnemyMinion = CardDB.cardIDEnum.None;

        //Helpfunctions help = Helpfunctions.Instance;

        private void addMinionsReal(List<Minion> source, List<Minion> trgt)
        {
            foreach (Minion m in source)
            {
                trgt.Add(new Minion(m));
            }

        }

        private void addCardsReal(List<Handmanager.Handcard> source)
        {

            foreach (Handmanager.Handcard m in source)
            {
                this.owncards.Add(new Handmanager.Handcard(m));
            }

        }

        public Playfield()
        {
            this.nextEntity = 1000;
            //this.simulateEnemyTurn = Ai.Instance.simulateEnemyTurn;
            this.ownController = Hrtprozis.Instance.getOwnController();

            //this.ownHeroEntity = Hrtprozis.Instance.ownHeroEntity;
            //this.enemyHeroEntity = Hrtprozis.Instance.enemyHeroEntitiy;

            this.mana = Hrtprozis.Instance.currentMana;
            this.manaTurnEnd = this.mana;
            this.ownMaxMana = Hrtprozis.Instance.ownMaxMana;
            this.enemyMaxMana = Hrtprozis.Instance.enemyMaxMana;
            this.evaluatePenality = 0;
            this.ownSecretsIDList.AddRange(Hrtprozis.Instance.ownSecretList);
            this.enemySecretCount = Hrtprozis.Instance.enemySecretCount;


            this.attackFaceHP = Hrtprozis.Instance.attackFaceHp;

            this.complete = false;

            addMinionsReal(Hrtprozis.Instance.ownMinions, ownMinions);
            addMinionsReal(Hrtprozis.Instance.enemyMinions, enemyMinions);
            this.ownHero = new Minion(Hrtprozis.Instance.ownHero);
            this.enemyHero = new Minion(Hrtprozis.Instance.enemyHero);
            addCardsReal(Handmanager.Instance.handCards);

            this.enemySecretList.Clear();
            if (Settings.Instance.useSecretsPlayArround)
            {
                foreach (SecretItem si in Probabilitymaker.Instance.enemySecrets)
                {
                    this.enemySecretList.Add(new SecretItem(si));
                }
            }

            this.ownHeroName = Hrtprozis.Instance.heroname;
            this.enemyHeroName = Hrtprozis.Instance.enemyHeroname;

            /*
            this.enemyHeroHp = Hrtprozis.Instance.enemyHp;
            this.ownHeroHp = Hrtprozis.Instance.heroHp;
            this.ownHeroReady = Hrtprozis.Instance.ownheroisread;
            this.ownHeroWindfury = Hrtprozis.Instance.ownHeroWindfury;
            this.ownHeroNumAttackThisTurn = Hrtprozis.Instance.ownHeroNumAttacksThisTurn;
            this.ownHeroFrozen = Hrtprozis.Instance.herofrozen;
            this.enemyHeroFrozen = Hrtprozis.Instance.enemyfrozen;
            this.ownheroAngr = Hrtprozis.Instance.heroAtk;
            this.heroImmuneWhileAttacking = Hrtprozis.Instance.heroImmuneToDamageWhileAttacking;
            this.ownHeroDefence = Hrtprozis.Instance.heroDefence;
            this.enemyHeroDefence = Hrtprozis.Instance.enemyDefence;
             */

            //####buffs#############################

            this.anzOwnRaidleader = 0;
            this.anzEnemyRaidleader = 0;
            this.anzOwnStormwindChamps = 0;
            this.anzEnemyStormwindChamps = 0;
            this.anzOwnTundrarhino = 0;
            this.anzEnemyTundrarhino = 0;
            this.anzOwnTimberWolfs = 0;
            this.anzEnemyTimberWolfs = 0;
            this.anzMurlocWarleader = 0;
            this.anzGrimscaleOracle = 0;
            this.anzOwnAuchenaiSoulpriest = 0;
            this.anzEnemyAuchenaiSoulpriest = 0;
            this.anzOwnsorcerersapprentice = 0;
            this.anzOwnsorcerersapprenticeStarted = 0;
            this.anzEnemysorcerersapprentice = 0;
            this.anzEnemysorcerersapprenticeStarted = 0;
            this.anzOwnSouthseacaptain = 0;
            this.anzEnemySouthseacaptain = 0;

            this.feugenDead = Probabilitymaker.Instance.feugenDead;
            this.stalaggDead = Probabilitymaker.Instance.stalaggDead;

            this.weHavePlayedMillhouseManastorm = false;

            this.doublepriest = 0;
            this.enemydoublepriest = 0;

            this.ownBaronRivendare = 0;
            this.enemyBaronRivendare = 0;
            //#########################################

            this.ownWeaponDurability = Hrtprozis.Instance.heroWeaponDurability;
            this.ownWeaponAttack = Hrtprozis.Instance.heroWeaponAttack;
            this.ownWeaponName = Hrtprozis.Instance.ownHeroWeapon;
            this.owncarddraw = 0;


            this.enemyWeaponAttack = Hrtprozis.Instance.enemyWeaponAttack;//dont know jet
            this.enemyWeaponName = Hrtprozis.Instance.enemyHeroWeapon;
            this.enemyWeaponDurability = Hrtprozis.Instance.enemyWeaponDurability;
            this.enemycarddraw = 0;

            this.enemyAnzCards = Handmanager.Instance.enemyAnzCards;

            this.ownAbilityReady = Hrtprozis.Instance.ownAbilityisReady;
            this.ownHeroAblility = new Handmanager.Handcard(Hrtprozis.Instance.heroAbility);
            this.enemyHeroAblility = new Handmanager.Handcard(Hrtprozis.Instance.enemyAbility);
            this.enemyAbilityReady = false;


            this.mobsplayedThisTurn = Hrtprozis.Instance.numMinionsPlayedThisTurn;
            this.startedWithMobsPlayedThisTurn = Hrtprozis.Instance.numMinionsPlayedThisTurn;// only change mobsplayedthisturm
            this.cardsPlayedThisTurn = Hrtprozis.Instance.cardsPlayedThisTurn;
            //todo:
            this.optionsPlayedThisTurn = Hrtprozis.Instance.numOptionsPlayedThisTurn;

            this.ueberladung = Hrtprozis.Instance.ueberladung;

            this.ownHeroFatigue = Hrtprozis.Instance.ownHeroFatigue;
            this.enemyHeroFatigue = Hrtprozis.Instance.enemyHeroFatigue;
            this.ownDeckSize = Hrtprozis.Instance.ownDeckSize;
            this.enemyDeckSize = Hrtprozis.Instance.enemyDeckSize;

            //need the following for manacost-calculation
            this.ownHeroHpStarted = this.ownHero.Hp;
            this.enemyHeroHpStarted = this.enemyHero.Hp;
            this.ownWeaponAttackStarted = this.ownWeaponAttack;
            this.ownCardsCountStarted = this.owncards.Count;
            this.enemyCardsCountStarted = this.enemyAnzCards;
            this.ownMobsCountStarted = this.ownMinions.Count + this.enemyMinions.Count;

            this.playedmagierinderkirintor = false;
            this.playedPreparation = false;

            this.winzigebeschwoererin = 0;
            this.managespenst = 0;
            this.soeldnerDerVenture = 0;
            this.beschwoerungsportal = 0;
            this.nerubarweblord = 0;

            this.startedWithnerubarweblord = 0;
            this.startedWithbeschwoerungsportal = 0;
            this.startedWithManagespenst = 0;
            this.startedWithWinzigebeschwoererin = 0;
            this.startedWithsoeldnerDerVenture = 0;

            this.ownBaronRivendare = 0;
            this.enemyBaronRivendare = 0;

            needGraveyard = false;
            this.loatheb = false;
            this.spellpower = 0;
            this.enemyspellpower = 0;

            this.startedWithDamagedMinions = false;

            foreach (Minion m in this.ownMinions)
            {
                if (m.Hp < m.maxHp && m.Hp >= 1) this.startedWithDamagedMinions = true;
                if (m.playedThisTurn && m.name == CardDB.cardName.loatheb) this.loatheb = true;

                spellpower = spellpower + m.spellpower;
                if (m.silenced) continue;
                spellpower += m.handcard.card.spellpowervalue;
                if (m.name == CardDB.cardName.prophetvelen) this.doublepriest++;


                if (m.name == CardDB.cardName.pintsizedsummoner)
                {
                    this.winzigebeschwoererin++;
                    this.startedWithWinzigebeschwoererin++;
                }

                if (m.name == CardDB.cardName.manawraith)
                {
                    this.managespenst++;
                    this.startedWithManagespenst++;
                }
                if (m.name == CardDB.cardName.nerubarweblord)
                {
                    this.nerubarweblord++;
                    this.startedWithnerubarweblord++;
                }
                if (m.name == CardDB.cardName.venturecomercenary)
                {
                    this.soeldnerDerVenture++;
                    this.startedWithsoeldnerDerVenture++;
                }
                if (m.name == CardDB.cardName.summoningportal)
                {
                    this.beschwoerungsportal++;
                    this.startedWithbeschwoerungsportal++;
                }

                if (m.handcard.card.name == CardDB.cardName.baronrivendare)
                {
                    this.ownBaronRivendare++;
                }
                if (m.handcard.card.name == CardDB.cardName.kelthuzad)
                {
                    this.needGraveyard = true;
                }

                if (m.name == CardDB.cardName.raidleader) this.anzOwnRaidleader++;
                if (m.name == CardDB.cardName.malganis) this.anzOwnMalGanis++;
                if (m.name == CardDB.cardName.stormwindchampion) this.anzOwnStormwindChamps++;
                if (m.name == CardDB.cardName.tundrarhino) this.anzOwnTundrarhino++;
                if (m.name == CardDB.cardName.timberwolf) this.anzOwnTimberWolfs++;
                if (m.name == CardDB.cardName.murlocwarleader) this.anzMurlocWarleader++;
                if (m.name == CardDB.cardName.grimscaleoracle) this.anzGrimscaleOracle++;
                if (m.name == CardDB.cardName.auchenaisoulpriest) this.anzOwnAuchenaiSoulpriest++;
                if (m.name == CardDB.cardName.sorcerersapprentice)
                {
                    this.anzOwnsorcerersapprentice++;
                    this.anzOwnsorcerersapprenticeStarted++;
                }
                if (m.name == CardDB.cardName.southseacaptain) this.anzOwnSouthseacaptain++;
                if (m.name == CardDB.cardName.mechwarper)
                {
                    this.anzOwnMechwarper++;
                    this.anzOwnMechwarperStarted++;
                }
                if (m.name == CardDB.cardName.steamwheedlesniper && this.ownHeroName == HeroEnum.hunter)
                {
                    this.weHaveSteamwheedleSniper = true;
                }

            }

            foreach (Handmanager.Handcard hc in this.owncards)
            {

                if (hc.card.name == CardDB.cardName.kelthuzad)
                {
                    this.needGraveyard = true;
                }
            }

            foreach (Minion m in this.enemyMinions)
            {
                this.enemyspellpower = this.enemyspellpower + m.spellpower;
                enemyspellpower += m.handcard.card.spellpowervalue;
                if (m.silenced) continue;
                if (m.name == CardDB.cardName.prophetvelen) this.enemydoublepriest++;
                if (m.name == CardDB.cardName.manawraith)
                {
                    this.managespenst++;
                    this.startedWithManagespenst++;
                }
                if (m.name == CardDB.cardName.nerubarweblord)
                {
                    this.nerubarweblord++;
                    this.startedWithnerubarweblord++;
                }
                if (m.handcard.card.name == CardDB.cardName.baronrivendare)
                {
                    this.enemyBaronRivendare++;
                }
                if (m.handcard.card.name == CardDB.cardName.kelthuzad)
                {
                    this.needGraveyard = true;
                }

                if (m.name == CardDB.cardName.raidleader) this.anzEnemyRaidleader++;
                if (m.name == CardDB.cardName.malganis) this.anzEnemyMalGanis++;
                if (m.name == CardDB.cardName.stormwindchampion) this.anzEnemyStormwindChamps++;
                if (m.name == CardDB.cardName.tundrarhino) this.anzEnemyTundrarhino++;
                if (m.name == CardDB.cardName.timberwolf) this.anzEnemyTimberWolfs++;
                if (m.name == CardDB.cardName.murlocwarleader) this.anzMurlocWarleader++;
                if (m.name == CardDB.cardName.grimscaleoracle) this.anzGrimscaleOracle++;
                if (m.name == CardDB.cardName.auchenaisoulpriest) this.anzEnemyAuchenaiSoulpriest++;
                if (m.name == CardDB.cardName.sorcerersapprentice)
                {
                    this.anzEnemysorcerersapprentice++;
                    this.anzEnemysorcerersapprenticeStarted++;
                }
                if (m.name == CardDB.cardName.southseacaptain) this.anzEnemySouthseacaptain++;
                if (m.name == CardDB.cardName.mechwarper)
                {
                    this.anzEnemyMechwarper++;
                    this.anzEnemyMechwarperStarted++;
                }
                if (m.name == CardDB.cardName.steamwheedlesniper && this.enemyHeroName == HeroEnum.hunter)
                {
                    this.enemyHaveSteamwheedleSniper = true;
                }
            }
            if (this.enemySecretCount >= 1) this.needGraveyard = true;
            if (this.needGraveyard) this.diedMinions = new List<GraveYardItem>(Probabilitymaker.Instance.turngraveyard);

            this.tempanzOwnCards = this.owncards.Count;
            this.tempanzEnemyCards = this.enemyAnzCards;


        }

        public Playfield(Playfield p)
        {

            this.nextEntity = p.nextEntity;

            this.isOwnTurn = p.isOwnTurn;
            this.turnCounter = p.turnCounter;

            this.attacked = p.attacked;
            this.sEnemTurn = p.sEnemTurn;
            this.ownController = p.ownController;
            //this.ownHeroEntity = p.ownHeroEntity;
            //this.enemyHeroEntity = p.enemyHeroEntity;

            this.evaluatePenality = p.evaluatePenality;
            this.ownSecretsIDList.AddRange(p.ownSecretsIDList);

            this.enemySecretCount = p.enemySecretCount;

            this.enemySecretList.Clear();
            if (Settings.Instance.useSecretsPlayArround)
            {
                foreach (SecretItem si in p.enemySecretList)
                {
                    this.enemySecretList.Add(new SecretItem(si));
                }
            }

            this.mana = p.mana;
            this.manaTurnEnd = p.manaTurnEnd;
            this.ownMaxMana = p.ownMaxMana;
            this.enemyMaxMana = p.enemyMaxMana;
            addMinionsReal(p.ownMinions, ownMinions);
            addMinionsReal(p.enemyMinions, enemyMinions);
            this.ownHero = new Minion(p.ownHero);
            this.enemyHero = new Minion(p.enemyHero);
            addCardsReal(p.owncards);

            this.ownHeroName = p.ownHeroName;
            this.enemyHeroName = p.enemyHeroName;

            this.playactions.AddRange(p.playactions);
            this.complete = false;

            this.attackFaceHP = p.attackFaceHP;

            this.owncarddraw = p.owncarddraw;

            this.enemyWeaponAttack = p.enemyWeaponAttack;
            this.enemyWeaponDurability = p.enemyWeaponDurability;
            this.enemyWeaponName = p.enemyWeaponName;
            this.enemycarddraw = p.enemycarddraw;
            this.enemyAnzCards = p.enemyAnzCards;

            this.ownWeaponDurability = p.ownWeaponDurability;
            this.ownWeaponAttack = p.ownWeaponAttack;
            this.ownWeaponName = p.ownWeaponName;

            this.lostDamage = p.lostDamage;
            this.lostWeaponDamage = p.lostWeaponDamage;
            this.lostHeal = p.lostHeal;

            this.ownAbilityReady = p.ownAbilityReady;
            this.enemyAbilityReady = p.enemyAbilityReady;
            this.ownHeroAblility = new Handmanager.Handcard(p.ownHeroAblility);
            this.enemyHeroAblility = new Handmanager.Handcard(p.enemyHeroAblility);

            this.spellpower = 0;
            this.mobsplayedThisTurn = p.mobsplayedThisTurn;
            this.startedWithMobsPlayedThisTurn = p.startedWithMobsPlayedThisTurn;
            this.optionsPlayedThisTurn = p.optionsPlayedThisTurn;
            this.cardsPlayedThisTurn = p.cardsPlayedThisTurn;
            this.ueberladung = p.ueberladung;

            this.ownDeckSize = p.ownDeckSize;
            this.enemyDeckSize = p.enemyDeckSize;
            this.ownHeroFatigue = p.ownHeroFatigue;
            this.enemyHeroFatigue = p.enemyHeroFatigue;

            //need the following for manacost-calculation
            this.ownHeroHpStarted = p.ownHeroHpStarted;
            this.ownWeaponAttackStarted = p.ownWeaponAttackStarted;
            this.ownCardsCountStarted = p.ownCardsCountStarted;
            this.enemyCardsCountStarted = p.enemyCardsCountStarted;
            this.ownMobsCountStarted = p.ownMobsCountStarted;

            this.startedWithWinzigebeschwoererin = p.startedWithWinzigebeschwoererin;
            this.playedmagierinderkirintor = p.playedmagierinderkirintor;

            this.startedWithWinzigebeschwoererin = p.startedWithWinzigebeschwoererin;
            this.startedWithManagespenst = p.startedWithManagespenst;
            this.startedWithsoeldnerDerVenture = p.startedWithsoeldnerDerVenture;
            this.startedWithbeschwoerungsportal = p.startedWithbeschwoerungsportal;
            this.startedWithnerubarweblord = p.startedWithnerubarweblord;

            this.startedWithDamagedMinions = p.startedWithDamagedMinions;

            this.nerubarweblord = p.nerubarweblord;
            this.winzigebeschwoererin = p.winzigebeschwoererin;
            this.managespenst = p.managespenst;
            this.soeldnerDerVenture = p.soeldnerDerVenture;
            this.loatheb = p.loatheb;

            this.spellpower = p.spellpower;
            this.enemyspellpower = p.enemyspellpower;

            this.needGraveyard = p.needGraveyard;
            if (p.needGraveyard) this.diedMinions = new List<GraveYardItem>(p.diedMinions);

            //####buffs#############################

            this.anzOwnRaidleader = p.anzOwnRaidleader;
            this.anzEnemyRaidleader = p.anzEnemyRaidleader;
            this.anzOwnMalGanis = p.anzOwnMalGanis;
            this.anzEnemyMalGanis = p.anzEnemyMalGanis;
            this.anzOwnStormwindChamps = p.anzOwnStormwindChamps;
            this.anzEnemyStormwindChamps = p.anzEnemyStormwindChamps;
            this.anzOwnTundrarhino = p.anzOwnTundrarhino;
            this.anzEnemyTundrarhino = p.anzEnemyTundrarhino;
            this.anzOwnTimberWolfs = p.anzOwnTimberWolfs;
            this.anzEnemyTimberWolfs = p.anzEnemyTimberWolfs;
            this.anzMurlocWarleader = p.anzMurlocWarleader;
            this.anzGrimscaleOracle = p.anzGrimscaleOracle;
            this.anzOwnAuchenaiSoulpriest = p.anzOwnAuchenaiSoulpriest;
            this.anzEnemyAuchenaiSoulpriest = p.anzEnemyAuchenaiSoulpriest;
            this.anzOwnsorcerersapprentice = p.anzOwnsorcerersapprentice;
            this.anzOwnsorcerersapprenticeStarted = p.anzOwnsorcerersapprenticeStarted;
            this.anzEnemysorcerersapprentice = p.anzEnemysorcerersapprentice;
            this.anzEnemysorcerersapprenticeStarted = p.anzEnemysorcerersapprenticeStarted;
            this.anzOwnSouthseacaptain = p.anzOwnSouthseacaptain;
            this.anzEnemySouthseacaptain = p.anzEnemySouthseacaptain;
            this.anzOwnMechwarper = p.anzOwnMechwarper;
            this.anzOwnMechwarperStarted = p.anzOwnMechwarperStarted;
            this.anzEnemyMechwarper = p.anzEnemyMechwarper;
            this.anzEnemyMechwarperStarted = p.anzEnemyMechwarperStarted;

            this.feugenDead = p.feugenDead;
            this.stalaggDead = p.stalaggDead;

            this.weHavePlayedMillhouseManastorm = p.weHavePlayedMillhouseManastorm;

            this.doublepriest = p.doublepriest;
            this.enemydoublepriest = p.enemydoublepriest;

            this.ownBaronRivendare = p.ownBaronRivendare;
            this.enemyBaronRivendare = p.enemyBaronRivendare;

            this.weHaveSteamwheedleSniper = p.weHaveSteamwheedleSniper;
            this.enemyHaveSteamwheedleSniper = p.enemyHaveSteamwheedleSniper;
            //#########################################


            this.tempanzOwnCards = this.owncards.Count;
            this.tempanzEnemyCards = this.enemyAnzCards;

        }

        public void copyValuesFrom(Playfield p)
        {

        }

        public bool isEqual(Playfield p, bool logg)
        {
            if (logg)
            {
                if (this.value != p.value) return false;
            }
            if (this.enemySecretCount != p.enemySecretCount)
            {

                if (logg) Helpfunctions.Instance.logg("enemy secrets changed ");
                return false;
            }

            if (this.enemySecretCount >= 1)
            {
                for (int i = 0; i < this.enemySecretList.Count; i++)
                {
                    if (!this.enemySecretList[i].isEqual(p.enemySecretList[i]))
                    {
                        if (logg) Helpfunctions.Instance.logg("enemy secrets changed! ");
                        return false;
                    }
                }
            }

            if (this.mana != p.mana || this.enemyMaxMana != p.enemyMaxMana || this.ownMaxMana != p.ownMaxMana)
            {
                if (logg) Helpfunctions.Instance.logg("mana changed " + this.mana + " " + p.mana + " " + this.enemyMaxMana + " " + p.enemyMaxMana + " " + this.ownMaxMana + " " + p.ownMaxMana);
                return false;
            }

            if (this.ownDeckSize != p.ownDeckSize || this.enemyDeckSize != p.enemyDeckSize || this.ownHeroFatigue != p.ownHeroFatigue || this.enemyHeroFatigue != p.enemyHeroFatigue)
            {
                if (logg) Helpfunctions.Instance.logg("deck/fatigue changed " + this.ownDeckSize + " " + p.ownDeckSize + " " + this.enemyDeckSize + " " + p.enemyDeckSize + " " + this.ownHeroFatigue + " " + p.ownHeroFatigue + " " + this.enemyHeroFatigue + " " + p.enemyHeroFatigue);
            }

            if (this.cardsPlayedThisTurn != p.cardsPlayedThisTurn || this.mobsplayedThisTurn != p.mobsplayedThisTurn || this.ueberladung != p.ueberladung || this.ownAbilityReady != p.ownAbilityReady)
            {
                if (logg) Helpfunctions.Instance.logg("stuff changed " + this.cardsPlayedThisTurn + " " + p.cardsPlayedThisTurn + " " + this.mobsplayedThisTurn + " " + p.mobsplayedThisTurn + " " + this.ueberladung + " " + p.ueberladung + " " + this.ownAbilityReady + " " + p.ownAbilityReady);
                return false;
            }

            if (this.ownHeroName != p.ownHeroName || this.enemyHeroName != p.enemyHeroName)
            {
                if (logg) Helpfunctions.Instance.logg("hero name changed ");
                return false;
            }

            if (this.ownHero.Hp != p.ownHero.Hp || this.ownHero.Angr != p.ownHero.Angr || this.ownHero.armor != p.ownHero.armor || this.ownHero.frozen != p.ownHero.frozen || this.ownHero.immuneWhileAttacking != p.ownHero.immuneWhileAttacking || this.ownHero.immune != p.ownHero.immune)
            {
                if (logg) Helpfunctions.Instance.logg("ownhero changed " + this.ownHero.Hp + " " + p.ownHero.Hp + " " + this.ownHero.Angr + " " + p.ownHero.Angr + " " + this.ownHero.armor + " " + p.ownHero.armor + " " + this.ownHero.frozen + " " + p.ownHero.frozen + " " + this.ownHero.immuneWhileAttacking + " " + p.ownHero.immuneWhileAttacking + " " + this.ownHero.immune + " " + p.ownHero.immune);
                return false;
            }
            if (this.ownHero.Ready != p.ownHero.Ready || this.ownWeaponAttack != p.ownWeaponAttack || this.ownWeaponDurability != p.ownWeaponDurability || this.ownHero.numAttacksThisTurn != p.ownHero.numAttacksThisTurn || this.ownHero.windfury != p.ownHero.windfury)
            {
                if (logg) Helpfunctions.Instance.logg("weapon changed " + this.ownHero.Ready + " " + p.ownHero.Ready + " " + this.ownWeaponAttack + " " + p.ownWeaponAttack + " " + this.ownWeaponDurability + " " + p.ownWeaponDurability + " " + this.ownHero.numAttacksThisTurn + " " + p.ownHero.numAttacksThisTurn + " " + this.ownHero.windfury + " " + p.ownHero.windfury);
                return false;
            }
            if (this.enemyHero.Hp != p.enemyHero.Hp || this.enemyWeaponAttack != p.enemyWeaponAttack || this.enemyHero.armor != p.enemyHero.armor || this.enemyWeaponDurability != p.enemyWeaponDurability || this.enemyHero.frozen != p.enemyHero.frozen || this.enemyHero.immune != p.enemyHero.immune)
            {
                if (logg) Helpfunctions.Instance.logg("enemyhero changed " + this.enemyHero.Hp + " " + p.enemyHero.Hp + " " + this.enemyWeaponAttack + " " + p.enemyWeaponAttack + " " + this.enemyHero.armor + " " + p.enemyHero.armor + " " + this.enemyWeaponDurability + " " + p.enemyWeaponDurability + " " + this.enemyHero.frozen + " " + p.enemyHero.frozen + " " + this.enemyHero.immune + " " + p.enemyHero.immune);
                return false;
            }

            /*if (this.auchenaiseelenpriesterin != p.auchenaiseelenpriesterin || this.winzigebeschwoererin != p.winzigebeschwoererin || this.zauberlehrling != p.zauberlehrling || this.managespenst != p.managespenst || this.soeldnerDerVenture != p.soeldnerDerVenture || this.beschwoerungsportal != p.beschwoerungsportal || this.doublepriest != p.doublepriest)
            {
                Helpfunctions.Instance.logg("special minions changed " + this.auchenaiseelenpriesterin + " " + p.auchenaiseelenpriesterin + " " + this.winzigebeschwoererin + " " + p.winzigebeschwoererin + " " + this.zauberlehrling + " " + p.zauberlehrling + " " + this.managespenst + " " + p.managespenst + " " + this.soeldnerDerVenture + " " + p.soeldnerDerVenture + " " + this.beschwoerungsportal + " " + p.beschwoerungsportal + " " + this.doublepriest + " " + p.doublepriest);
                return false;
            }*/

            if (this.ownHeroAblility.card.name != p.ownHeroAblility.card.name)
            {
                if (logg) Helpfunctions.Instance.logg("hero ability changed ");
                return false;
            }

            if (this.spellpower != p.spellpower)
            {
                if (logg) Helpfunctions.Instance.logg("spellpower changed");
                return false;
            }

            if (this.ownMinions.Count != p.ownMinions.Count || this.enemyMinions.Count != p.enemyMinions.Count || this.owncards.Count != p.owncards.Count)
            {
                if (logg) Helpfunctions.Instance.logg("minions count or hand changed");
                return false;
            }

            bool minionbool = true;
            for (int i = 0; i < this.ownMinions.Count; i++)
            {
                Minion dis = this.ownMinions[i]; Minion pis = p.ownMinions[i];
                //if (dis.entitiyID == 0) dis.entitiyID = pis.entitiyID;
                //if (pis.entitiyID == 0) pis.entitiyID = dis.entitiyID;
                if (dis.name != pis.name) minionbool = false;
                if (dis.Angr != pis.Angr || dis.Hp != pis.Hp || dis.maxHp != pis.maxHp || dis.numAttacksThisTurn != pis.numAttacksThisTurn) minionbool = false;
                if (dis.Ready != pis.Ready) minionbool = false; // includes frozen, exhaunted
                if (dis.playedThisTurn != pis.playedThisTurn) minionbool = false;
                if (dis.silenced != pis.silenced || dis.stealth != pis.stealth || dis.taunt != pis.taunt || dis.windfury != pis.windfury || dis.zonepos != pis.zonepos) minionbool = false;
                if (dis.divineshild != pis.divineshild || dis.cantLowerHPbelowONE != pis.cantLowerHPbelowONE || dis.immune != pis.immune) minionbool = false;
                if (dis.ownBlessingOfWisdom != pis.ownBlessingOfWisdom || dis.enemyBlessingOfWisdom != pis.enemyBlessingOfWisdom) minionbool = false;
                if (dis.destroyOnEnemyTurnStart != pis.destroyOnEnemyTurnStart || dis.destroyOnEnemyTurnEnd != pis.destroyOnEnemyTurnEnd || dis.destroyOnOwnTurnEnd != pis.destroyOnOwnTurnEnd || dis.destroyOnOwnTurnStart != pis.destroyOnOwnTurnStart) minionbool = false;
                if (dis.ancestralspirit != pis.ancestralspirit || dis.souloftheforest != pis.souloftheforest) minionbool = false;

            }
            if (minionbool == false)
            {
                if (logg) Helpfunctions.Instance.logg("ownminions changed");
                return false;
            }

            for (int i = 0; i < this.enemyMinions.Count; i++)
            {
                Minion dis = this.enemyMinions[i]; Minion pis = p.enemyMinions[i];
                //if (dis.entitiyID == 0) dis.entitiyID = pis.entitiyID;
                //if (pis.entitiyID == 0) pis.entitiyID = dis.entitiyID;
                if (dis.name != pis.name) minionbool = false;
                if (dis.Angr != pis.Angr || dis.Hp != pis.Hp || dis.maxHp != pis.maxHp || dis.numAttacksThisTurn != pis.numAttacksThisTurn) minionbool = false;
                if (dis.Ready != pis.Ready) minionbool = false; // includes frozen, exhaunted
                if (dis.playedThisTurn != pis.playedThisTurn) minionbool = false;
                if (dis.silenced != pis.silenced || dis.stealth != pis.stealth || dis.taunt != pis.taunt || dis.windfury != pis.windfury || dis.zonepos != pis.zonepos) minionbool = false;
                if (dis.divineshild != pis.divineshild || dis.cantLowerHPbelowONE != pis.cantLowerHPbelowONE || dis.immune != pis.immune) minionbool = false;
                if (dis.ownBlessingOfWisdom != pis.ownBlessingOfWisdom || dis.enemyBlessingOfWisdom != pis.enemyBlessingOfWisdom) minionbool = false;
                if (dis.destroyOnEnemyTurnStart != pis.destroyOnEnemyTurnStart || dis.destroyOnEnemyTurnEnd != pis.destroyOnEnemyTurnEnd || dis.destroyOnOwnTurnEnd != pis.destroyOnOwnTurnEnd || dis.destroyOnOwnTurnStart != pis.destroyOnOwnTurnStart) minionbool = false;
                if (dis.ancestralspirit != pis.ancestralspirit || dis.souloftheforest != pis.souloftheforest) minionbool = false;
            }
            if (minionbool == false)
            {
                if (logg) Helpfunctions.Instance.logg("enemyminions changed");
                return false;
            }

            for (int i = 0; i < this.owncards.Count; i++)
            {
                Handmanager.Handcard dishc = this.owncards[i]; Handmanager.Handcard pishc = p.owncards[i];
                if (dishc.position != pishc.position || dishc.entity != pishc.entity || dishc.getManaCost(this) != pishc.getManaCost(p))
                {
                    if (logg) Helpfunctions.Instance.logg("handcard changed: " + dishc.card.name);
                    return false;
                }
            }

            for (int i = 0; i < this.ownMinions.Count; i++)
            {
                Minion dis = this.ownMinions[i]; Minion pis = p.ownMinions[i];
                if (dis.entitiyID != pis.entitiyID) Ai.Instance.updateEntitiy(pis.entitiyID, dis.entitiyID);

            }

            for (int i = 0; i < this.enemyMinions.Count; i++)
            {
                Minion dis = this.enemyMinions[i]; Minion pis = p.enemyMinions[i];
                if (dis.entitiyID != pis.entitiyID) Ai.Instance.updateEntitiy(pis.entitiyID, dis.entitiyID);

            }
            if (this.ownSecretsIDList.Count != p.ownSecretsIDList.Count)
            {
                if (logg) Helpfunctions.Instance.logg("secretsCount changed");
                return false;
            }
            for (int i = 0; i < this.ownSecretsIDList.Count; i++)
            {
                if (this.ownSecretsIDList[i] != p.ownSecretsIDList[i])
                {
                    if (logg) Helpfunctions.Instance.logg("secrets changed");
                    return false;
                }
            }
            return true;
        }

        public bool isEqualf(Playfield p)
        {
            if (this.value != p.value) return false;

            if (this.ownMinions.Count != p.ownMinions.Count || this.enemyMinions.Count != p.enemyMinions.Count || this.owncards.Count != p.owncards.Count) return false;

            if (this.cardsPlayedThisTurn != p.cardsPlayedThisTurn || this.mobsplayedThisTurn != p.mobsplayedThisTurn || this.ueberladung != p.ueberladung || this.ownAbilityReady != p.ownAbilityReady) return false;

            if (this.mana != p.mana || this.enemyMaxMana != p.enemyMaxMana || this.ownMaxMana != p.ownMaxMana) return false;

            if (this.ownHeroName != p.ownHeroName || this.enemyHeroName != p.enemyHeroName || this.enemySecretCount != p.enemySecretCount) return false;

            if (this.ownHero.Hp != p.ownHero.Hp || this.ownHero.Angr != p.ownHero.Angr || this.ownHero.armor != p.ownHero.armor || this.ownHero.frozen != p.ownHero.frozen || this.ownHero.immuneWhileAttacking != p.ownHero.immuneWhileAttacking || this.ownHero.immune != p.ownHero.immune) return false;

            if (this.ownHero.Ready != p.ownHero.Ready || this.ownWeaponAttack != p.ownWeaponAttack || this.ownWeaponDurability != p.ownWeaponDurability || this.ownHero.numAttacksThisTurn != p.ownHero.numAttacksThisTurn || this.ownHero.windfury != p.ownHero.windfury) return false;

            if (this.enemyHero.Hp != p.enemyHero.Hp || this.enemyWeaponAttack != p.enemyWeaponAttack || this.enemyHero.armor != p.enemyHero.armor || this.enemyWeaponDurability != p.enemyWeaponDurability || this.enemyHero.frozen != p.enemyHero.frozen || this.enemyHero.immune != p.enemyHero.immune) return false;

            if (this.ownHeroAblility.card.name != p.ownHeroAblility.card.name || this.spellpower != p.spellpower) return false;

            bool minionbool = true;
            for (int i = 0; i < this.ownMinions.Count; i++)
            {
                Minion dis = this.ownMinions[i]; Minion pis = p.ownMinions[i];
                //if (dis.entitiyID == 0) dis.entitiyID = pis.entitiyID;
                //if (pis.entitiyID == 0) pis.entitiyID = dis.entitiyID;
                if (dis.entitiyID != pis.entitiyID) minionbool = false;
                if (dis.Angr != pis.Angr || dis.Hp != pis.Hp || dis.maxHp != pis.maxHp || dis.numAttacksThisTurn != pis.numAttacksThisTurn) minionbool = false;
                if (dis.Ready != pis.Ready) minionbool = false; // includes frozen, exhaunted
                if (dis.playedThisTurn != pis.playedThisTurn) minionbool = false;
                if (dis.silenced != pis.silenced || dis.stealth != pis.stealth || dis.taunt != pis.taunt || dis.windfury != pis.windfury || dis.zonepos != pis.zonepos) minionbool = false;
                if (dis.divineshild != pis.divineshild || dis.cantLowerHPbelowONE != pis.cantLowerHPbelowONE || dis.immune != pis.immune) minionbool = false;
                if (dis.ownBlessingOfWisdom != pis.ownBlessingOfWisdom || dis.enemyBlessingOfWisdom != pis.enemyBlessingOfWisdom) minionbool = false;
                if (dis.destroyOnEnemyTurnStart != pis.destroyOnEnemyTurnStart || dis.destroyOnEnemyTurnEnd != pis.destroyOnEnemyTurnEnd || dis.destroyOnOwnTurnEnd != pis.destroyOnOwnTurnEnd || dis.destroyOnOwnTurnStart != pis.destroyOnOwnTurnStart) minionbool = false;
                if (dis.ancestralspirit != pis.ancestralspirit || dis.souloftheforest != pis.souloftheforest) minionbool = false;
                if (minionbool == false) break;
            }
            if (minionbool == false)
            {

                return false;
            }

            for (int i = 0; i < this.enemyMinions.Count; i++)
            {
                Minion dis = this.enemyMinions[i]; Minion pis = p.enemyMinions[i];
                //if (dis.entitiyID == 0) dis.entitiyID = pis.entitiyID;
                //if (pis.entitiyID == 0) pis.entitiyID = dis.entitiyID;
                if (dis.entitiyID != pis.entitiyID) minionbool = false;
                if (dis.Angr != pis.Angr || dis.Hp != pis.Hp || dis.maxHp != pis.maxHp || dis.numAttacksThisTurn != pis.numAttacksThisTurn) minionbool = false;
                if (dis.Ready != pis.Ready) minionbool = false; // includes frozen, exhaunted
                if (dis.playedThisTurn != pis.playedThisTurn) minionbool = false;
                if (dis.silenced != pis.silenced || dis.stealth != pis.stealth || dis.taunt != pis.taunt || dis.windfury != pis.windfury || dis.zonepos != pis.zonepos) minionbool = false;
                if (dis.divineshild != pis.divineshild || dis.cantLowerHPbelowONE != pis.cantLowerHPbelowONE || dis.immune != pis.immune) minionbool = false;
                if (dis.ownBlessingOfWisdom != pis.ownBlessingOfWisdom || dis.enemyBlessingOfWisdom != pis.enemyBlessingOfWisdom) minionbool = false;
                if (dis.destroyOnEnemyTurnStart != pis.destroyOnEnemyTurnStart || dis.destroyOnEnemyTurnEnd != pis.destroyOnEnemyTurnEnd || dis.destroyOnOwnTurnEnd != pis.destroyOnOwnTurnEnd || dis.destroyOnOwnTurnStart != pis.destroyOnOwnTurnStart) minionbool = false;
                if (dis.ancestralspirit != pis.ancestralspirit || dis.souloftheforest != pis.souloftheforest) minionbool = false;
                if (minionbool == false) break;
            }
            if (minionbool == false)
            {
                return false;
            }

            for (int i = 0; i < this.owncards.Count; i++)
            {
                Handmanager.Handcard dishc = this.owncards[i]; Handmanager.Handcard pishc = p.owncards[i];
                if (dishc.position != pishc.position || dishc.entity != pishc.entity || dishc.manacost != pishc.manacost)
                {
                    return false;
                }
            }

            if (this.enemySecretCount >= 1)
            {
                for (int i = 0; i < this.enemySecretList.Count; i++)
                {
                    if (!this.enemySecretList[i].isEqual(p.enemySecretList[i]))
                    {
                        return false;
                    }
                }
            }

            if (this.ownSecretsIDList.Count != p.ownSecretsIDList.Count)
            {
                return false;
            }
            for (int i = 0; i < this.ownSecretsIDList.Count; i++)
            {
                if (this.ownSecretsIDList[i] != p.ownSecretsIDList[i])
                {
                    return false;
                }
            }

            return true;
        }

        public override int GetHashCode()
        {
            int retval = 0;
            retval += 10000 * this.ownMinions.Count + 100 * this.enemyMinions.Count + 1000 * this.mana + 100000 * (this.ownHero.Hp + this.enemyHero.Hp) + this.owncards.Count + this.enemycarddraw + this.cardsPlayedThisTurn + this.mobsplayedThisTurn + this.ownHero.Angr + this.ownHero.armor + this.ownWeaponAttack + this.enemyWeaponDurability;
            return retval;
        }


        //stuff for playing around enemy aoes
        public void enemyPlaysAoe(int pprob, int pprob2)
        {
            if (!this.loatheb)
            {
                Playfield p = new Playfield(this);
                float oldval = Ai.Instance.botBase.getPlayfieldValue(p);
                p.value = int.MinValue;
                p.EnemyCardPlaying(p.enemyHeroName, p.mana, p.enemyAnzCards, pprob, pprob2);
                float newval = Ai.Instance.botBase.getPlayfieldValue(p);
                p.value = int.MinValue;
                if (oldval > newval) // new board is better for enemy (value is smaller)
                {
                    this.copyValuesFrom(p);
                }
            }
        }

        public int EnemyCardPlaying(HeroEnum enemyHeroNamee, int currmana, int cardcount, int playAroundProb, int pap2)
        {
            int mana = currmana;
            if (cardcount == 0) return currmana;

            bool useAOE = false;
            int mobscount = 0;
            foreach (Minion min in this.ownMinions)
            {
                if (min.maxHp >= 2 && min.Angr >= 2) mobscount++;
            }

            if (mobscount >= 3) useAOE = true;

            if (enemyHeroNamee == HeroEnum.warrior)
            {
                bool usewhirlwind = true;
                foreach (Minion m in this.enemyMinions)
                {
                    if (m.Hp == 1) usewhirlwind = false;
                }
                if (this.ownMinions.Count <= 3) usewhirlwind = false;

                if (usewhirlwind)
                {
                    mana = EnemyPlaysACard(CardDB.cardName.whirlwind, mana, playAroundProb, pap2);
                }
            }

            if (!useAOE) return mana;

            if (enemyHeroNamee == HeroEnum.mage)
            {
                mana = EnemyPlaysACard(CardDB.cardName.flamestrike, mana, playAroundProb, pap2);
                mana = EnemyPlaysACard(CardDB.cardName.blizzard, mana, playAroundProb, pap2);
            }

            if (enemyHeroNamee == HeroEnum.hunter)
            {
                mana = EnemyPlaysACard(CardDB.cardName.unleashthehounds, mana, playAroundProb, pap2);
            }

            if (enemyHeroNamee == HeroEnum.priest)
            {
                mana = EnemyPlaysACard(CardDB.cardName.holynova, mana, playAroundProb, pap2);
            }

            if (enemyHeroNamee == HeroEnum.shaman)
            {
                mana = EnemyPlaysACard(CardDB.cardName.lightningstorm, mana, playAroundProb, pap2);
            }

            if (enemyHeroNamee == HeroEnum.pala)
            {
                mana = EnemyPlaysACard(CardDB.cardName.consecration, mana, playAroundProb, pap2);
            }

            if (enemyHeroNamee == HeroEnum.druid)
            {
                mana = EnemyPlaysACard(CardDB.cardName.swipe, mana, playAroundProb, pap2);
            }



            return mana;
        }

        public int EnemyPlaysACard(CardDB.cardName cardname, int currmana, int playAroundProb, int pap2)
        {

            //todo manacosts
            if (cardname == CardDB.cardName.flamestrike && currmana >= 7)
            {
                bool dontkill = false;
                int prob = Probabilitymaker.Instance.getProbOfEnemyHavingCardInHand(CardDB.cardIDEnum.CS2_032, this.enemyAnzCards, this.enemyDeckSize);
                if (playAroundProb > prob) return currmana;
                if (pap2 > prob) dontkill = true;

                List<Minion> temp = this.ownMinions;
                int damage = getEnemySpellDamageDamage(4);
                foreach (Minion enemy in temp)
                {
                    enemy.cantLowerHPbelowONE = dontkill;
                    this.minionGetDamageOrHeal(enemy, damage);
                    enemy.cantLowerHPbelowONE = false;
                }

                currmana -= 7;
                return currmana;
            }

            if (cardname == CardDB.cardName.blizzard && currmana >= 6)
            {
                bool dontkill = false;
                int prob = Probabilitymaker.Instance.getProbOfEnemyHavingCardInHand(CardDB.cardIDEnum.CS2_028, this.enemyAnzCards, this.enemyDeckSize);
                if (playAroundProb > prob) return currmana;
                if (pap2 > prob) dontkill = true;

                List<Minion> temp = this.ownMinions;
                int damage = getEnemySpellDamageDamage(2);
                foreach (Minion enemy in temp)
                {
                    enemy.frozen = true;
                    enemy.cantLowerHPbelowONE = dontkill;
                    this.minionGetDamageOrHeal(enemy, damage);
                    enemy.cantLowerHPbelowONE = false;
                }

                currmana -= 6;
                return currmana;
            }


            if (cardname == CardDB.cardName.unleashthehounds && currmana >= 5)
            {
                bool dontkill = false;
                int prob = Probabilitymaker.Instance.getProbOfEnemyHavingCardInHand(CardDB.cardIDEnum.EX1_538, this.enemyAnzCards, this.enemyDeckSize);
                if (playAroundProb > prob) return currmana;
                if (pap2 > prob) dontkill = true;

                int anz = this.ownMinions.Count;
                int posi = this.enemyMinions.Count - 1;
                CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_538t);//hound
                for (int i = 0; i < anz; i++)
                {
                    callKid(kid, posi, false);
                }
                currmana -= 5;
                return currmana;
            }





            if (cardname == CardDB.cardName.holynova && currmana >= 5)
            {
                bool dontkill = false;
                int prob = Probabilitymaker.Instance.getProbOfEnemyHavingCardInHand(CardDB.cardIDEnum.CS1_112, this.enemyAnzCards, this.enemyDeckSize);
                if (playAroundProb > prob) return currmana;
                if (pap2 > prob) dontkill = true;

                List<Minion> temp = this.enemyMinions;
                int heal = getEnemySpellHeal(2);
                int damage = getEnemySpellDamageDamage(2);
                foreach (Minion enemy in temp)
                {
                    this.minionGetDamageOrHeal(enemy, -heal);
                }
                this.minionGetDamageOrHeal(this.enemyHero, -heal);
                temp = this.ownMinions;
                foreach (Minion enemy in temp)
                {
                    enemy.cantLowerHPbelowONE = dontkill;
                    this.minionGetDamageOrHeal(enemy, damage);
                    enemy.cantLowerHPbelowONE = false;
                }
                this.minionGetDamageOrHeal(this.ownHero, damage);
                currmana -= 5;
                return currmana;
            }




            if (cardname == CardDB.cardName.lightningstorm && currmana >= 4)//3
            {
                bool dontkill = false;
                int prob = Probabilitymaker.Instance.getProbOfEnemyHavingCardInHand(CardDB.cardIDEnum.EX1_259, this.enemyAnzCards, this.enemyDeckSize);
                if (playAroundProb > prob) return currmana;
                if (pap2 > prob) dontkill = true;

                List<Minion> temp = this.ownMinions;
                int damage = getEnemySpellDamageDamage(3);
                foreach (Minion enemy in temp)
                {
                    enemy.cantLowerHPbelowONE = dontkill;
                    this.minionGetDamageOrHeal(enemy, damage);
                    enemy.cantLowerHPbelowONE = false;
                }
                currmana -= 3;
                return currmana;
            }



            if (cardname == CardDB.cardName.whirlwind && currmana >= 3)//1
            {
                bool dontkill = false;
                int prob = Probabilitymaker.Instance.getProbOfEnemyHavingCardInHand(CardDB.cardIDEnum.EX1_400, this.enemyAnzCards, this.enemyDeckSize);
                if (playAroundProb > prob) return currmana;
                if (pap2 > prob) dontkill = true;

                List<Minion> temp = this.enemyMinions;
                int damage = getEnemySpellDamageDamage(1);
                foreach (Minion enemy in temp)
                {
                    this.minionGetDamageOrHeal(enemy, damage);
                }
                temp = this.ownMinions;
                foreach (Minion enemy in temp)
                {
                    enemy.cantLowerHPbelowONE = dontkill;
                    this.minionGetDamageOrHeal(enemy, damage);
                    enemy.cantLowerHPbelowONE = false;
                }
                currmana -= 1;
                return currmana;
            }



            if (cardname == CardDB.cardName.consecration && currmana >= 4)
            {
                bool dontkill = false;
                int prob = Probabilitymaker.Instance.getProbOfEnemyHavingCardInHand(CardDB.cardIDEnum.CS2_093, this.enemyAnzCards, this.enemyDeckSize);
                if (playAroundProb > prob) return currmana;
                if (pap2 > prob) dontkill = true;

                List<Minion> temp = this.ownMinions;
                int damage = getEnemySpellDamageDamage(2);
                foreach (Minion enemy in temp)
                {
                    enemy.cantLowerHPbelowONE = dontkill;
                    this.minionGetDamageOrHeal(enemy, damage);
                    enemy.cantLowerHPbelowONE = false;
                }

                this.minionGetDamageOrHeal(this.ownHero, damage);
                currmana -= 4;
                return currmana;
            }



            if (cardname == CardDB.cardName.swipe && currmana >= 4)
            {
                bool dontkill = false;
                int prob = Probabilitymaker.Instance.getProbOfEnemyHavingCardInHand(CardDB.cardIDEnum.CS2_012, this.enemyAnzCards, this.enemyDeckSize);
                if (playAroundProb > prob) return currmana;
                if (pap2 > prob) dontkill = true;

                int damage = getEnemySpellDamageDamage(4);
                // all others get 1 spelldamage
                int damage1 = getEnemySpellDamageDamage(1);

                List<Minion> temp = this.ownMinions;
                Minion target = null;
                foreach (Minion mnn in temp)
                {
                    if (mnn.Hp <= damage || mnn.handcard.card.isSpecialMinion || target == null)
                    {
                        target = mnn;
                    }
                }
                foreach (Minion mnn in temp.ToArray())
                {
                    if (mnn.entitiyID == target.entitiyID)
                    {
                        mnn.cantLowerHPbelowONE = dontkill;
                        this.minionGetDamageOrHeal(mnn, damage1);
                        mnn.cantLowerHPbelowONE = false;
                    }
                    else
                    {
                        mnn.cantLowerHPbelowONE = dontkill;
                        this.minionGetDamageOrHeal(mnn, damage);
                        mnn.cantLowerHPbelowONE = false;
                    }
                }
                currmana -= 4;
                return currmana;
            }





            return currmana;
        }

        public int getNextEntity()
        {
            //i dont trust return this.nextEntity++; !!!
            int retval = this.nextEntity;
            this.nextEntity++;
            return retval;
        }


        // get all minions which are attackable
        public List<Minion> getAttackTargets(bool own)
        {
            List<Minion> trgts = new List<Minion>();
            List<Minion> trgts2 = new List<Minion>();
            bool hasTaunts = false;
            if (own)
            {
                if (!this.enemyHero.immune) trgts2.Add(this.enemyHero);
                foreach (Minion m in this.enemyMinions)
                {
                    if (m.stealth) continue; // cant target stealth

                    if (m.taunt)
                    {
                        hasTaunts = true;
                        trgts.Add(m);
                    }
                    else
                    {
                        trgts2.Add(m);
                    }
                }
            }
            else
            {

                foreach (Minion m in this.ownMinions)
                {
                    if (m.stealth) continue; // cant target stealth

                    if (m.taunt)
                    {
                        hasTaunts = true;
                        trgts.Add(m);
                    }
                    else
                    {
                        trgts2.Add(m);
                    }
                }

                trgts2.Add(this.ownHero);
                //if (trgts2.Count == 0 && !this.ownHero.immune) trgts2.Add(this.ownHero);
            }

            if (hasTaunts) return trgts;

            return trgts2;


        }

        public int getBestPlace(CardDB.Card card, bool lethal)
        {
            //we return the zonepos!
            if (card.type != CardDB.cardtype.MOB) return 1;
            if (this.ownMinions.Count == 0) return 1;
            if (this.ownMinions.Count == 1) return 2;

            int[] places = new int[this.ownMinions.Count];
            int i = 0;
            int tempval = 0;
            if (lethal && card.name == CardDB.cardName.defenderofargus)
            {
                i = 0;
                foreach (Minion m in this.ownMinions)
                {

                    places[i] = 0;
                    tempval = 0;
                    if (m.Ready)
                    {
                        tempval -= m.Angr - 1;
                        if (m.windfury) tempval -= m.Angr - 1;
                    }
                    places[i] = tempval;

                    i++;
                }


                i = 0;
                int bestpl = 7;
                int bestval = 10000;
                foreach (Minion m in this.ownMinions)
                {
                    int prev = 0;
                    int next = 0;
                    if (i >= 1) prev = places[i - 1];
                    next = places[i];
                    if (bestval > prev + next)
                    {
                        bestval = prev + next;
                        bestpl = i;
                    }
                    i++;
                }
                return bestpl + 1;
            }
            if (card.name == CardDB.cardName.sunfuryprotector || card.name == CardDB.cardName.defenderofargus) // bestplace, if right and left minions have no taunt + lots of hp, dont make priority-minions to taunt
            {
                i = 0;
                foreach (Minion m in this.ownMinions)
                {

                    places[i] = 0;
                    tempval = 0;
                    if (!m.taunt)
                    {
                        tempval -= m.Hp;
                    }
                    else
                    {
                        tempval -= m.Hp + 2;
                    }

                    if (m.handcard.card.name == CardDB.cardName.flametonguetotem) tempval += 50;
                    if (m.handcard.card.name == CardDB.cardName.raidleader) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.grimscaleoracle) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.direwolfalpha) tempval += 50;
                    if (m.handcard.card.name == CardDB.cardName.murlocwarleader) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.southseacaptain) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.stormwindchampion) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.timberwolf) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.leokk) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.northshirecleric) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.sorcerersapprentice) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.pintsizedsummoner) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.summoningportal) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.scavenginghyena) tempval += 10;

                    places[i] = tempval;

                    i++;
                }


                i = 0;
                int bestpl = 7;
                int bestval = 10000;
                foreach (Minion m in this.ownMinions)
                {
                    int prev = 0;
                    int next = 0;
                    if (i >= 1) prev = places[i - 1];
                    next = places[i];
                    if (bestval > prev + next)
                    {
                        bestval = prev + next;
                        bestpl = i;
                    }
                    i++;
                }
                return bestpl + 1;
            }

            int cardIsBuffer = 0;
            bool placebuff = false;
            if (card.name == CardDB.cardName.flametonguetotem || card.name == CardDB.cardName.direwolfalpha)
            {
                placebuff = true;
                if (card.name == CardDB.cardName.flametonguetotem) cardIsBuffer = 2;
                if (card.name == CardDB.cardName.direwolfalpha) cardIsBuffer = 1;
            }
            bool commander = false;
            foreach (Minion m in this.ownMinions)
            {
                if (m.handcard.card.name == CardDB.cardName.warsongcommander) commander = true;
                if (m.handcard.card.name == CardDB.cardName.flametonguetotem || m.handcard.card.name == CardDB.cardName.direwolfalpha) placebuff = true;
            }
            //attackmaxing :D
            if (placebuff)
            {


                int cval = 0;
                if (card.Charge || (card.Attack <= 3 && commander))
                {
                    cval = card.Attack;
                    if (card.windfury) cval = card.Attack;
                }
                if (card.name == CardDB.cardName.nerubianegg)
                {
                    cval += 1;
                }
                cval++;
                i = 0;
                int[] buffplaces = new int[this.ownMinions.Count];
                int[] whirlwindplaces = new int[this.ownMinions.Count];
                int gesval = 0;
                foreach (Minion m in this.ownMinions)
                {
                    buffplaces[i] = 0;
                    whirlwindplaces[i] = 1;
                    places[i] = 0;
                    tempval = -1;
                    if (!m.Ready && m.Angr == 0 && !m.playedThisTurn) tempval = 0;
                    if (m.Ready)
                    {
                        tempval = m.Angr;
                        if (m.windfury && m.numAttacksThisTurn == 0)
                        {
                            tempval += m.Angr;
                            whirlwindplaces[i] = 2;
                        }


                    }
                    if (m.handcard.card.name == CardDB.cardName.flametonguetotem)
                    {
                        buffplaces[i] = 2;
                    }
                    if (m.handcard.card.name == CardDB.cardName.direwolfalpha)
                    {
                        buffplaces[i] = 1;
                    }
                    tempval++;
                    places[i] = tempval;
                    gesval += tempval;
                    i++;
                }
                //gesval = whole possible damage
                int bplace = 0;
                int bvale = 0;
                tempval = 0;
                i = 0;
                for (int j = 0; j <= this.ownMinions.Count; j++)
                {
                    tempval = gesval;
                    int current = cval;
                    int prev = 0;
                    int next = 0;
                    if (i >= 1)
                    {
                        tempval -= places[i - 1];
                        prev = places[i - 1];
                        if (prev >= 0) prev += whirlwindplaces[i - 1] * cardIsBuffer;
                        if (current > 0) current += buffplaces[i - 1];

                        if (i < this.ownMinions.Count)
                        {
                            prev -= whirlwindplaces[i - 1] * buffplaces[i];
                        }
                    }
                    if (i < this.ownMinions.Count)
                    {
                        tempval -= places[i];
                        next = places[i];
                        if (next >= 0) next += whirlwindplaces[i] * cardIsBuffer;
                        if (current > 0) current += buffplaces[i];
                        if (i >= 1)
                        {
                            next -= whirlwindplaces[i] * buffplaces[i - 1];
                        }
                    }
                    tempval += current + prev + next;
                    if (tempval > bvale)
                    {
                        bplace = i;
                        bvale = tempval;
                    }
                    i++;
                }
                return bplace + 1;

            }

            // normal placement
            int cardvalue = card.Attack * 2 + card.Health;
            if (card.tank)
            {
                cardvalue += 5;
                cardvalue += card.Health;
            }

            if (card.name == CardDB.cardName.flametonguetotem) cardvalue += 90;
            if (card.name == CardDB.cardName.raidleader) cardvalue += 10;
            if (card.name == CardDB.cardName.grimscaleoracle) cardvalue += 10;
            if (card.name == CardDB.cardName.direwolfalpha) cardvalue += 90;
            if (card.name == CardDB.cardName.murlocwarleader) cardvalue += 10;
            if (card.name == CardDB.cardName.southseacaptain) cardvalue += 10;
            if (card.name == CardDB.cardName.stormwindchampion) cardvalue += 10;
            if (card.name == CardDB.cardName.timberwolf) cardvalue += 10;
            if (card.name == CardDB.cardName.leokk) cardvalue += 10;
            if (card.name == CardDB.cardName.northshirecleric) cardvalue += 10;
            if (card.name == CardDB.cardName.sorcerersapprentice) cardvalue += 10;
            if (card.name == CardDB.cardName.pintsizedsummoner) cardvalue += 10;
            if (card.name == CardDB.cardName.summoningportal) cardvalue += 10;
            if (card.name == CardDB.cardName.scavenginghyena) cardvalue += 10;
            if (card.name == CardDB.cardName.faeriedragon) cardvalue += 40;
            cardvalue += 1;

            i = 0;
            foreach (Minion m in this.ownMinions)
            {
                places[i] = 0;
                tempval = m.Angr * 2 + m.maxHp;
                if (m.taunt)
                {
                    tempval += 6;
                    tempval += m.maxHp;
                }
                if (!m.silenced)
                {
                    if (m.handcard.card.name == CardDB.cardName.flametonguetotem) tempval += 90;
                    if (m.handcard.card.name == CardDB.cardName.raidleader) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.grimscaleoracle) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.direwolfalpha) tempval += 90;
                    if (m.handcard.card.name == CardDB.cardName.murlocwarleader) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.southseacaptain) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.stormwindchampion) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.timberwolf) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.leokk) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.northshirecleric) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.sorcerersapprentice) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.pintsizedsummoner) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.summoningportal) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.scavenginghyena) tempval += 10;
                    if (m.handcard.card.name == CardDB.cardName.faeriedragon) tempval += 40;
                    if (m.stealth) tempval += 40;
                }
                places[i] = tempval;

                i++;
            }

            //bigminion if >=10
            int bestplace = 0;
            int bestvale = 0;
            tempval = 0;
            i = 0;
            for (int j = 0; j <= this.ownMinions.Count; j++)
            {
                int prev = cardvalue;
                int next = cardvalue;
                if (i >= 1) prev = places[i - 1];
                if (i < this.ownMinions.Count) next = places[i];


                if (cardvalue >= prev && cardvalue >= next)
                {
                    tempval = 2 * cardvalue - prev - next;
                    if (tempval > bestvale)
                    {
                        bestplace = i;
                        bestvale = tempval;
                    }
                }
                if (cardvalue <= prev && cardvalue <= next)
                {
                    tempval = -2 * cardvalue + prev + next;
                    if (tempval > bestvale)
                    {
                        bestplace = i;
                        bestvale = tempval;
                    }
                }

                i++;
            }

            return bestplace + 1;
        }

        public void guessHeroDamage()
        {
            int ghd = 0;
            foreach (Minion m in this.enemyMinions)
            {
                if (m.frozen) continue;
                if (m.name == CardDB.cardName.ancientwatcher && !m.silenced)
                {
                    continue;
                }
                ghd += m.Angr;
                if (m.windfury) ghd += m.Angr;
            }

            if (!this.enemyHero.frozen)
            {
                if (this.enemyWeaponAttack >= 1)
                {
                    ghd += enemyWeaponAttack;
                    if (this.enemyHero.windfury || this.enemyWeaponName == CardDB.cardName.doomhammer) ghd += enemyWeaponAttack;
                }
                else
                {
                    if (this.enemyHeroName == HeroEnum.druid) ghd++;
                    if (this.enemyHeroName == HeroEnum.thief) ghd++;
                }
            }

            if (this.enemyHeroName == HeroEnum.mage) ghd++;
            if (this.enemyHeroName == HeroEnum.hunter) ghd += 2;


            foreach (Minion m in this.ownMinions)
            {
                if (m.taunt) ghd -= m.Hp;
                if (m.taunt && m.divineshild) ghd -= 1;
            }

            int guessingHeroDamage = Math.Max(0, ghd);
            if (this.ownHero.immune) guessingHeroDamage = 0;
            this.guessingHeroHP = this.ownHero.Hp + this.ownHero.armor - guessingHeroDamage;
        }

        public void simulateTraps()
        {
            //todo rework this
            // DONT KILL ENEMY HERO (cause its only guessing)
            foreach (CardDB.cardIDEnum secretID in this.ownSecretsIDList)
            {
                //hunter secrets############
                if (secretID == CardDB.cardIDEnum.EX1_554) //snaketrap
                {

                    //call 3 snakes (if possible)
                    int posi = this.ownMinions.Count - 1;
                    CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_554t);//snake
                    callKid(kid, posi, true);
                    callKid(kid, posi, true);
                    callKid(kid, posi, true);
                }
                if (secretID == CardDB.cardIDEnum.EX1_609) //snipe
                {
                    //kill weakest minion of enemy
                    List<Minion> temp = new List<Minion>(this.enemyMinions);
                    temp.Sort((a, b) => a.Angr.CompareTo(b.Angr));//take the weakest
                    if (temp.Count == 0) continue;
                    Minion m = temp[0];
                    minionGetDamageOrHeal(m, 4);
                }
                if (secretID == CardDB.cardIDEnum.EX1_610) //explosive trap
                {
                    //take 2 damage to each enemy
                    List<Minion> temp = this.enemyMinions;
                    foreach (Minion m in temp)
                    {
                        minionGetDamageOrHeal(m, 2);
                    }
                    attackEnemyHeroWithoutKill(2);
                }
                if (secretID == CardDB.cardIDEnum.EX1_611) //freezing trap
                {
                    //return weakest enemy minion to hand
                    List<Minion> temp = new List<Minion>(this.enemyMinions);
                    temp.Sort((a, b) => a.Angr.CompareTo(b.Angr));//take the weakest
                    if (temp.Count == 0) continue;
                    Minion m = temp[0];
                    minionReturnToHand(m, false, 0);
                }
                if (secretID == CardDB.cardIDEnum.EX1_533) // missdirection
                {
                    // first damage to your hero is nulled -> lower guessingHeroDamage
                    List<Minion> temp = new List<Minion>(this.enemyMinions);
                    temp.Sort((a, b) => -a.Angr.CompareTo(b.Angr));//take the strongest
                    if (temp.Count == 0) continue;
                    Minion m = temp[0];
                    m.Angr = 0;
                    this.evaluatePenality -= this.enemyMinions.Count;// the more the enemy minions has on board, the more the posibility to destroy something other :D
                }

                //mage secrets############
                if (secretID == CardDB.cardIDEnum.EX1_287) //counterspell
                {
                    // what should we do?
                    this.evaluatePenality -= 8;
                }

                if (secretID == CardDB.cardIDEnum.EX1_289) //ice barrier
                {
                    this.ownHero.armor += 8;
                }

                if (secretID == CardDB.cardIDEnum.EX1_295) //ice block
                {
                    //set the guessed Damage to zero
                    this.ownHero.immune = true;
                }

                if (secretID == CardDB.cardIDEnum.EX1_294) //mirror entity
                {
                    //summon snake ( a weak minion)
                    int posi = this.ownMinions.Count - 1;
                    CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_554t);//snake
                    callKid(kid, posi, true);
                }
                if (secretID == CardDB.cardIDEnum.tt_010) //spellbender
                {
                    //whut???
                    // add 2 to your defence (most attack-buffs give +2, lots of damage spells too)
                    this.evaluatePenality -= 4;
                }
                if (secretID == CardDB.cardIDEnum.EX1_594) // vaporize
                {
                    // first damage to your hero is nulled -> lower guessingHeroDamage and destroy weakest minion
                    List<Minion> temp = new List<Minion>(this.enemyMinions);
                    temp.Sort((a, b) => a.Angr.CompareTo(b.Angr));//take the weakest
                    if (temp.Count == 0) continue;
                    Minion m = temp[0];
                    minionGetDestroyed(m);
                }
                if (secretID == CardDB.cardIDEnum.FP1_018) // duplicate
                {
                    // first damage to your hero is nulled -> lower guessingHeroDamage and destroy weakest minion
                    List<Minion> temp = new List<Minion>(this.ownMinions);
                    temp.Sort((a, b) => a.Angr.CompareTo(b.Angr));//take the weakest
                    if (temp.Count == 0) continue;
                    Minion m = temp[0];
                    drawACard(m.name, true);
                    drawACard(m.name, true);
                }

                //pala secrets############
                if (secretID == CardDB.cardIDEnum.EX1_132) // eye for an eye
                {
                    // enemy takes one damage
                    List<Minion> temp = new List<Minion>(this.enemyMinions);
                    temp.Sort((a, b) => a.Angr.CompareTo(b.Angr));//take the weakest
                    if (temp.Count == 0) continue;
                    Minion m = temp[0];
                    attackEnemyHeroWithoutKill(m.Angr);
                }
                if (secretID == CardDB.cardIDEnum.EX1_130) // noble sacrifice
                {
                    //spawn a 2/1 taunt!
                    int posi = this.ownMinions.Count - 1;
                    CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_130a);
                    callKid(kid, posi, true);

                }

                if (secretID == CardDB.cardIDEnum.EX1_136) // redemption
                {
                    // we give our weakest minion a divine shield :D
                    List<Minion> temp = new List<Minion>(this.ownMinions);
                    temp.Sort((a, b) => a.Hp.CompareTo(b.Hp));//take the weakest
                    if (temp.Count == 0) continue;
                    foreach (Minion m in temp)
                    {
                        if (m.divineshild) continue;
                        m.divineshild = true;
                        break;
                    }
                }

                if (secretID == CardDB.cardIDEnum.EX1_379) // repentance
                {
                    // set his current lowest hp minion to x/1
                    List<Minion> temp = new List<Minion>(this.enemyMinions);
                    temp.Sort((a, b) => a.Hp.CompareTo(b.Hp));//take the weakest
                    if (temp.Count == 0) continue;
                    Minion m = temp[0];
                    m.Hp = 1;
                    m.maxHp = 1;
                }

                if (secretID == CardDB.cardIDEnum.FP1_020) // avenge
                {
                    // we give our weakest minion +3/+2 :D
                    List<Minion> temp = new List<Minion>(this.ownMinions);
                    temp.Sort((a, b) => a.Hp.CompareTo(b.Hp));//take the weakest
                    if (temp.Count == 0) continue;
                    foreach (Minion m in temp)
                    {
                        minionGetBuffed(m, 3, 2);
                        break;
                    }
                }
            }

            this.doDmgTriggers();
        }



        //old one, will be replaced soon
        public void endTurn(bool simulateTwoTurns, bool playaround, bool print = false, int pprob = 0, int pprob2 = 0)
        {
            this.value = int.MinValue;
            if (this.turnCounter == 0) this.manaTurnEnd = this.mana;
            this.turnCounter++;
            //penalty for destroying combo

            this.evaluatePenality += ComboBreaker.Instance.checkIfComboWasPlayed(this.playactions, this.ownWeaponName, this.ownHeroName);

            if (this.complete) return;
            this.triggerEndTurn(this.isOwnTurn);
            this.isOwnTurn = !this.isOwnTurn;
            this.triggerStartTurn(this.isOwnTurn);
            this.optionsPlayedThisTurn = 0;
            if (!this.isOwnTurn) simulateTraps();

            if (!sEnemTurn)
            {
                guessHeroDamage();
                this.triggerEndTurn(false);
                this.triggerStartTurn(true);
                this.complete = true;
            }
            else
            {
                guessHeroDamage();
                /*
                if (this.guessingHeroHP >= 1)
                {
                    //simulateEnemysTurn(simulateTwoTurns, playaround, print, pprob, pprob2);
                    this.prepareNextTurn(this.isOwnTurn);

                    if (this.turnCounter >= 2)
                        Ai.Instance.enemySecondTurnSim.simulateEnemysTurn(this, simulateTwoTurns, playaround, print, pprob, pprob2);
                    else
                        Ai.Instance.enemyTurnSim.simulateEnemysTurn(this, simulateTwoTurns, playaround, print, pprob, pprob2);
                }
                this.complete = true;*/
            }

        }

        //prepares the turn for the next player
        public void prepareNextTurn(bool own)
        {
            //call this after start turn trigger!

            if (own)
            {
                this.ownMaxMana = Math.Min(10, this.ownMaxMana + 1);
                this.mana = this.ownMaxMana - this.ueberladung;
                foreach (Minion m in ownMinions)
                {
                    m.numAttacksThisTurn = 0;
                    m.playedThisTurn = false;
                    m.updateReadyness();

                    if (m.concedal)
                    {
                        m.concedal = false;
                        m.stealth = false;
                    }

                }
                //unfreeze the enemy minions
                foreach (Minion m in enemyMinions)
                {
                    m.frozen = false;
                }
                this.enemyHero.frozen = false;


                this.ownHero.Angr = this.ownWeaponAttack;
                this.ownHero.numAttacksThisTurn = 0;
                this.ownAbilityReady = true;
                this.ownHero.updateReadyness();
                this.cardsPlayedThisTurn = 0;
                this.mobsplayedThisTurn = 0;
                this.playedPreparation = false;
                this.playedmagierinderkirintor = false;
                this.optionsPlayedThisTurn = 0;
                this.owncarddraw = 0;
                this.sEnemTurn = false;
            }
            else
            {

                this.enemyMaxMana = Math.Min(10, this.enemyMaxMana + 1);
                this.mana = this.enemyMaxMana; ;//todo enemy overload -this.ueberladung;

                foreach (Minion m in enemyMinions)
                {
                    m.numAttacksThisTurn = 0;
                    m.playedThisTurn = false;
                    m.updateReadyness();
                    if (m.concedal)
                    {
                        m.concedal = false;
                        m.stealth = false;
                    }
                }
                //unfreeze the own minions
                foreach (Minion m in ownMinions)
                {
                    m.frozen = false;
                }
                this.ownHero.frozen = false;

                this.enemyHero.Angr = this.enemyWeaponAttack;
                this.enemyHero.numAttacksThisTurn = 0;
                this.enemyAbilityReady = true;
                this.enemyHero.updateReadyness();
                this.enemyOptionsDoneThisTurn = 0;

                this.cardsPlayedThisTurn = 0;
                this.mobsplayedThisTurn = 0;
                this.playedPreparation = false;
                this.playedmagierinderkirintor = false;

                this.sEnemTurn = false;
            }


            this.ueberladung = 0;
            this.complete = false;

            this.value = int.MinValue;
            if (this.diedMinions != null) this.diedMinions.Clear();//contains only the minions that died in this turn!
        }

        public void endEnemyTurn()
        {
            this.triggerEndTurn(false);
            this.turnCounter++;
            this.isOwnTurn = true;
            this.triggerStartTurn(true);
            this.complete = true;
            //Ai.Instance.botBase.getPlayfieldValue(this);

        }

        //spelldamage calculation---------------------------------------------------
        public int getSpellDamageDamage(int dmg)
        {
            int retval = dmg;
            retval += this.spellpower;
            if (this.doublepriest >= 1) retval *= (2 * this.doublepriest);
            return retval;
        }

        public int getSpellHeal(int heal)
        {
            int retval = heal;
            if (this.anzOwnAuchenaiSoulpriest >= 1)
            {
                retval *= -1;
                retval -= this.spellpower;
            }
            if (this.doublepriest >= 1) retval *= (2 * this.doublepriest);
            return retval;
        }

        public int getMinionHeal(int heal)
        {
            return (this.anzOwnAuchenaiSoulpriest >= 1) ? -heal : heal;
        }

        public int getEnemySpellDamageDamage(int dmg)
        {
            int retval = dmg;
            retval += this.enemyspellpower;
            if (this.enemydoublepriest >= 1) retval *= (2 * this.enemydoublepriest);
            return retval;
        }

        public int getEnemySpellHeal(int heal)
        {
            int retval = heal;
            if (this.anzOwnAuchenaiSoulpriest >= 1)
            {
                retval *= -1;
                retval -= this.enemyspellpower;
            }
            if (this.doublepriest >= 1) retval *= (2 * this.doublepriest);
            return retval;
        }

        public int getEnemyMinionHeal(int heal)
        {
            return (this.anzEnemyAuchenaiSoulpriest >= 1) ? -heal : heal;
        }


        // do the action--------------------------------------------------------------

        public void doAction(Action aa)
        {
            //CREATE NEW MINIONS (cant use a.target or a.own) (dont belong to this board)
            Minion trgt = null;
            Minion o = null;
            Handmanager.Handcard ha = null;
            if (aa.target != null)
            {
                foreach (Minion m in this.ownMinions)
                {
                    if (aa.target.entitiyID == m.entitiyID)
                    {
                        trgt = m;
                        break;
                    }
                }
                foreach (Minion m in this.enemyMinions)
                {
                    if (aa.target.entitiyID == m.entitiyID)
                    {
                        trgt = m;
                        break;
                    }
                }
                if (aa.target.entitiyID == this.ownHero.entitiyID) trgt = this.ownHero;
                if (aa.target.entitiyID == this.enemyHero.entitiyID) trgt = this.enemyHero;
            }
            if (aa.own != null)
            {
                foreach (Minion m in this.ownMinions)
                {
                    if (aa.own.entitiyID == m.entitiyID)
                    {
                        o = m;
                        break;
                    }
                }
                foreach (Minion m in this.enemyMinions)
                {
                    if (aa.own.entitiyID == m.entitiyID)
                    {
                        o = m;
                        break;
                    }
                }
                if (aa.own.entitiyID == this.ownHero.entitiyID) o = this.ownHero;
                if (aa.own.entitiyID == this.enemyHero.entitiyID) o = this.enemyHero;
            }

            if (aa.card != null)
            {
                foreach (Handmanager.Handcard hh in this.owncards)
                {
                    if (hh.entity == aa.card.entity)
                    {
                        ha = hh;
                        break;
                    }
                }
                if (aa.actionType == actionEnum.useHeroPower)
                {
                    ha = this.isOwnTurn ? this.ownHeroAblility : this.enemyHeroAblility;
                }
            }
            // create and execute the action------------------------------------------------------------------------
            Action a = new Action(aa.actionType, ha, o, aa.place, trgt, aa.penalty, aa.druidchoice);



            //save the action if its our first turn
            if (this.turnCounter == 0) this.playactions.Add(a);
            //if (this.isOwnTurn) this.playactions.Add(a);

            // its a minion attack--------------------------------
            if (a.actionType == actionEnum.attackWithMinion)
            {
                this.evaluatePenality += a.penalty;
                Minion target = a.target;
                //secret stuff
                int newTarget = this.secretTrigger_CharIsAttacked(a.own, target);

                if (newTarget >= 1)
                {
                    //search new target!
                    foreach (Minion m in this.ownMinions)
                    {
                        if (m.entitiyID == newTarget)
                        {
                            target = m;
                            break;
                        }
                    }
                    foreach (Minion m in this.enemyMinions)
                    {
                        if (m.entitiyID == newTarget)
                        {
                            target = m;
                            break;
                        }
                    }
                    if (this.ownHero.entitiyID == newTarget) target = this.ownHero;
                    if (this.enemyHero.entitiyID == newTarget) target = this.enemyHero;
                    //Helpfunctions.Instance.ErrorLog("missdirection target = " + target.entitiyID);
                }
                if (a.own.Hp >= 1) minionAttacksMinion(a.own, target);
            }
            else
            {
                // its an hero attack--------------------------------
                if (a.actionType == actionEnum.attackWithHero)
                {
                    //secret trigger is inside
                    attackWithWeapon(a.own, a.target, a.penalty);
                }
                else
                {
                    // its an playing-card--------------------------------
                    if (a.actionType == actionEnum.playcard)
                    {
                        if (this.isOwnTurn)
                        {
                            playACard(a.card, a.target, a.place, a.druidchoice, a.penalty);
                        }
                        else
                        {
                            //enemyplaysACard();
                        }
                    }
                    else
                    {
                        // its using the hero power--------------------------------
                        if (a.actionType == actionEnum.useHeroPower)
                        {
                            playHeroPower(a.target, a.penalty, this.isOwnTurn);
                        }
                    }
                }
            }







            if (this.isOwnTurn)
            {
                this.optionsPlayedThisTurn++;
            }
            else
            {
                this.enemyOptionsDoneThisTurn++;
            }

        }

        //minion attacks a minion

        //dontcount = betrayal effect!
        public void minionAttacksMinion(Minion attacker, Minion defender, bool dontcount = false)
        {

            if (attacker.isHero)
            {
                if (defender.isHero)
                {

                    defender.getDamageOrHeal(attacker.Angr, this, true, false);
                }
                else
                {

                    int enem_attack = defender.Angr;

                    defender.getDamageOrHeal(attacker.Angr, this, true, false);

                    if (!this.ownHero.immuneWhileAttacking)
                    {
                        int oldhp = attacker.Hp;
                        attacker.getDamageOrHeal(enem_attack, this, true, false);
                        if (!defender.silenced && oldhp > attacker.Hp)
                        {
                            if (defender.handcard.card.name == CardDB.cardName.waterelemental || defender.handcard.card.name == CardDB.cardName.snowchugger)
                            {
                                attacker.frozen = true;
                            }

                            this.triggerAMinionDealedDmg(defender, oldhp - attacker.Hp);
                        }
                    }
                }
                doDmgTriggers();
                return;
            }

            if (!dontcount)
            {
                attacker.numAttacksThisTurn++;
                attacker.stealth = false;
                if ((attacker.windfury && attacker.numAttacksThisTurn == 2) || !attacker.windfury)
                {
                    attacker.Ready = false;
                }

            }


            if (logging) Helpfunctions.Instance.logg(".attck with" + attacker.name + " A " + attacker.Angr + " H " + attacker.Hp);

            int attackerAngr = attacker.Angr;
            int defAngr = defender.Angr;

            //trigger attack ---------------------------
            this.triggerAMinionIsGoingToAttack(attacker);
            //------------------------------------------

            if (defender.isHero)//target is enemy hero
            {

                int oldhp = defender.Hp;
                defender.getDamageOrHeal(attacker.Angr, this, true, false);
                if (!attacker.silenced && oldhp > defender.Hp) // attacker did dmg
                {

                    if (attacker.handcard.card.name == CardDB.cardName.waterelemental || attacker.handcard.card.name == CardDB.cardName.snowchugger) defender.frozen = true;

                    this.triggerAMinionDealedDmg(attacker, oldhp - defender.Hp);
                }
                doDmgTriggers();
                return;
            }



            //defender gets dmg
            int oldHP = defender.Hp;
            defender.getDamageOrHeal(attackerAngr, this, true, false);
            if (!attacker.silenced && oldHP > defender.Hp && (attacker.handcard.card.name == CardDB.cardName.waterelemental || attacker.handcard.card.name == CardDB.cardName.snowchugger)) defender.frozen = true;
            bool defenderGotDmg = oldHP > defender.Hp;

            bool attackerGotDmg = false;

            //attacker gets dmg
            if (!dontcount)//betrayal effect :D
            {
                oldHP = attacker.Hp;
                attacker.getDamageOrHeal(defAngr, this, true, false);

                if (!defender.silenced && oldHP > attacker.Hp)
                {
                    if (defender.handcard.card.name == CardDB.cardName.waterelemental || defender.handcard.card.name == CardDB.cardName.snowchugger) attacker.frozen = true;

                    this.triggerAMinionDealedDmg(defender, oldHP - attacker.Hp);
                }
                attackerGotDmg = oldHP > attacker.Hp;
            }


            //trigger poisonous effect of attacker + defender (even if they died due to attacking/defending)

            if (defenderGotDmg && !attacker.silenced && attacker.handcard.card.poisionous && !defender.isHero)
            {
                minionGetDestroyed(defender);
            }

            if (attackerGotDmg && !defender.silenced && defender.handcard.card.poisionous && !attacker.isHero)
            {
                minionGetDestroyed(attacker);
            }

            if (!dontcount) //foe reaper reaps!
            {
                if (attacker.name == CardDB.cardName.foereaper4000 && !attacker.silenced)
                {
                    List<Minion> temp = (attacker.own) ? this.enemyMinions : this.ownMinions;
                    foreach (Minion mnn in temp)
                    {
                        if (mnn.zonepos + 1 == defender.zonepos || mnn.zonepos - 1 == defender.zonepos)
                        {
                            this.minionAttacksMinion(attacker, mnn, true);
                        }
                    }
                }
            }

            this.doDmgTriggers();



        }

        //a hero attacks a minion
        public void attackWithWeapon(Minion hero, Minion target, int penality)
        {
            bool own = hero.own;
            this.attacked = true;
            this.evaluatePenality += penality;
            hero.numAttacksThisTurn++;

            //hero will end his readyness
            hero.updateReadyness();

            //heal whether truesilverchampion equipped
            if (own)
            {
                if (this.ownWeaponName == CardDB.cardName.truesilverchampion)
                {
                    int heal = this.getMinionHeal(2);//minionheal because it's ignoring spellpower
                    this.minionGetDamageOrHeal(hero, -heal);
                    doDmgTriggers();
                }
            }
            else
            {
                if (this.enemyWeaponName == CardDB.cardName.truesilverchampion)
                {
                    int heal = this.getEnemyMinionHeal(2);
                    this.minionGetDamageOrHeal(hero, -heal);
                    doDmgTriggers();
                }
            }

            if (logging) Helpfunctions.Instance.logg("attck with weapon trgt: " + target.entitiyID);

            // hero attacks enemy----------------------------------------------------------------------------------

            if (target.isHero)// trigger secret and change target if necessary
            {
                int newTarget = this.secretTrigger_CharIsAttacked(hero, target);
                if (newTarget >= 1)
                {
                    //search new target!
                    foreach (Minion m in this.ownMinions)
                    {
                        if (m.entitiyID == newTarget)
                        {
                            target = m;
                            break;
                        }
                    }
                    foreach (Minion m in this.enemyMinions)
                    {
                        if (m.entitiyID == newTarget)
                        {
                            target = m;
                            break;
                        }
                    }
                    if (this.ownHero.entitiyID == newTarget) target = this.ownHero;
                    if (this.enemyHero.entitiyID == newTarget) target = this.enemyHero;
                }

            }
            this.minionAttacksMinion(hero, target);
            //-----------------------------------------------------------------------------------------------------

            //gorehowl is not killed if he attacks minions
            if (own)
            {
                if (ownWeaponName == CardDB.cardName.gorehowl && !target.isHero)
                {
                    this.ownWeaponAttack--;
                    hero.Angr--;
                }
                else
                {
                    this.lowerWeaponDurability(1, true);
                }
            }
            else
            {
                if (enemyWeaponName == CardDB.cardName.gorehowl && !target.isHero)
                {
                    this.enemyWeaponAttack--;
                    hero.Angr--;
                }
                else
                {
                    this.lowerWeaponDurability(1, false);
                }
            }

        }

        //play a minion trigger stuff:
        // 1 whenever you play a card whatever triggers
        // 2 Auras
        // 5 whenever you summon a minion triggers (like starving buzzard)
        // 3 battlecry
        // 3.5 place minion
        // 3.75 dmg/died/dthrttl triggers
        // 4 secret: minion is played
        // 4.5 dmg/died/dthrttl triggers
        // 5 after you summon a minion triggers
        // 5.5 dmg/died/dthrttl triggers
        public void playACard(Handmanager.Handcard hc, Minion target, int position, int choice, int penality)
        {

            CardDB.Card c = hc.card;
            this.evaluatePenality += penality;
            this.mana = this.mana - hc.getManaCost(this);
            removeCard(hc);// remove card from hand

            this.triggerCardsChanged(true);

            if (c.type == CardDB.cardtype.SPELL) this.playedPreparation = false;

            if (c.Secret)
            {
                this.ownSecretsIDList.Add(c.cardIDenum);
                this.playedmagierinderkirintor = false;
            }


            //Helpfunctions.Instance.logg("play crd " + c.name + " entitiy# " + cardEntity + " mana " + hc.getManaCost(this) + " trgt " + target);
            if (logging) Helpfunctions.Instance.logg("play crd " + c.name + " entitiy# " + hc.entity + " mana " + hc.getManaCost(this) + " trgt " + target);


            this.triggerACardWillBePlayed(hc, true);
            int newTarget = secretTrigger_SpellIsPlayed(target, c.type == CardDB.cardtype.SPELL);
            if (newTarget >= 1)
            {
                //search new target!
                foreach (Minion m in this.ownMinions)
                {
                    if (m.entitiyID == newTarget)
                    {
                        target = m;
                        break;
                    }
                }
                foreach (Minion m in this.enemyMinions)
                {
                    if (m.entitiyID == newTarget)
                    {
                        target = m;
                        break;
                    }
                }
                if (this.ownHero.entitiyID == newTarget) target = this.ownHero;
                if (this.enemyHero.entitiyID == newTarget) target = this.enemyHero;
            }
            if (newTarget != -2) // trigger spell-secrets!
            {

                if (c.type == CardDB.cardtype.MOB)
                {
                    this.placeAmobSomewhere(hc, target, choice, position);
                    this.mobsplayedThisTurn++;

                }
                else
                {

                    c.sim_card.onCardPlay(this, true, target, choice);
                    this.doDmgTriggers();
                    //secret trigger? do here


                }

                //atm only 2 cards trigger this
                if (c.type == CardDB.cardtype.SPELL)
                {
                    this.triggerACardWasPlayed(c, true);
                    this.doDmgTriggers();
                }
            }

            //this.ueberladung += c.recallValue;
            this.cardsPlayedThisTurn++;

        }

        public void enemyplaysACard(CardDB.Card c, Minion target, int position, int choice, int penality)
        {

            Handmanager.Handcard hc = new Handmanager.Handcard(c);
            hc.entity = this.getNextEntity();
            //Helpfunctions.Instance.logg("play crd " + c.name + " entitiy# " + cardEntity + " mana " + hc.getManaCost(this) + " trgt " + target);
            if (logging) Helpfunctions.Instance.logg("enemy play crd " + c.name + " trgt " + target);

            this.enemyAnzCards--;//might be deleted if he got a real hand

            this.triggerACardWillBePlayed(hc, false);
            this.triggerCardsChanged(false);

            int newTarget = secretTrigger_SpellIsPlayed(target, c.type == CardDB.cardtype.SPELL);
            if (newTarget >= 1)
            {
                //search new target!
                foreach (Minion m in this.ownMinions)
                {
                    if (m.entitiyID == newTarget)
                    {
                        target = m;
                        break;
                    }
                }
                foreach (Minion m in this.enemyMinions)
                {
                    if (m.entitiyID == newTarget)
                    {
                        target = m;
                        break;
                    }
                }
                if (this.ownHero.entitiyID == newTarget) target = this.ownHero;
                if (this.enemyHero.entitiyID == newTarget) target = this.enemyHero;
            }
            if (newTarget != -2) // trigger spell-secrets!
            {
                if (c.type == CardDB.cardtype.MOB)
                {
                    //todo mob playing
                    //this.placeAmobSomewhere(hc, target, choice, position);

                }
                else
                {
                    c.sim_card.onCardPlay(this, false, target, choice);
                    this.doDmgTriggers();
                    //secret trigger? do here


                }
            }

            //atm only 2 cards trigger this
            if (c.type == CardDB.cardtype.SPELL)
            {
                this.triggerACardWasPlayed(c, false);
                this.doDmgTriggers();
            }

        }


        public void playHeroPower(Minion target, int penality, bool ownturn)
        {

            CardDB.Card c = (ownturn) ? this.ownHeroAblility.card : this.enemyHeroAblility.card;

            if (ownturn) this.ownAbilityReady = false;
            else this.enemyAbilityReady = false;

            this.evaluatePenality += penality;
            this.mana = this.mana - 2;

            //Helpfunctions.Instance.logg("play crd " + c.name + " entitiy# " + cardEntity + " mana " + hc.getManaCost(this) + " trgt " + target);
            if (logging) Helpfunctions.Instance.logg("play crd " + c.name + " trgt " + target);

            c.sim_card.onCardPlay(this, ownturn, target, 0);
            this.doDmgTriggers();
        }


        //lower durability of weapon + destroy them (deathrattle) 
        //todo: test death's bite's dearthrattle
        public void lowerWeaponDurability(int value, bool own)
        {

            if (own)
            {
                if (this.ownWeaponDurability <= 0) return;
                this.ownWeaponDurability -= value;
                if (this.ownWeaponDurability <= 0)
                {
                    //todo deathrattle deathsbite

                    if (this.ownWeaponName == CardDB.cardName.powermace && this.ownMinions.Count >= 1)
                    {
                        int sum = 1000;
                        Minion t = null;

                        foreach (Minion m in ownMinions)
                        {
                            if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL)
                            {
                                int s = m.maxHp + m.Angr;
                                if (s < sum)
                                {
                                    t = m;
                                    sum = s;
                                }
                            }

                        }

                        if (t != null && sum < 999)
                        {
                            this.minionGetBuffed(t, 2, 2);
                        }
                    }

                    if (this.ownWeaponName == CardDB.cardName.deathsbite)
                    {
                        int anz = 1;
                        if (this.ownBaronRivendare >= 1) anz = 2;
                        int dmg = getSpellDamageDamage(1);
                        foreach (Minion m in this.ownMinions)
                        {
                            this.minionGetDamageOrHeal(m, anz * dmg);
                        }
                        foreach (Minion m in this.enemyMinions)
                        {
                            this.minionGetDamageOrHeal(m, anz * dmg);
                        }
                        this.doDmgTriggers();

                    }


                    this.ownHero.Angr -= this.ownWeaponAttack;
                    this.ownWeaponDurability = 0;
                    this.ownWeaponAttack = 0;
                    this.ownWeaponName = CardDB.cardName.unknown;
                    this.ownHero.windfury = false;

                    foreach (Minion m in this.ownMinions)
                    {
                        if (m.playedThisTurn && m.name == CardDB.cardName.southseadeckhand)
                        {
                            m.charge--;
                            m.updateReadyness();
                        }
                    }
                    this.ownHero.updateReadyness();
                }
            }
            else
            {
                if (this.enemyWeaponDurability <= 0) return;
                this.enemyWeaponDurability -= value;
                if (this.enemyWeaponDurability <= 0)
                {
                    //deathrattle deathsbite

                    if (this.ownWeaponName == CardDB.cardName.powermace && this.enemyMinions.Count >= 1)
                    {
                        int sum = 1000;
                        Minion t = null;

                        foreach (Minion m in enemyMinions)
                        {
                            if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL)
                            {
                                int s = m.maxHp + m.Angr;
                                if (s < sum)
                                {
                                    t = m;
                                    sum = s;
                                }
                            }

                        }

                        if (t != null && sum < 999)
                        {
                            this.minionGetBuffed(t, 2, 2);
                        }
                    }

                    if (this.enemyWeaponName == CardDB.cardName.deathsbite)
                    {
                        int anz = 1;
                        if (this.enemyBaronRivendare >= 1) anz = 2;
                        int dmg = getEnemySpellDamageDamage(1);
                        foreach (Minion m in this.ownMinions)
                        {
                            this.minionGetDamageOrHeal(m, anz * dmg);
                        }
                        foreach (Minion m in this.enemyMinions)
                        {
                            this.minionGetDamageOrHeal(m, anz * dmg);
                        }
                        this.doDmgTriggers();
                    }

                    this.enemyHero.Angr -= this.enemyWeaponAttack;
                    this.enemyWeaponDurability = 0;
                    this.enemyWeaponAttack = 0;
                    this.enemyWeaponName = CardDB.cardName.unknown;
                    this.enemyHero.windfury = false;
                    this.enemyHero.updateReadyness();
                }
            }
        }



        public void doDmgTriggers()
        {
            //we do the these trigger manualy (to less minions) (we could trigger them with m.handcard.card.sim_card.ontrigger...)
            if (this.tempTrigger.charsGotHealed >= 1)
            {
                triggerACharGotHealed();//possible effects: gain attack
                this.tempTrigger.charsGotHealed = 0;
            }

            if (this.tempTrigger.minionsGotHealed >= 1)
            {
                triggerAMinionGotHealed();//possible effects: draw card
                this.tempTrigger.minionsGotHealed = 0;
            }


            if (this.tempTrigger.ownMinionsGotDmg + this.tempTrigger.enemyMinionsGotDmg >= 1)
            {
                triggerAMinionGotDmg(); //possible effects: draw card, gain armor, gain attack
                this.tempTrigger.ownMinionsGotDmg = 0;
                this.tempTrigger.enemyMinionsGotDmg = 0;
                this.tempTrigger.ownHeroGotDmg = 0;
                this.tempTrigger.enemyHeroGotDmg = 0;
            }

            if (this.tempTrigger.ownMinionsDied + this.tempTrigger.enemyMinionsDied >= 1)
            {
                triggerAMinionDied(); //possible effects: draw card, gain attack + hp
                if (this.tempTrigger.ownMinionsDied >= 1) this.tempTrigger.ownMinionsChanged = true;
                if (this.tempTrigger.enemyMinionsDied >= 1) this.tempTrigger.enemyMininsChanged = true;
                this.tempTrigger.ownMinionsDied = 0;
                this.tempTrigger.enemyMinionsDied = 0;
                this.tempTrigger.ownBeastDied = 0;
                this.tempTrigger.enemyBeastDied = 0;
                this.tempTrigger.ownMurlocDied = 0;
                this.tempTrigger.enemyMurlocDied = 0;
                this.tempTrigger.ownMechanicDied = 0;
                this.tempTrigger.enemyMechanicDied = 0;
            }

            updateBoards();
            if (this.tempTrigger.charsGotHealed + this.tempTrigger.minionsGotHealed + this.tempTrigger.ownMinionsGotDmg + this.tempTrigger.enemyMinionsGotDmg + this.tempTrigger.ownMinionsDied + this.tempTrigger.enemyMinionsDied >= 1)
            {
                doDmgTriggers();
            }
        }

        public void triggerACharGotHealed()
        {
            foreach (Minion mnn in this.ownMinions)
            {
                if (mnn.silenced) continue;
                if (mnn.handcard.card.name == CardDB.cardName.lightwarden)
                {
                    minionGetBuffed(mnn, 2 * this.tempTrigger.charsGotHealed, 0);
                }
                if (mnn.handcard.card.name == CardDB.cardName.shadowboxer)
                {
                    for (int i = 0; i < this.tempTrigger.charsGotHealed; i++)
                    {
                        Minion t = this.searchRandomMinion(this.enemyMinions, searchmode.searchHighestHP);
                        if (t != null)
                        {
                            this.minionGetDamageOrHeal(t, 1);
                        }
                        else
                        {
                            this.minionGetDamageOrHeal(this.enemyHero, 1);
                        }
                    }
                }
            }
            foreach (Minion mnn in this.enemyMinions)
            {
                if (mnn.silenced) continue;
                if (mnn.handcard.card.name == CardDB.cardName.lightwarden)
                {
                    minionGetBuffed(mnn, 2 * this.tempTrigger.charsGotHealed, 0);
                }
                if (mnn.handcard.card.name == CardDB.cardName.shadowboxer)
                {
                    for (int i = 0; i < this.tempTrigger.charsGotHealed; i++)
                    {
                        Minion t = this.searchRandomMinion(this.ownMinions, searchmode.searchHighestHP);
                        if (t != null)
                        {
                            this.minionGetDamageOrHeal(t, 1);
                        }
                        else
                        {
                            this.minionGetDamageOrHeal(this.ownHero, 1);
                        }
                    }
                }
            }
        }

        public void triggerAMinionGotHealed()
        {
            //also dead minions trigger this
            foreach (Minion mnn in this.ownMinions)
            {
                if (mnn.silenced) continue;
                if (mnn.handcard.card.name == CardDB.cardName.northshirecleric)
                {
                    for (int i = 0; i < this.tempTrigger.minionsGotHealed; i++)
                    {
                        this.drawACard(CardDB.cardName.unknown, true);
                    }
                }
            }

            foreach (Minion mnn in this.enemyMinions)
            {
                if (mnn.silenced) continue;
                if (mnn.handcard.card.name == CardDB.cardName.northshirecleric)
                {
                    for (int i = 0; i < this.tempTrigger.minionsGotHealed; i++)
                    {
                        this.drawACard(CardDB.cardName.unknown, false);
                    }
                }
            }
        }

        public void triggerAMinionGotDmg()
        {
            /*
            int anz = this.tempTrigger.ownMinionsGotDmg + this.tempTrigger.enemyMinionsGotDmg;
            for (int i = 0; i < anz; i++)
            {
                foreach (Minion m in this.ownMinions)
                {
                    m.handcard.card.sim_card.onMinionGotDmgTrigger(this, m, i < this.tempTrigger.ownMinionsGotDmg);
                }

                foreach (Minion m in this.enemyMinions)
                {
                    m.handcard.card.sim_card.onMinionGotDmgTrigger(this, m, i < this.tempTrigger.ownMinionsGotDmg);
                }
            }*/

            // only 4 minions.. we do this manually :D
            //allso dead minion trigger this!
            foreach (Minion m in this.ownMinions)
            {
                if (m.silenced)
                {
                    m.anzGotDmg = 0;
                    continue;
                }

                if (m.name == CardDB.cardName.frothingberserker)
                {
                    this.minionGetBuffed(m, this.tempTrigger.ownMinionsGotDmg + this.tempTrigger.enemyMinionsGotDmg, 0);
                }

                if (m.name == CardDB.cardName.gurubashiberserker && m.anzGotDmg >= 1)
                {
                    this.minionGetBuffed(m, 3 * m.anzGotDmg, 0);
                }

                if (m.name == CardDB.cardName.acolyteofpain && m.anzGotDmg >= 1)
                {
                    for (int i = 0; i < m.anzGotDmg; i++)
                    {
                        this.drawACard(CardDB.cardName.unknown, true);
                    }
                }

                if (m.name == CardDB.cardName.armorsmith)
                {
                    for (int i = 0; i < this.tempTrigger.ownMinionsGotDmg; i++)
                    {
                        this.minionGetArmor(this.ownHero, 1);
                    }
                }

                if (m.name == CardDB.cardName.gahzrilla && m.anzGotDmg >= 1)
                {
                    this.minionGetBuffed(m, m.Angr * (2 ^ m.anzGotDmg) - m.Angr, 0);
                }

                if (this.isOwnTurn && m.name == CardDB.cardName.floatingwatcher && this.ownHero.anzGotDmg >= 1)
                {
                    this.minionGetBuffed(m, 2 * this.ownHero.anzGotDmg, 2 * this.ownHero.anzGotDmg);
                }

                if (m.name == CardDB.cardName.mechbearcat && m.anzGotDmg >= 1)
                {
                    for (int i = 0; i < m.anzGotDmg; i++)
                    {
                        this.drawACard(CardDB.cardName.armorplating, true, true);
                    }
                }

                m.anzGotDmg = 0;


            }

            foreach (Minion m in this.enemyMinions)
            {
                if (m.silenced)
                {
                    m.anzGotDmg = 0;
                    continue;
                }

                if (m.name == CardDB.cardName.frothingberserker)
                {
                    this.minionGetBuffed(m, this.tempTrigger.ownMinionsGotDmg + this.tempTrigger.enemyMinionsGotDmg, 0);
                }

                if (m.name == CardDB.cardName.gurubashiberserker && m.anzGotDmg >= 1)
                {
                    this.minionGetBuffed(m, 3 * m.anzGotDmg, 0);
                }

                if (m.name == CardDB.cardName.acolyteofpain && m.anzGotDmg >= 1)
                {
                    for (int i = 0; i < m.anzGotDmg; i++)
                    {
                        this.drawACard(CardDB.cardName.unknown, false);
                    }
                }

                if (m.name == CardDB.cardName.armorsmith)
                {
                    for (int i = 0; i < this.tempTrigger.enemyMinionsGotDmg; i++)
                    {
                        this.minionGetArmor(this.enemyHero, 1);
                    }
                }

                if (m.name == CardDB.cardName.gahzrilla && m.anzGotDmg >= 1)
                {
                    this.minionGetBuffed(m, m.Angr * (2 ^ m.anzGotDmg) - m.Angr, 0);
                }

                if (!this.isOwnTurn && m.name == CardDB.cardName.floatingwatcher && this.enemyHero.anzGotDmg >= 1)
                {
                    this.minionGetBuffed(m, 2 * this.enemyHero.anzGotDmg, 2 * this.enemyHero.anzGotDmg);
                }

                if (m.name == CardDB.cardName.mechbearcat && m.anzGotDmg >= 1)
                {
                    for (int i = 0; i < m.anzGotDmg; i++)
                    {
                        this.drawACard(CardDB.cardName.armorplating, false, true);
                    }
                }
                m.anzGotDmg = 0;
            }


            this.ownHero.anzGotDmg = 0;
            this.enemyHero.anzGotDmg = 0;
        }

        public void triggerAMinionDied()
        {
            int summonOwn = 0;
            int summonEnemy = 0;
            foreach (Minion mnn in this.ownMinions)
            {
                if (mnn.silenced) continue;
                if (mnn.Hp <= 0) continue;
                if (mnn.handcard.card.name == CardDB.cardName.cultmaster)
                {
                    int anz = this.tempTrigger.ownMinionsDied;
                    if (mnn.Hp <= 0) anz--;//only other minions

                    for (int i = 0; i < anz; i++)
                    {
                        this.drawACard(CardDB.cardName.unknown, true);
                    }
                }

                if (mnn.handcard.card.name == CardDB.cardName.flesheatingghoul)
                {
                    this.minionGetBuffed(mnn, this.tempTrigger.ownMinionsDied + this.tempTrigger.enemyMinionsDied, 0);
                }

                if (mnn.handcard.card.name == CardDB.cardName.scavenginghyena)
                {
                    this.minionGetBuffed(mnn, 2 * this.tempTrigger.ownBeastDied, this.tempTrigger.ownBeastDied);
                }

                if (mnn.handcard.card.name == CardDB.cardName.oldmurkeye)
                {
                    this.minionGetBuffed(mnn, -1 * (this.tempTrigger.ownMurlocDied + this.tempTrigger.enemyMurlocDied), 0);
                }

                if (mnn.handcard.card.name == CardDB.cardName.siltfinspiritwalker)
                {
                    for (int i = 0; i < this.tempTrigger.ownMurlocDied; i++)
                    {
                        this.drawACard(CardDB.cardName.unknown, true);
                    }
                }

                if (mnn.handcard.card.name == CardDB.cardName.cogmaster)
                {
                    if (this.tempTrigger.ownMechanicDied >= 1)
                    {
                        //check if we have more mechanics, or debuff him
                        bool hasmechanics = false;
                        foreach (Minion m in this.ownMinions)
                        {
                            if (m.Hp >= 1 && (TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL) hasmechanics = true;
                        }

                        if (!hasmechanics)
                        {
                            //we have no living mechanics -> debuff cogmaster
                            this.minionGetBuffed(mnn, -2, 0);
                        }



                    }
                }

                if (mnn.handcard.card.name == CardDB.cardName.cogmasterswrench)
                {
                    if (this.tempTrigger.ownMechanicDied >= 1)
                    {
                        //check if we have more mechanics, or debuff him
                        bool hasmechanics = false;
                        foreach (Minion m in this.ownMinions)
                        {
                            if (m.Hp >= 1 && (TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL) hasmechanics = true;
                        }

                        if (!hasmechanics)
                        {
                            this.ownWeaponAttack -= 2;
                            this.minionGetBuffed(this.ownHero, -2, 0);
                        }



                    }
                }


                if (mnn.handcard.card.name == CardDB.cardName.junkbot)
                {
                    this.minionGetBuffed(mnn, 2 * this.tempTrigger.ownMechanicDied, 2 * this.tempTrigger.ownMechanicDied);
                }

                if (mnn.handcard.card.name == CardDB.cardName.mekgineerthermaplugg)
                {
                    summonOwn += this.tempTrigger.enemyMinionsDied;
                }

            }
            foreach (Minion mnn in this.enemyMinions)
            {
                if (mnn.silenced) continue;
                if (mnn.Hp <= 0) continue;
                if (mnn.handcard.card.name == CardDB.cardName.cultmaster)
                {
                    int anz = this.tempTrigger.enemyMinionsDied;
                    if (mnn.Hp <= 0) anz--;//only other minions

                    for (int i = 0; i < anz; i++)
                    {
                        this.drawACard(CardDB.cardName.unknown, false);
                    }
                }

                if (mnn.handcard.card.name == CardDB.cardName.flesheatingghoul)
                {
                    this.minionGetBuffed(mnn, this.tempTrigger.ownMinionsDied + this.tempTrigger.enemyMinionsDied, 0);
                }

                if (mnn.handcard.card.name == CardDB.cardName.scavenginghyena)
                {
                    this.minionGetBuffed(mnn, 2 * this.tempTrigger.enemyBeastDied, this.tempTrigger.enemyBeastDied);
                }

                if (mnn.handcard.card.name == CardDB.cardName.oldmurkeye)
                {
                    this.minionGetBuffed(mnn, -1 * (this.tempTrigger.ownMurlocDied + this.tempTrigger.enemyMurlocDied), 0);
                }

                if (mnn.handcard.card.name == CardDB.cardName.siltfinspiritwalker)
                {
                    for (int i = 0; i < this.tempTrigger.enemyMurlocDied; i++)
                    {
                        this.drawACard(CardDB.cardName.unknown, false);
                    }
                }

                if (mnn.handcard.card.name == CardDB.cardName.cogmaster)
                {
                    if (this.tempTrigger.enemyMechanicDied >= 1)
                    {
                        //check if we have more mechanics, or debuff him
                        bool hasmechanics = false;
                        foreach (Minion m in this.enemyMinions)
                        {
                            if (m.Hp >= 1 && (TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL) hasmechanics = true;
                        }

                        if (!hasmechanics)
                        {
                            //we have no living mechanics -> debuff cogmaster
                            this.minionGetBuffed(mnn, -2, 0);
                        }



                    }
                }

                if (mnn.handcard.card.name == CardDB.cardName.cogmasterswrench)
                {
                    if (this.tempTrigger.ownMechanicDied >= 1)
                    {
                        //check if we have more mechanics, or debuff him
                        bool hasmechanics = false;
                        foreach (Minion m in this.ownMinions)
                        {
                            if (m.Hp >= 1 && (TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL) hasmechanics = true;
                        }

                        if (!hasmechanics)
                        {
                            this.enemyWeaponAttack -= 2;
                            this.minionGetBuffed(this.enemyHero, -2, 0);
                        }



                    }
                }

                if (mnn.handcard.card.name == CardDB.cardName.junkbot)
                {
                    this.minionGetBuffed(mnn, 2 * this.tempTrigger.enemyMechanicDied, 2 * this.tempTrigger.enemyMechanicDied);
                }

                if (mnn.handcard.card.name == CardDB.cardName.mekgineerthermaplugg)
                {
                    summonEnemy += this.tempTrigger.ownMinionsDied;
                }
            }

            foreach (Handmanager.Handcard hc in this.owncards)
            {
                if (hc.card.name == CardDB.cardName.bolvarfordragon) hc.addattack += this.tempTrigger.ownMinionsDied;
            }

            if (summonOwn >= 1)
            {
                for (int i = 0; i < summonOwn; i++)
                {
                    int pos = this.ownMinions.Count;
                    this.callKid(CardDB.Instance.lepergnome, pos, true);
                }
            }
            if (summonEnemy >= 1)
            {
                for (int i = 0; i < summonEnemy; i++)
                {
                    int pos = this.enemyMinions.Count;
                    this.callKid(CardDB.Instance.lepergnome, pos, false);
                }
            }
        }

        public void triggerAMinionIsGoingToAttack(Minion m)
        {
            //todo trigger secret her too
            //blessing of wisdom (truesilver is located in attackWithWeapon(...))
            if (m.ownBlessingOfWisdom >= 1)
            {
                for (int i = 0; i < m.ownBlessingOfWisdom; i++)
                {
                    this.drawACard(CardDB.cardName.unknown, true);
                }
            }
            if (m.enemyBlessingOfWisdom >= 1)
            {
                for (int i = 0; i < m.enemyBlessingOfWisdom; i++)
                {
                    this.drawACard(CardDB.cardName.unknown, false);
                }
            }

        }

        public void triggerAMinionDealedDmg(Minion m, int dmgDone)
        {
            //only GVG_018 has such an trigger!
            if (m.name == CardDB.cardName.mistressofpain && dmgDone >= 1)
            {
                if (m.own)
                {
                    if (this.anzOwnAuchenaiSoulpriest >= 1) // you have a soulpriest? lol you die!!!
                    {
                        this.ownHero.Hp = 0;
                    }
                    else
                    {
                        this.minionGetDamageOrHeal(this.ownHero, -dmgDone);
                    }
                }
                else
                {
                    if (this.anzEnemyAuchenaiSoulpriest >= 1) // you have a soulpriest? lol you die!!!
                    {
                        this.enemyHero.Hp = 0;
                    }
                    else
                    {
                        this.minionGetDamageOrHeal(this.enemyHero, -dmgDone);
                    }
                }
            }

        }

        public void triggerACardWillBePlayed(Handmanager.Handcard hc, bool own)
        {
            if (own)
            {
                int violetteacher = 0; //we count violetteacher to avoid copying ownminions
                int illidan = 0;
                int burly = 0;
                foreach (Minion m in this.ownMinions)
                {
                    if (m.silenced) continue;

                    if (own && m.name == CardDB.cardName.illidanstormrage)
                    {
                        illidan++;
                        continue;
                    }

                    if (own && m.name == CardDB.cardName.violetteacher)
                    {
                        if (hc.card.type == CardDB.cardtype.SPELL)
                        {
                            violetteacher++;
                        }
                        continue;
                    }
                    if (own && m.name == CardDB.cardName.hobgoblin)
                    {
                        if (hc.card.type == CardDB.cardtype.MOB && hc.card.Attack == 1)
                        {
                            hc.addattack += 2;
                            hc.addHp += 2;
                        }
                        continue;
                    }

                    m.handcard.card.sim_card.onCardIsGoingToBePlayed(this, hc.card, own, m);
                }

                foreach (Minion m in this.enemyMinions)
                {
                    if (m.name == CardDB.cardName.troggzortheearthinator)
                    {
                        burly++;
                    }
                    if (m.name == CardDB.cardName.felreaver)
                    {
                        m.handcard.card.sim_card.onCardIsGoingToBePlayed(this, hc.card, own, m);
                    }
                }

                for (int i = 0; i < violetteacher; i++)
                {
                    int pos = this.ownMinions.Count;
                    this.callKid(CardDB.Instance.teacherminion, pos, own);
                }

                for (int i = 0; i < illidan; i++)
                {
                    int pos = this.ownMinions.Count;
                    this.callKid(CardDB.Instance.illidanminion, pos, own);
                }

                for (int i = 0; i < burly; i++)//summon for enemy !
                {
                    int pos = this.enemyMinions.Count;
                    this.callKid(CardDB.Instance.burlyrockjaw, pos, !own);
                }


            }
            else
            {
                int violetteacher = 0; //we count violetteacher to avoid copying ownminions
                int illidan = 0;
                int burly = 0;
                foreach (Minion m in this.enemyMinions)
                {
                    if (m.silenced) continue;
                    if (!own && m.name == CardDB.cardName.illidanstormrage)
                    {
                        illidan++;
                        continue;
                    }
                    if (!own && m.name == CardDB.cardName.violetteacher)
                    {
                        if (hc.card.type == CardDB.cardtype.SPELL)
                        {
                            violetteacher++;
                        }
                        continue;
                    }
                    if (!own && m.name == CardDB.cardName.hobgoblin)
                    {
                        if (hc.card.type == CardDB.cardtype.MOB && hc.card.Attack == 1)
                        {
                            hc.addattack += 2;
                            hc.addHp += 2;
                        }
                        continue;
                    }

                    m.handcard.card.sim_card.onCardIsGoingToBePlayed(this, hc.card, own, m);
                }
                foreach (Minion m in this.ownMinions)
                {
                    if (m.name == CardDB.cardName.troggzortheearthinator)
                    {
                        burly++;
                    }
                    if (m.name == CardDB.cardName.felreaver)
                    {
                        m.handcard.card.sim_card.onCardIsGoingToBePlayed(this, hc.card, own, m);
                    }
                }
                for (int i = 0; i < violetteacher; i++)
                {
                    int pos = this.enemyMinions.Count;
                    this.callKid(CardDB.Instance.teacherminion, pos, own);
                }
                for (int i = 0; i < illidan; i++)
                {
                    int pos = this.enemyMinions.Count;
                    this.callKid(CardDB.Instance.illidanminion, pos, own);
                }

                for (int i = 0; i < burly; i++)//summon for us
                {
                    int pos = this.ownMinions.Count;
                    this.callKid(CardDB.Instance.burlyrockjaw, pos, own);
                }
            }

        }

        public void triggerACardWasPlayed(CardDB.Card c, bool own)
        {
            //we do the effects manually :D (just 2 minions)
            foreach (Minion m in this.ownMinions)
            {
                if (m.silenced || m.Hp <= 0) continue;

                if (m.name == CardDB.cardName.secretkeeper && c.Secret)
                {
                    this.minionGetBuffed(m, 1, 1);
                }
                if (own && m.name == CardDB.cardName.wildpyromancer && c.type == CardDB.cardtype.SPELL)
                {
                    this.allMinionsGetDamage(1);
                }
            }

            foreach (Minion m in this.enemyMinions)
            {
                if (m.silenced || m.Hp <= 0) continue;

                if (m.name == CardDB.cardName.secretkeeper && c.Secret)
                {
                    this.minionGetBuffed(m, 1, 1);
                }
                if (!own && m.name == CardDB.cardName.wildpyromancer && c.type == CardDB.cardtype.SPELL)
                {
                    this.allMinionsGetDamage(1);
                }
            }


        }

        public void triggerAMinionIsSummoned(Minion m)
        {
            if (m.own)
            {
                foreach (Minion mnn in this.ownMinions)
                {
                    if (mnn.silenced) continue;
                    mnn.handcard.card.sim_card.onMinionIsSummoned(this, mnn, m);
                }

                foreach (Minion mnn in this.enemyMinions)
                {
                    if (mnn.silenced) continue;
                    if (mnn.name == CardDB.cardName.murloctidecaller) mnn.handcard.card.sim_card.onMinionIsSummoned(this, mnn, m);
                }

                if (this.ownWeaponName == CardDB.cardName.swordofjustice)
                {
                    this.minionGetBuffed(m, 1, 1);
                    this.lowerWeaponDurability(1, true);
                }
            }
            else
            {
                foreach (Minion mnn in this.enemyMinions)
                {
                    if (mnn.silenced) continue;
                    mnn.handcard.card.sim_card.onMinionIsSummoned(this, mnn, m);
                }

                foreach (Minion mnn in this.ownMinions)
                {
                    if (mnn.silenced) continue;
                    if (mnn.name == CardDB.cardName.murloctidecaller) mnn.handcard.card.sim_card.onMinionIsSummoned(this, mnn, m);
                }
                if (this.enemyWeaponName == CardDB.cardName.swordofjustice)
                {
                    this.minionGetBuffed(m, 1, 1);
                    this.lowerWeaponDurability(1, false);
                }
            }

        }

        public void triggerAMinionWasSummoned(Minion mnn)
        {
            if (mnn.own)
            {
                foreach (Minion m in this.ownMinions)
                {
                    if (m.silenced) continue;
                    if (m.name == CardDB.cardName.knifejuggler)
                    {
                        m.handcard.card.sim_card.onMinionWasSummoned(this, m, mnn);
                    }
                }
            }
            else
            {
                foreach (Minion m in this.enemyMinions)
                {
                    if (m.silenced) continue;
                    if (m.name == CardDB.cardName.knifejuggler)
                    {
                        m.handcard.card.sim_card.onMinionWasSummoned(this, m, mnn);
                    }
                }
            }

        }

        public void triggerEndTurn(bool ownturn)
        {
            //todo sort them
            //List<Minion> temp = (ownturn)? this.ownMinions : this.enemyMinions;

            List<Minion> ownm = (ownturn) ? this.ownMinions : this.enemyMinions;
            foreach (Minion m in ownm.ToArray())
            {
                if (!m.silenced)
                {
                    m.handcard.card.sim_card.onTurnEndsTrigger(this, m, ownturn);
                }
                if (ownturn && m.destroyOnOwnTurnEnd) this.minionGetDestroyed(m);
                if (!ownturn && m.destroyOnEnemyTurnEnd) this.minionGetDestroyed(m);
            }
            List<Minion> enemm = (ownturn) ? this.enemyMinions : this.ownMinions;
            foreach (Minion m in enemm.ToArray())
            {
                //only gruul + kelthuzad
                if (!m.silenced && (m.name == CardDB.cardName.gruul || m.name == CardDB.cardName.kelthuzad || m.name == CardDB.cardName.animagolem || m.name == CardDB.cardName.jeeves))
                {
                    m.handcard.card.sim_card.onTurnEndsTrigger(this, m, ownturn);
                }
            }

            this.doDmgTriggers();

            //shadowmadness
            foreach (Minion m in ownm.ToArray())
            {

                if (m.shadowmadnessed)
                {
                    m.shadowmadnessed = false;
                    this.minionGetControlled(m, !m.own, false);
                }

            }

            this.doDmgTriggers();

            this.playedmagierinderkirintor = false;



            foreach (Minion m in this.ownMinions)
            {
                this.minionGetTempBuff(m, -m.tempAttack, 0);
                m.immune = false;
                m.cantLowerHPbelowONE = false;
            }
            foreach (Minion m in this.enemyMinions)
            {
                this.minionGetTempBuff(m, -m.tempAttack, 0);
                m.immune = false;
                m.cantLowerHPbelowONE = false;
            }

        }

        public void triggerStartTurn(bool ownturn)
        {

            List<Minion> ownm = (ownturn) ? this.ownMinions : this.enemyMinions;
            foreach (Minion m in ownm)
            {
                m.playedThisTurn = false;
                m.numAttacksThisTurn = 0;
                m.updateReadyness();
                if (!m.silenced)
                {
                    m.handcard.card.sim_card.onTurnStartTrigger(this, m, ownturn);
                }
                if (ownturn && m.destroyOnOwnTurnStart) this.minionGetDestroyed(m);
                if (!ownturn && m.destroyOnEnemyTurnStart) this.minionGetDestroyed(m);
            }

            List<Minion> enemm = (ownturn) ? this.enemyMinions : this.ownMinions;
            foreach (Minion m in enemm)
            {
                if (!m.silenced)
                {
                    if (m.name == CardDB.cardName.micromachine) m.handcard.card.sim_card.onTurnStartTrigger(this, m, ownturn);
                }
                if (ownturn && m.destroyOnOwnTurnStart) this.minionGetDestroyed(m);
                if (!ownturn && m.destroyOnEnemyTurnStart) this.minionGetDestroyed(m);
            }

            this.doDmgTriggers();

            this.drawACard(CardDB.cardName.unknown, ownturn);
            this.doDmgTriggers();
        }

        public void triggerAHeroGotArmor(bool ownHero)
        {
            foreach (Minion m in ((ownHero) ? this.ownMinions : this.enemyMinions))
            {
                if (m.name == CardDB.cardName.siegeengine)
                {
                    this.minionGetBuffed(m, 1, 0);
                }
            }
        }

        public void triggerCardsChanged(bool own)
        {
            if (own)
            {
                if (this.tempanzOwnCards >= 6 && this.owncards.Count <= 5)
                {
                    //delete effect of enemy Goblin Sapper
                    foreach (Minion m in this.enemyMinions)
                    {
                        if (m.name == CardDB.cardName.goblinsapper && !m.silenced)
                        {
                            this.minionGetBuffed(m, -4, 0);
                        }
                    }
                }
                if (this.owncards.Count >= 6 && this.tempanzOwnCards <= 5)
                {
                    //add effect of enemy Goblin Sapper
                    foreach (Minion m in this.enemyMinions)
                    {
                        if (m.name == CardDB.cardName.goblinsapper && !m.silenced)
                        {
                            this.minionGetBuffed(m, 4, 0);
                        }
                    }
                }

                this.tempanzOwnCards = this.owncards.Count;
            }
            else
            {
                if (this.tempanzEnemyCards >= 6 && this.enemyAnzCards <= 5)
                {
                    //delete effect of own Goblin Sapper
                    foreach (Minion m in this.ownMinions)
                    {
                        if (m.name == CardDB.cardName.goblinsapper && !m.silenced)
                        {
                            this.minionGetBuffed(m, -4, 0);
                        }
                    }
                }
                if (this.enemyAnzCards >= 6 && this.tempanzEnemyCards <= 5)
                {
                    //add effect of own Goblin Sapper
                    foreach (Minion m in this.ownMinions)
                    {
                        if (m.name == CardDB.cardName.goblinsapper && !m.silenced)
                        {
                            this.minionGetBuffed(m, 4, 0);
                        }
                    }
                }

                this.tempanzEnemyCards = this.enemyAnzCards;
            }
        }



        public int secretTrigger_CharIsAttacked(Minion attacker, Minion defender)
        {
            int newTarget = 0;
            int triggered = 0;
            if (this.isOwnTurn && this.enemySecretCount >= 1)
            {

                if (defender.isHero && !defender.own)
                {
                    foreach (SecretItem si in this.enemySecretList.ToArray())
                    {
                        if (si.canBe_explosive)
                        {
                            triggered++;
                            CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_610).sim_card.onSecretPlay(this, false, 0);
                            doDmgTriggers();
                            //Helpfunctions.Instance.ErrorLog("trigger explosive" + attacker.Hp);
                            si.usedTrigger_CharIsAttacked(true, attacker.isHero);
                            foreach (SecretItem sii in this.enemySecretList)
                            {
                                sii.canBe_explosive = false;
                            }
                        }

                        if (!attacker.isHero && si.canBe_vaporize)
                        {
                            triggered++;
                            CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_594).sim_card.onSecretPlay(this, false, attacker, 0);
                            doDmgTriggers();

                            si.usedTrigger_CharIsAttacked(true, attacker.isHero);
                            foreach (SecretItem sii in this.enemySecretList)
                            {
                                sii.canBe_vaporize = false;
                            }
                        }

                        if (si.canBe_missdirection)
                        {
                            if (!(attacker.isHero && this.ownMinions.Count + this.enemyMinions.Count == 0))
                            {
                                triggered++;
                                CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_533).sim_card.onSecretPlay(this, false, attacker, defender, out newTarget);
                                si.usedTrigger_CharIsAttacked(true, attacker.isHero);
                                //Helpfunctions.Instance.ErrorLog("trigger miss " + attacker.Hp);
                                foreach (SecretItem sii in this.enemySecretList)
                                {
                                    sii.canBe_missdirection = false;
                                }
                            }
                        }

                        if (si.canBe_icebarrier)
                        {
                            triggered++;
                            CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_289).sim_card.onSecretPlay(this, false, defender, 0);
                            si.usedTrigger_CharIsAttacked(true, attacker.isHero);
                            foreach (SecretItem sii in this.enemySecretList)
                            {
                                sii.canBe_icebarrier = false;
                            }
                        }

                    }

                }

                if (!defender.isHero && !defender.own)
                {
                    foreach (SecretItem si in this.enemySecretList)
                    {

                        if (si.canBe_snaketrap)
                        {
                            triggered++;
                            CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_554).sim_card.onSecretPlay(this, false, 0);
                            si.usedTrigger_CharIsAttacked(false, attacker.isHero);
                            foreach (SecretItem sii in this.enemySecretList)
                            {
                                sii.canBe_snaketrap = false;
                            }
                        }
                    }
                }

                if (!attacker.isHero && attacker.own) // minion attacks
                {
                    foreach (SecretItem si in this.enemySecretList)
                    {
                        if (si.canBe_freezing)
                        {
                            triggered++;
                            CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_611).sim_card.onSecretPlay(this, false, attacker, 0);
                            si.usedTrigger_CharIsAttacked(defender.isHero, attacker.isHero);
                            //Helpfunctions.Instance.ErrorLog("trigger freeze " + attacker.Hp);
                            foreach (SecretItem sii in this.enemySecretList)
                            {
                                sii.canBe_freezing = false;
                            }
                        }
                    }
                }

                foreach (SecretItem si in this.enemySecretList)
                {

                    if (si.canBe_noblesacrifice)
                    {
                        //triggered++;
                        bool ishero = defender.isHero;
                        //CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_130).sim_card.onSecretPlay(this, false, attacker, defender, out newTarget);
                        si.usedTrigger_CharIsAttacked(ishero, attacker.isHero);
                        foreach (SecretItem sii in this.enemySecretList)
                        {
                            sii.canBe_noblesacrifice = false;
                        }
                    }
                }


            }

            if (turnCounter == 0)
            {
                this.evaluatePenality -= triggered * 50;
            }

            return newTarget;
        }

        public void secretTrigger_HeroGotDmg(bool own, int dmg)
        {
            int triggered = 0;
            if (own != this.isOwnTurn)
            {
                if (this.isOwnTurn && this.enemySecretCount >= 1)
                {
                    foreach (SecretItem si in this.enemySecretList)
                    {
                        if (si.canBe_eyeforaneye)
                        {
                            triggered++;
                            CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_132).sim_card.onSecretPlay(this, false, dmg);
                            si.usedTrigger_HeroGotDmg();
                            foreach (SecretItem sii in this.enemySecretList)
                            {
                                sii.canBe_eyeforaneye = false;
                            }
                        }

                        if (si.canBe_iceblock && this.enemyHero.Hp <= 0)
                        {
                            triggered++;
                            CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_295).sim_card.onSecretPlay(this, false, this.enemyHero, dmg);
                            si.usedTrigger_HeroGotDmg(true);
                            foreach (SecretItem sii in this.enemySecretList)
                            {
                                sii.canBe_iceblock = false;
                            }

                        }
                    }
                }
            }

            if (turnCounter == 0)
            {
                this.evaluatePenality -= triggered * 50;
            }

        }

        public void secretTrigger_MinionIsPlayed(Minion playedMinion)
        {
            int triggered = 0;
            if (this.isOwnTurn && playedMinion.own && this.enemySecretCount >= 1)
            {
                foreach (SecretItem si in this.enemySecretList.ToArray())
                {
                    if (si.canBe_snipe)
                    {
                        triggered++;
                        CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_609).sim_card.onSecretPlay(this, false, playedMinion, 0);
                        doDmgTriggers();
                        si.usedTrigger_MinionIsPlayed();
                        foreach (SecretItem sii in this.enemySecretList)
                        {
                            sii.canBe_snipe = false;
                        }
                    }

                    if (si.canBe_mirrorentity)
                    {
                        triggered++;
                        CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_294).sim_card.onSecretPlay(this, false, playedMinion, 0);
                        si.usedTrigger_MinionIsPlayed();
                        foreach (SecretItem sii in this.enemySecretList)
                        {
                            sii.canBe_mirrorentity = false;
                        }

                    }

                    if (si.canBe_repentance)
                    {
                        //triggered++;
                        //CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_379).sim_card.onSecretPlay(this, false, playedMinion, 0);
                        si.usedTrigger_MinionIsPlayed();
                        foreach (SecretItem sii in this.enemySecretList)
                        {
                            sii.canBe_repentance = false;
                        }
                    }
                }
            }

            if (turnCounter == 0)
            {
                this.evaluatePenality -= triggered * 50;
            }

        }

        public int secretTrigger_SpellIsPlayed(Minion target, bool isSpell)
        {
            int triggered = 0;
            if (this.isOwnTurn && isSpell && this.enemySecretCount >= 1) //actual secrets need a spell played!
            {
                foreach (SecretItem si in this.enemySecretList)
                {

                    if (si.canBe_counterspell)
                    {
                        triggered++;
                        // dont use spell!
                        si.usedTrigger_SpellIsPlayed(false);
                        foreach (SecretItem sii in this.enemySecretList)
                        {
                            sii.canBe_counterspell = false;
                        }

                        if (turnCounter == 0)
                        {
                            this.evaluatePenality -= triggered * 50;
                        }
                        return -2;//spellbender will NEVER trigger
                    }
                }



                foreach (SecretItem si in this.enemySecretList)
                {

                    if (si.canBe_spellbender && target != null && !target.isHero)
                    {
                        triggered++;
                        int retval = 0;
                        CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.tt_010).sim_card.onSecretPlay(this, false, null, target, out retval);
                        si.usedTrigger_SpellIsPlayed(true);
                        foreach (SecretItem sii in this.enemySecretList)
                        {
                            sii.canBe_spellbender = false;
                        }

                        if (turnCounter == 0)
                        {
                            this.evaluatePenality -= triggered * 50;
                        }
                        return retval;// the new target
                    }




                }

            }

            if (turnCounter == 0)
            {
                this.evaluatePenality -= triggered * 50;
            }

            return 0;

        }

        public void secretTrigger_MinionDied(bool own)
        {
            int triggered = 0;

            if (this.isOwnTurn && !own && this.enemySecretCount >= 1)
            {

                foreach (SecretItem si in this.enemySecretList)
                {
                    if (si.canBe_duplicate)
                    {
                        triggered++;
                        CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.FP1_018).sim_card.onSecretPlay(this, false, 0);
                        si.usedTrigger_MinionDied();
                        foreach (SecretItem sii in this.enemySecretList)
                        {
                            sii.canBe_duplicate = false;
                        }
                    }

                    if (si.canBe_redemption)
                    {
                        //triggered++;
                        //CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_136).sim_card.onSecretPlay(this, false, 0);
                        si.usedTrigger_MinionDied();
                        foreach (SecretItem sii in this.enemySecretList)
                        {
                            sii.canBe_redemption = false;
                        }
                    }

                    if (si.canBe_avenge)
                    {
                        //triggered++;
                        //CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.FP1_020).sim_card.onSecretPlay(this, false, 0);
                        si.usedTrigger_MinionDied();
                        foreach (SecretItem sii in this.enemySecretList)
                        {
                            sii.canBe_avenge = false;
                        }
                    }


                }
            }

            if (turnCounter == 0)
            {
                this.evaluatePenality -= triggered * 50;
            }

        }



        public void doDeathrattles(List<Minion> deathrattles)
        {
            //todo sort them from oldest to newest (first played, first deathrattle)
            //https://www.youtube.com/watch?v=2WrbqsOSbhc
            foreach (Minion m in deathrattles)
            {
                if (!m.silenced && m.handcard.card.deathrattle) m.handcard.card.sim_card.onDeathrattle(this, m);

                for (int i = 0; i < m.souloftheforest; i++)
                {
                    CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_158t);//Treant
                    int pos = (m.own) ? this.ownMinions.Count : this.enemyMinions.Count;
                    callKid(kid, pos, m.own);
                }

                for (int i = 0; i < m.ancestralspirit; i++)
                {
                    CardDB.Card kid = m.handcard.card;
                    int pos = (m.own) ? this.ownMinions.Count : this.enemyMinions.Count;
                    callKid(kid, pos, m.own);
                }

                //baron rivendare ??
                if ((m.own && this.ownBaronRivendare >= 1) || (!m.own && this.enemyBaronRivendare >= 1))
                {
                    if (!m.silenced && m.handcard.card.deathrattle) m.handcard.card.sim_card.onDeathrattle(this, m);

                    for (int i = 0; i < m.souloftheforest; i++)
                    {
                        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_158t);//Treant
                        int pos = (m.own) ? this.ownMinions.Count : this.enemyMinions.Count;
                        callKid(kid, pos, m.own);
                    }

                    for (int i = 0; i < m.ancestralspirit; i++)
                    {
                        CardDB.Card kid = m.handcard.card;
                        int pos = (m.own) ? this.ownMinions.Count : this.enemyMinions.Count;
                        callKid(kid, pos, m.own);
                    }

                }
            }


        }


        public void updateBoards()
        {
            if (!this.tempTrigger.ownMinionsChanged && !this.tempTrigger.enemyMininsChanged) return;
            List<Minion> deathrattles = new List<Minion>();

            bool minionOwnReviving = false;
            bool minionEnemyReviving = false;

            if (this.tempTrigger.ownMinionsChanged)
            {
                this.tempTrigger.ownMinionsChanged = false;
                List<Minion> temp = new List<Minion>();
                int i = 1;
                foreach (Minion m in this.ownMinions)
                {
                    //delete adjacent buffs
                    this.minionGetAdjacentBuff(m, -m.AdjacentAngr, 0);
                    m.cantBeTargetedBySpellsOrHeroPowers = false;
                    if ((m.name == CardDB.cardName.faeriedragon || m.name == CardDB.cardName.spectralknight || m.name == CardDB.cardName.laughingsister || m.name == CardDB.cardName.arcanenullifierx21) && !m.silenced)
                    {
                        m.cantBeTargetedBySpellsOrHeroPowers = true;
                    }

                    //kill it!
                    if (m.Hp <= 0)
                    {
                        if (this.revivingOwnMinion == CardDB.cardIDEnum.None)
                        {
                            this.revivingOwnMinion = m.handcard.card.cardIDenum;
                            minionOwnReviving = true;
                        }

                        if ((!m.silenced && m.handcard.card.deathrattle) || m.ancestralspirit >= 1 || m.souloftheforest >= 1)
                        {
                            deathrattles.Add(m);
                        }
                        // end aura of minion m
                        m.handcard.card.sim_card.onAuraEnds(this, m);

                        /*if (m.handcard.card.name == CardDB.cardName.cairnebloodhoof || m.handcard.card.name == CardDB.cardName.harvestgolem || m.ancestralspirit>=1)
                        {
                            this.evaluatePenality -= Ai.Instance.botBase.getEnemyMinionValue(m, this) - 1;
                        }*/

                    }
                    else
                    {
                        m.zonepos = i;
                        temp.Add(m);
                        i++;
                    }

                }
                this.ownMinions = temp;
                this.updateAdjacentBuffs(true);
            }

            if (this.tempTrigger.enemyMininsChanged)
            {
                this.tempTrigger.enemyMininsChanged = false;
                List<Minion> temp = new List<Minion>();
                int i = 1;
                foreach (Minion m in this.enemyMinions)
                {
                    //delete adjacent buffs
                    this.minionGetAdjacentBuff(m, -m.AdjacentAngr, 0);
                    m.cantBeTargetedBySpellsOrHeroPowers = false;
                    if ((m.name == CardDB.cardName.faeriedragon || m.name == CardDB.cardName.spectralknight || m.name == CardDB.cardName.laughingsister || m.name == CardDB.cardName.arcanenullifierx21) && !m.silenced)
                    {
                        m.cantBeTargetedBySpellsOrHeroPowers = true;
                    }

                    //kill it!
                    if (m.Hp <= 0)
                    {
                        if (this.revivingEnemyMinion == CardDB.cardIDEnum.None)
                        {
                            this.revivingEnemyMinion = m.handcard.card.cardIDenum;
                            minionEnemyReviving = true;
                        }

                        if ((!m.silenced && m.handcard.card.deathrattle) || m.ancestralspirit >= 1 || m.souloftheforest >= 1)
                        {
                            deathrattles.Add(m);
                        }
                        m.handcard.card.sim_card.onAuraEnds(this, m);

                        if ((!m.silenced && (m.handcard.card.name == CardDB.cardName.cairnebloodhoof || m.handcard.card.name == CardDB.cardName.harvestgolem)) || m.ancestralspirit >= 1)
                        {
                            this.evaluatePenality -= Ai.Instance.botBase.getEnemyMinionValue(m, this) - 1;
                        }
                    }
                    else
                    {
                        m.zonepos = i;
                        temp.Add(m);
                        i++;
                    }

                }
                this.enemyMinions = temp;
                this.updateAdjacentBuffs(false);
            }


            if (deathrattles.Count >= 1) this.doDeathrattles(deathrattles);

            if (minionOwnReviving)
            {
                this.secretTrigger_MinionDied(true);
                this.revivingOwnMinion = CardDB.cardIDEnum.None;
            }

            if (minionEnemyReviving)
            {
                this.secretTrigger_MinionDied(false);
                this.revivingEnemyMinion = CardDB.cardIDEnum.None;
            }
            //update buffs
        }

        public void minionGetOrEraseAllAreaBuffs(Minion m, bool get)
        {
            if (m.isHero) return;
            int angr = 0;
            int vert = 0;

            if (m.handcard.card.race == 14)
            {
                angr += 2 * anzMurlocWarleader + anzGrimscaleOracle;
                vert += anzMurlocWarleader;

            }

            if (!m.silenced) // if they are not silenced, these minions will give a buff, but cant buff themselfes
            {
                if (m.name == CardDB.cardName.raidleader || m.name == CardDB.cardName.leokk || m.name == CardDB.cardName.timberwolf) angr--;
                if (m.name == CardDB.cardName.stormwindchampion || m.name == CardDB.cardName.southseacaptain)
                {
                    angr--;
                    vert--;
                }
                if (m.name == CardDB.cardName.murlocwarleader)
                {
                    angr -= 2;
                    vert--;
                }
                if (m.name == CardDB.cardName.grimscaleoracle)
                {
                    angr--;
                }
            }


            if (m.own)
            {
                // todo charge:  m.charge -= anzOwnTundrarhino;
                if (get) m.charge += anzOwnTundrarhino;
                else m.charge -= anzOwnTundrarhino;
                angr += anzOwnRaidleader;
                angr += anzOwnStormwindChamps;
                vert += anzOwnStormwindChamps;
                if (m.handcard.card.race == 20)
                {
                    angr += anzOwnTimberWolfs;
                }
                if (m.handcard.card.race == 23)
                {
                    angr += anzOwnSouthseacaptain;
                    vert += anzOwnSouthseacaptain;

                }
                if (m.handcard.card.race == 15)
                {
                    angr += anzOwnMalGanis * 2;
                    vert += anzOwnMalGanis * 2;

                }

            }
            else
            {
                if (get) m.charge += anzEnemyTundrarhino;
                else m.charge -= anzEnemyTundrarhino;
                angr += anzEnemyRaidleader;
                angr += anzEnemyStormwindChamps;
                vert += anzEnemyStormwindChamps;

                if (m.handcard.card.race == 20)
                {
                    angr += anzEnemyTimberWolfs;
                }
                if (m.handcard.card.race == 23)
                {
                    angr += anzEnemySouthseacaptain;
                    vert += anzEnemySouthseacaptain;
                }
                if (m.handcard.card.race == 15)
                {
                    angr += anzEnemyMalGanis * 2;
                    vert += anzEnemyMalGanis * 2;

                }
            }

            if (get) this.minionGetBuffed(m, angr, vert);
            else this.minionGetBuffed(m, -angr, -vert);

        }

        public void updateAdjacentBuffs(bool own)
        {
            //only call this after update board
            if (own)
            {
                int anz = this.ownMinions.Count;
                for (int i = 0; i < anz; i++)
                {
                    Minion m = this.ownMinions[i];
                    if (!m.silenced)
                    {
                        if (m.name == CardDB.cardName.direwolfalpha)
                        {
                            if (i > 0) this.minionGetAdjacentBuff(this.ownMinions[i - 1], 1, 0);
                            if (i < anz - 1) this.minionGetAdjacentBuff(this.ownMinions[i + 1], 1, 0);
                        }

                        if (m.name == CardDB.cardName.flametonguetotem)
                        {
                            if (i > 0) this.minionGetAdjacentBuff(this.ownMinions[i - 1], 2, 0);
                            if (i < anz - 1) this.minionGetAdjacentBuff(this.ownMinions[i + 1], 2, 0);
                        }

                        if (m.name == CardDB.cardName.weespellstopper)
                        {
                            if (i > 0) this.ownMinions[i - 1].cantBeTargetedBySpellsOrHeroPowers = true;
                            if (i < anz - 1) this.ownMinions[i + 1].cantBeTargetedBySpellsOrHeroPowers = true;
                        }
                    }
                }
            }
            else
            {
                int anz = this.enemyMinions.Count;
                for (int i = 0; i < anz; i++)
                {
                    Minion m = this.enemyMinions[i];
                    if (!m.silenced)
                    {
                        if (m.name == CardDB.cardName.direwolfalpha)
                        {
                            if (i > 0) this.minionGetAdjacentBuff(this.enemyMinions[i - 1], 1, 0);
                            if (i < anz - 1) this.minionGetAdjacentBuff(this.enemyMinions[i + 1], 1, 0);
                        }

                        if (m.name == CardDB.cardName.flametonguetotem)
                        {
                            if (i > 0) this.minionGetAdjacentBuff(this.enemyMinions[i - 1], 2, 0);
                            if (i < anz - 1) this.minionGetAdjacentBuff(this.enemyMinions[i + 1], 2, 0);
                        }

                        if (m.name == CardDB.cardName.weespellstopper)
                        {
                            if (i > 0) this.enemyMinions[i - 1].cantBeTargetedBySpellsOrHeroPowers = true;
                            if (i < anz - 1) this.enemyMinions[i + 1].cantBeTargetedBySpellsOrHeroPowers = true;
                        }
                    }
                }
            }
        }

        public Minion createNewMinion(Handmanager.Handcard hc, int zonepos, bool own)
        {
            Minion m = new Minion();
            Handmanager.Handcard handc = new Handmanager.Handcard(hc);
            //Handmanager.Handcard handc = hc; // new Handcard(hc)?
            m.handcard = handc;
            m.own = own;
            m.isHero = false;
            m.entitiyID = hc.entity;
            m.Angr = hc.card.Attack + hc.addattack;
            m.Hp = hc.card.Health + hc.addHp;

            hc.addattack = 0;
            hc.addHp = 0;

            m.maxHp = hc.card.Health;
            m.name = hc.card.name;
            m.playedThisTurn = true;
            m.numAttacksThisTurn = 0;
            m.zonepos = zonepos;
            m.windfury = hc.card.windfury;
            m.taunt = hc.card.tank;
            m.charge = (hc.card.Charge) ? 1 : 0;
            m.divineshild = hc.card.Shield;
            m.poisonous = hc.card.poisionous;
            m.stealth = hc.card.Stealth;

            m.updateReadyness();

            if (m.name == CardDB.cardName.lightspawn)
            {
                m.Angr = m.Hp;
            }


            //trigger on summon effect!
            this.triggerAMinionIsSummoned(m);
            //activate onAura effect
            m.handcard.card.sim_card.onAuraStarts(this, m);
            //buffs minion
            this.minionGetOrEraseAllAreaBuffs(m, true);
            return m;
        }

        public void placeAmobSomewhere(Handmanager.Handcard hc, Minion target, int choice, int zonepos)
        {
            int mobplace = zonepos;

            //create the new minion + trigger Summon effects + buffs it
            Minion m = createNewMinion(hc, mobplace, true);


            //trigger the battlecry!
            m.handcard.card.sim_card.getBattlecryEffect(this, m, target, choice);

            //add minion to list + do triggers + do secret trigger +  minion was played trigger
            addMinionToBattlefield(m);

            secretTrigger_MinionIsPlayed(m);


            if (logging) Helpfunctions.Instance.logg("added " + m.handcard.card.name);
        }

        public void addMinionToBattlefield(Minion m, bool isSummon = true)
        {
            List<Minion> temp = (m.own) ? this.ownMinions : this.enemyMinions;
            if (temp.Count >= m.zonepos && m.zonepos >= 1)
            {
                temp.Insert(m.zonepos - 1, m);
            }
            else
            {
                temp.Add(m);
            }
            if (m.own) this.tempTrigger.ownMinionsChanged = true;
            else this.tempTrigger.enemyMininsChanged = true;
            doDmgTriggers();


            //minion was played secrets? trigger here---- (+ do triggers)


            //trigger a minion was summoned
            triggerAMinionWasSummoned(m);
            doDmgTriggers();

        }

        public void equipWeapon(CardDB.Card c, bool own)
        {
            Minion hero = (own) ? this.ownHero : this.enemyHero;
            if (own)
            {
                if (this.ownWeaponDurability >= 1)
                {
                    this.lostWeaponDamage += this.ownWeaponDurability * this.ownWeaponAttack * this.ownWeaponAttack;
                    this.lowerWeaponDurability(1000, true);
                    hero.Angr -= this.ownWeaponAttack;
                }
                this.ownWeaponAttack = c.Attack;
                this.ownWeaponDurability = c.Durability;
                this.ownWeaponName = c.name;
            }
            else
            {
                if (this.enemyWeaponDurability >= 1)
                {
                    hero.Angr -= this.enemyWeaponAttack;
                }
                this.enemyWeaponAttack = c.Attack;
                this.enemyWeaponDurability = c.Durability;
                this.enemyWeaponName = c.name;
            }



            hero.Angr += c.Attack;

            hero.windfury = (c.name == CardDB.cardName.doomhammer);

            hero.updateReadyness();

            hero.immuneWhileAttacking = (c.name == CardDB.cardName.gladiatorslongbow);

            List<Minion> temp = (own) ? this.ownMinions : this.enemyMinions;
            foreach (Minion m in temp)
            {
                if (m.playedThisTurn && m.name == CardDB.cardName.southseadeckhand)
                {
                    minionGetCharge(m);
                }
            }

        }


        //todo 4th param
        public void callKid(CardDB.Card c, int zonepos, bool own, bool spawnKid = false, bool oneMoreIsAllowed = false)
        {
            //spawnKid = true if its a minion spawned with another one (battlecry)
            int allowed = 7;
            allowed += (oneMoreIsAllowed) ? 1 : 0;
            allowed -= (spawnKid) ? 1 : 0;

            if (own)
            {
                if (this.ownMinions.Count >= allowed)
                {
                    if (spawnKid) this.evaluatePenality += 20;
                    return;
                }
            }
            else
            {
                if (this.enemyMinions.Count >= allowed)
                {
                    if (spawnKid) this.evaluatePenality -= 20;
                    return;
                }
            }
            int mobplace = zonepos + 1;//todo check this?

            //create minion (+triggers)
            Handmanager.Handcard hc = new Handmanager.Handcard(c) { entity = this.getNextEntity() };
            Minion m = createNewMinion(hc, mobplace, own);
            //put it on battle field (+triggers)
            addMinionToBattlefield(m);

        }



        public void minionGetSilenced(Minion m)
        {
            //minion cant die due to silencing!
            m.becomeSilence(this);

        }

        public void allMinionsGetSilenced(bool own)
        {
            List<Minion> temp = (own) ? this.ownMinions : this.enemyMinions;
            foreach (Minion m in temp)
            {
                m.becomeSilence(this);
            }
        }

        public void drawACard(CardDB.cardName ss, bool own, bool nopen = false)
        {
            CardDB.cardName s = ss;

            // cant hold more than 10 cards
            if (own)
            {

                if (s == CardDB.cardName.unknown && !nopen) // draw a card from deck :D
                {
                    if (ownDeckSize == 0)
                    {
                        this.ownHeroFatigue++;
                        this.ownHero.getDamageOrHeal(this.ownHeroFatigue, this, false, true);
                    }
                    else
                    {
                        this.ownDeckSize--;
                        if (this.owncards.Count >= 10)
                        {
                            this.evaluatePenality += 15;
                            return;
                        }
                        this.owncarddraw++;
                    }

                }
                else
                {
                    if (this.owncards.Count >= 10)
                    {
                        this.evaluatePenality += 5;
                        return;
                    }
                    this.owncarddraw++;

                }


            }
            else
            {
                int oldenemyanz = this.enemyAnzCards;
                if (s == CardDB.cardName.unknown && !nopen) // draw a card from deck :D
                {
                    if (enemyDeckSize == 0)
                    {
                        this.enemyHeroFatigue++;
                        this.enemyHero.getDamageOrHeal(this.enemyHeroFatigue, this, false, true);
                    }
                    else
                    {
                        this.enemyDeckSize--;
                        if (this.enemyAnzCards >= 10)
                        {
                            this.evaluatePenality -= 50;
                            return;
                        }
                        this.enemycarddraw++;
                        this.enemyAnzCards++;
                    }

                }
                else
                {
                    if (this.enemyAnzCards >= 10)
                    {
                        this.evaluatePenality -= 50;
                        return;
                    }
                    this.enemycarddraw++;
                    this.enemyAnzCards++;

                }
                if (this.enemyAnzCards != oldenemyanz) this.triggerCardsChanged(false);
                return;
            }

            if (s == CardDB.cardName.unknown)
            {
                CardDB.Card plchldr = new CardDB.Card { name = CardDB.cardName.unknown };
                Handmanager.Handcard hc = new Handmanager.Handcard { card = plchldr, position = this.owncards.Count + 1, manacost = 1000, entity = this.getNextEntity() };
                this.owncards.Add(hc);
                this.triggerCardsChanged(true);
            }
            else
            {
                CardDB.Card c = CardDB.Instance.getCardData(s);
                Handmanager.Handcard hc = new Handmanager.Handcard { card = c, position = this.owncards.Count + 1, manacost = c.calculateManaCost(this), entity = this.getNextEntity() };
                this.owncards.Add(hc);
                this.triggerCardsChanged(true);
            }

        }

        public void drawACard(CardDB.cardIDEnum ss, bool own, bool nopen = false)
        {
            CardDB.cardIDEnum s = ss;

            // cant hold more than 10 cards

            if (own)
            {
                if (s == CardDB.cardIDEnum.None && !nopen) // draw a card from deck :D
                {
                    if (ownDeckSize == 0)
                    {
                        this.ownHeroFatigue++;
                        this.ownHero.getDamageOrHeal(this.ownHeroFatigue, this, false, true);
                    }
                    else
                    {
                        this.ownDeckSize--;
                        if (this.owncards.Count >= 10)
                        {
                            this.evaluatePenality += 15;
                            return;
                        }
                        this.owncarddraw++;
                    }

                }
                else
                {
                    if (this.owncards.Count >= 10)
                    {
                        this.evaluatePenality += 5;
                        return;
                    }
                    this.owncarddraw++;

                }


            }
            else
            {
                int oldenemyanz = this.enemyAnzCards;
                if (s == CardDB.cardIDEnum.None && !nopen) // draw a card from deck :D
                {
                    if (enemyDeckSize == 0)
                    {
                        this.enemyHeroFatigue++;
                        this.enemyHero.getDamageOrHeal(this.enemyHeroFatigue, this, false, true);
                    }
                    else
                    {
                        this.enemyDeckSize--;
                        if (this.enemyAnzCards >= 10)
                        {
                            this.evaluatePenality -= 50;
                            return;
                        }
                        this.enemycarddraw++;
                        this.enemyAnzCards++;
                    }

                }
                else
                {
                    if (this.enemyAnzCards >= 10)
                    {
                        this.evaluatePenality -= 50;
                        return;
                    }
                    this.enemycarddraw++;
                    this.enemyAnzCards++;

                }
                if (this.enemyAnzCards != oldenemyanz) this.triggerCardsChanged(false);
                return;
            }

            if (s == CardDB.cardIDEnum.None)
            {
                CardDB.Card plchldr = new CardDB.Card { name = CardDB.cardName.unknown };
                Handmanager.Handcard hc = new Handmanager.Handcard { card = plchldr, position = this.owncards.Count + 1, manacost = 1000, entity = this.getNextEntity() };
                this.owncards.Add(hc);
                this.triggerCardsChanged(true);
            }
            else
            {
                CardDB.Card c = CardDB.Instance.getCardDataFromID(s);
                Handmanager.Handcard hc = new Handmanager.Handcard { card = c, position = this.owncards.Count + 1, manacost = c.calculateManaCost(this), entity = this.getNextEntity() };
                this.owncards.Add(hc);
                this.triggerCardsChanged(true);
            }

        }


        public void removeCard(Handmanager.Handcard hcc)
        {
            //todo test this and remove toarray()
            //this.owncards.RemoveAll(x => x.entity == hcc.entity);
            int i = 1;
            foreach (Handmanager.Handcard hc in this.owncards.ToArray())
            {
                if (hc.entity == hcc.entity)
                {
                    this.owncards.Remove(hc);
                    continue;
                }
                this.owncards[i - 1].position = i;
                //hc.position = i;
                i++;
            }

        }


        // some helpfunctions 


        public void attackEnemyHeroWithoutKill(int dmg)
        {
            this.enemyHero.cantLowerHPbelowONE = true;
            this.minionGetDamageOrHeal(this.enemyHero, dmg);
            this.enemyHero.cantLowerHPbelowONE = false;
        }

        public void minionGetDestroyed(Minion m)
        {
            if (m.Hp > 0)
            {
                m.Hp = 0;
                m.minionDied(this);
            }

        }

        public void allMinionsGetDestroyed()
        {
            foreach (Minion m in this.ownMinions)
            {
                minionGetDestroyed(m);
            }
            foreach (Minion m in this.enemyMinions)
            {
                minionGetDestroyed(m);
            }
        }


        public void minionGetArmor(Minion m, int armor)
        {
            m.armor += armor;
            this.triggerAHeroGotArmor(m.own);
        }

        public void minionReturnToHand(Minion m, bool own, int manachange)
        {
            List<Minion> temp = (own) ? this.ownMinions : this.enemyMinions;
            m.handcard.card.sim_card.onAuraEnds(this, m);
            temp.Remove(m);

            if (own)
            {
                CardDB.Card c = m.handcard.card;
                Handmanager.Handcard hc = new Handmanager.Handcard { card = c, position = this.owncards.Count + 1, entity = m.entitiyID, manacost = c.calculateManaCost(this) + manachange };
                if (this.owncards.Count < 10)
                {
                    this.owncards.Add(hc);
                    this.triggerCardsChanged(true);
                }
                else
                {
                    this.drawACard(CardDB.cardName.unknown, true);
                }
                this.tempTrigger.ownMinionsChanged = true;
            }
            else
            {
                this.drawACard(CardDB.cardName.unknown, true);
                this.tempTrigger.enemyMininsChanged = true;
            }

        }

        public void minionTransform(Minion m, CardDB.Card c)
        {
            m.handcard.card.sim_card.onAuraEnds(this, m);//end aura of the minion

            Handmanager.Handcard hc = new Handmanager.Handcard(c) { entity = m.entitiyID };
            int ancestral = m.ancestralspirit;
            if (m.handcard.card.name == CardDB.cardName.cairnebloodhoof || m.handcard.card.name == CardDB.cardName.harvestgolem || ancestral >= 1)
            {
                this.evaluatePenality -= Ai.Instance.botBase.getEnemyMinionValue(m, this) - 1;
            }

            //necessary???
            /*Minion tranform = createNewMinion(hc, m.zonepos, m.own);
            Minion temp = new Minion();
            temp.setMinionTominion(m);
            m.setMinionTominion(tranform);*/

            m.setMinionTominion(createNewMinion(hc, m.zonepos, m.own));

            m.handcard.card.sim_card.onAuraStarts(this, m);
            this.minionGetOrEraseAllAreaBuffs(m, true);

            if (m.own)
            {
                this.tempTrigger.ownMinionsChanged = true;
            }
            else
            {
                this.tempTrigger.enemyMininsChanged = true;
            }

            if (logging) Helpfunctions.Instance.logg("minion got sheep" + m.name + " " + m.Angr);
        }

        public void minionGetControlled(Minion m, bool newOwner, bool canAttack)
        {
            List<Minion> newOwnerList = (newOwner) ? this.ownMinions : this.enemyMinions;
            List<Minion> oldOwnerList = (newOwner) ? this.enemyMinions : this.ownMinions;



            if (newOwnerList.Count >= 7) return;

            this.tempTrigger.ownMinionsChanged = true;
            this.tempTrigger.enemyMininsChanged = true;

            //end buffs/aura
            m.handcard.card.sim_card.onAuraEnds(this, m);
            this.minionGetOrEraseAllAreaBuffs(m, false);

            //remove minion from list
            oldOwnerList.Remove(m);

            //change site (and minion is played in this turn)
            m.playedThisTurn = true;
            m.own = !m.own;

            // add minion to new list + new buffs
            newOwnerList.Add(m);
            m.handcard.card.sim_card.onAuraStarts(this, m);
            this.minionGetOrEraseAllAreaBuffs(m, true);

            if (m.charge >= 1 || canAttack) // minion can attack if its shadowmadnessed (canAttack = true) or it has charge
            {
                this.minionGetCharge(m);
            }
            m.updateReadyness();

        }



        public void minionGetWindfurry(Minion m)
        {
            if (m.windfury) return;
            m.windfury = true;
            m.updateReadyness();
        }

        public void minionGetCharge(Minion m)
        {
            m.charge++;
            m.updateReadyness();
        }

        public void minionLostCharge(Minion m)
        {
            m.charge--;
            m.updateReadyness();
        }



        public void minionGetTempBuff(Minion m, int tempAttack, int tempHp)
        {
            if (!m.silenced && m.name == CardDB.cardName.lightspawn) return;
            if (tempAttack < 0 && -tempAttack > m.Angr)
            {
                tempAttack = -m.Angr;
            }
            m.tempAttack += tempAttack;
            m.Angr += tempAttack;
        }

        public void minionGetAdjacentBuff(Minion m, int angr, int vert)
        {
            if (!m.silenced && m.name == CardDB.cardName.lightspawn) return;
            m.Angr += angr;
            m.AdjacentAngr += angr;
        }

        public void minionGetBuffed(Minion m, int attackbuff, int hpbuff)
        {
            m.Angr = Math.Max(0, m.Angr + attackbuff);

            if (hpbuff >= 1)
            {
                m.Hp = m.Hp + hpbuff;
                m.maxHp = m.maxHp + hpbuff;
            }
            else
            {
                //debuffing hp, lower only maxhp (unless maxhp < hp)
                m.maxHp = m.maxHp + hpbuff;
                if (m.maxHp < m.Hp)
                {
                    m.Hp = m.maxHp;
                }
            }


            m.wounded = (m.maxHp != m.Hp);

            if (m.name == CardDB.cardName.lightspawn && !m.silenced)
            {
                m.Angr = m.Hp;
            }

        }

        public void minionSetAngrToOne(Minion m)
        {
            if (!m.silenced && m.name == CardDB.cardName.lightspawn) return;
            m.Angr = 1;
            m.tempAttack = 0;
            this.minionGetOrEraseAllAreaBuffs(m, true);
        }

        public void minionSetLifetoOne(Minion m)
        {
            minionGetOrEraseAllAreaBuffs(m, false);
            m.Hp = 1;
            m.maxHp = 1;
            if (m.wounded && !m.silenced) m.handcard.card.sim_card.onEnrageStop(this, m);
            m.wounded = false;
            minionGetOrEraseAllAreaBuffs(m, true);
        }

        public void minionSetAngrToHP(Minion m)
        {
            m.Angr = m.Hp;
            m.tempAttack = 0;
            this.minionGetOrEraseAllAreaBuffs(m, true);

        }

        public void minionSwapAngrAndHP(Minion m)
        {
            this.minionGetOrEraseAllAreaBuffs(m, false);
            bool woundedbef = m.wounded;
            int temp = m.Angr;
            m.Angr = m.Hp;
            m.Hp = temp;
            m.maxHp = temp;
            m.wounded = false;
            if (woundedbef) m.handcard.card.sim_card.onEnrageStop(this, m);
            if (m.Hp <= 0)
            {
                if (m.own) this.tempTrigger.ownMinionsDied++;
                else this.tempTrigger.enemyMinionsDied++;
            }

            this.minionGetOrEraseAllAreaBuffs(m, true);
        }

        public void minionGetDamageOrHeal(Minion m, int dmgOrHeal, bool dontDmgLoss = false)
        {
            m.getDamageOrHeal(dmgOrHeal, this, false, dontDmgLoss);
        }



        public void allMinionOfASideGetDamage(bool own, int damages, bool frozen = false)
        {
            List<Minion> temp = (own) ? this.ownMinions : this.enemyMinions;
            foreach (Minion m in temp)
            {
                if (frozen) m.frozen = true;
                minionGetDamageOrHeal(m, damages, true);
            }
        }

        public void allCharsOfASideGetDamage(bool own, int damages)
        {
            //ALL CHARS get same dmg
            List<Minion> temp = (own) ? this.ownMinions : this.enemyMinions;
            foreach (Minion m in temp)
            {
                minionGetDamageOrHeal(m, damages, true);
            }

            this.minionGetDamageOrHeal(own ? this.ownHero : this.enemyHero, damages);
        }

        public void allCharsGetDamage(int damages)
        {
            foreach (Minion m in this.ownMinions)
            {
                minionGetDamageOrHeal(m, damages, true);
            }
            foreach (Minion m in this.enemyMinions)
            {
                minionGetDamageOrHeal(m, damages, true);
            }
            minionGetDamageOrHeal(this.ownHero, damages);
            minionGetDamageOrHeal(this.enemyHero, damages);
        }

        public void allMinionsGetDamage(int damages)
        {
            foreach (Minion m in this.ownMinions)
            {
                minionGetDamageOrHeal(m, damages, true);
            }
            foreach (Minion m in this.enemyMinions)
            {
                minionGetDamageOrHeal(m, damages, true);
            }
        }

        public enum searchmode
        {
            searchLowestHP,
            searchHighestHP,
            searchLowestAttack,
            searchHighestAttack,
        }

        public Minion searchRandomMinion(List<Minion> minions, searchmode mode)
        {
            //get = 0 -> get lowest hp
            //get = 1 -> get highest hp
            //get = 2 -> get lowest attack
            //get = 3 -> get highest attack
            int get = (int)mode;

            if (minions.Count == 0) return null;
            Minion ret = minions[0];
            int value = ret.Hp;
            if (get >= 2) value = ret.Angr;
            foreach (Minion m in minions)
            {
                if (m.Hp <= 0) continue;

                switch (get)
                {
                    case 1:
                        if (m.Hp > value)
                        {
                            ret = m;
                            value = m.Hp;
                        }
                        break;
                    case 2:
                        if (m.Angr < value)
                        {
                            ret = m;
                            value = m.Angr;
                        }
                        break;
                    case 3:
                        if (m.Angr > value)
                        {
                            ret = m;
                            value = m.Angr;
                        }
                        break;
                    default:
                        if (m.Hp < value)
                        {
                            ret = m;
                            value = m.Hp;
                        }
                        break;
                }
            }
            if (ret.Hp <= 0) return null;
            return ret;
        }


        public void debugMinions()
        {
            Helpfunctions.Instance.logg("OWN MINIONS################");

            foreach (Minion m in this.ownMinions)
            {
                Helpfunctions.Instance.logg("name,ang, hp, maxhp: " + m.name + ", " + m.Angr + ", " + m.Hp + ", " + m.maxHp);
            }

            Helpfunctions.Instance.logg("ENEMY MINIONS############");
            foreach (Minion m in this.enemyMinions)
            {
                Helpfunctions.Instance.logg("name,ang, hp: " + m.name + ", " + m.Angr + ", " + m.Hp);
            }
        }

        public void printBoard()
        {
            Helpfunctions.Instance.logg("board: " + value + " ++++++++++++++++++++++");
            Helpfunctions.Instance.logg("pen " + this.evaluatePenality);
            Helpfunctions.Instance.logg("mana " + this.mana + "/" + this.ownMaxMana);
            Helpfunctions.Instance.logg("cardsplayed: " + this.cardsPlayedThisTurn + " handsize: " + this.owncards.Count + " eh " + this.enemyAnzCards);

            Helpfunctions.Instance.logg("ownhero: ");
            Helpfunctions.Instance.logg("ownherohp: " + this.ownHero.Hp + " + " + this.ownHero.armor);
            Helpfunctions.Instance.logg("ownheroattac: " + this.ownHero.Angr);
            Helpfunctions.Instance.logg("ownheroweapon: " + this.ownWeaponAttack + " " + this.ownWeaponDurability + " " + this.ownWeaponName);
            Helpfunctions.Instance.logg("ownherostatus: frozen" + this.ownHero.frozen + " ");
            Helpfunctions.Instance.logg("enemyherohp: " + this.enemyHero.Hp + " + " + this.enemyHero.armor + ((this.enemyHero.immune) ? " immune" : ""));

            if (this.enemySecretCount >= 1) Helpfunctions.Instance.logg("enemySecrets: " + Probabilitymaker.Instance.getEnemySecretData(this.enemySecretList));
            /*foreach (Action a in this.playactions)
            {
                a.print();
            }*/
            Helpfunctions.Instance.logg("OWN MINIONS################");

            foreach (Minion m in this.ownMinions)
            {
                Helpfunctions.Instance.logg("name,ang, hp: " + m.name + ", " + m.Angr + ", " + m.Hp + " " + m.entitiyID);
            }

            Helpfunctions.Instance.logg("ENEMY MINIONS############");
            foreach (Minion m in this.enemyMinions)
            {
                Helpfunctions.Instance.logg("name,ang, hp: " + m.name + ", " + m.Angr + ", " + m.Hp + " " + m.entitiyID);
            }


            Helpfunctions.Instance.logg("");
        }

        public void printBoardDebug()
        {
            Helpfunctions.Instance.logg("hero " + this.ownHero.Hp + " " + this.ownHero.armor + " " + this.ownHero.entitiyID);
            Helpfunctions.Instance.logg("ehero " + this.enemyHero.Hp + " " + this.enemyHero.armor + " " + this.enemyHero.entitiyID);
            foreach (Minion m in ownMinions)
            {
                Helpfunctions.Instance.logg(m.name + " " + m.entitiyID);
            }
            Helpfunctions.Instance.logg("-");
            foreach (Minion m in enemyMinions)
            {
                Helpfunctions.Instance.logg(m.name + " " + m.entitiyID);
            }
            Helpfunctions.Instance.logg("-");
            foreach (Handmanager.Handcard hc in this.owncards)
            {
                Helpfunctions.Instance.logg(hc.position + " " + hc.card.name + " " + hc.entity);
            }
        }

        public Action getNextAction()
        {
            if (this.playactions.Count >= 1) return this.playactions[0];
            return null;
        }

        public void printActions(bool toBuffer = false)
        {
            foreach (Action a in this.playactions)
            {
                a.print(toBuffer);
                Helpfunctions.Instance.logg("");
            }
        }

        public void printActionforDummies(Action a)
        {
            if (a.actionType == actionEnum.playcard)
            {
                Helpfunctions.Instance.ErrorLog("play " + a.card.card.name);
                if (a.druidchoice >= 1)
                {
                    string choose = (a.druidchoice == 1) ? "left card" : "right card";
                    Helpfunctions.Instance.ErrorLog("choose the " + choose);
                }
                if (a.place >= 1)
                {
                    Helpfunctions.Instance.ErrorLog("on position " + a.place);
                }
                if (a.target != null)
                {
                    if (!a.target.own && !a.target.isHero)
                    {
                        string ename = "" + a.target.name;
                        Helpfunctions.Instance.ErrorLog("and target to the enemy " + ename);
                    }

                    if (a.target.own && !a.target.isHero)
                    {
                        string ename = "" + a.target.name;
                        Helpfunctions.Instance.ErrorLog("and target to your own" + ename);
                    }

                    if (a.target.own && a.target.isHero)
                    {
                        Helpfunctions.Instance.ErrorLog("and target your own hero");
                    }

                    if (!a.target.own && a.target.isHero)
                    {
                        Helpfunctions.Instance.ErrorLog("and target to the enemy hero");
                    }
                }

            }
            if (a.actionType == actionEnum.attackWithMinion)
            {
                string name = "" + a.own.name;
                if (a.target.isHero)
                {
                    Helpfunctions.Instance.ErrorLog("attack with: " + name + " the enemy hero");
                }
                else
                {
                    string ename = "" + a.target.name;
                    Helpfunctions.Instance.ErrorLog("attack with: " + name + " the enemy: " + ename);
                }

            }

            if (a.actionType == actionEnum.attackWithHero)
            {
                if (a.target.isHero)
                {
                    Helpfunctions.Instance.ErrorLog("attack with your hero the enemy hero!");
                }
                else
                {
                    string ename = "" + a.target.name;
                    Helpfunctions.Instance.ErrorLog("attack with the hero, and choose the enemy: " + ename);
                }
            }
            if (a.actionType == actionEnum.useHeroPower)
            {
                Helpfunctions.Instance.ErrorLog("use your Heropower ");
                if (a.target != null)
                {
                    if (!a.target.own && !a.target.isHero)
                    {
                        string ename = "" + a.target.name;
                        Helpfunctions.Instance.ErrorLog("on enemy: " + ename);
                    }

                    if (a.target.own && !a.target.isHero)
                    {
                        string ename = "" + a.target.name;
                        Helpfunctions.Instance.ErrorLog("on your own: " + ename);
                    }

                    if (a.target.own && a.target.isHero)
                    {
                        Helpfunctions.Instance.ErrorLog("on your own hero");
                    }

                    if (!a.target.own && a.target.isHero)
                    {
                        Helpfunctions.Instance.ErrorLog("on your the enemy hero");
                    }

                }
            }
            Helpfunctions.Instance.ErrorLog("");

        }


    }

   
    public class Ai
    {

        private int maxdeep = 12;
        public int maxwide = 3000;
        //public int playaroundprob = 40;
        public int playaroundprob2 = 80;


        private bool usePenalityManager = true;
        private bool useCutingTargets = true;
        private bool dontRecalc = true;
        private bool useLethalCheck = true;
        private bool useComparison = true;


        public int lethalMissing = 30; //RR

        public MiniSimulator mainTurnSimulator;

        public List<EnemyTurnSimulator> enemyTurnSim = new List<EnemyTurnSimulator>();
        public List<MiniSimulatorNextTurn> nextTurnSimulator = new List<MiniSimulatorNextTurn>();
        public List<EnemyTurnSimulator> enemySecondTurnSim = new List<EnemyTurnSimulator>();

        public string currentCalculatedBoard = "1";

        PenalityManager penman = PenalityManager.Instance;

        List<Playfield> posmoves = new List<Playfield>(7000);

        Hrtprozis hp = Hrtprozis.Instance;
        Handmanager hm = Handmanager.Instance;
        Helpfunctions help = Helpfunctions.Instance;

        public Action bestmove = null;
        public float bestmoveValue = 0;
        public Playfield nextMoveGuess = new Playfield();
        public Behavior botBase = null;

        public List<Action> bestActions = new List<Action>();

        public bool secondturnsim = false;
        //public int secondTurnAmount = 256;
        public bool playaround = false;

        private static Ai instance;

        public static Ai Instance
        {
            get
            {
                return instance ?? (instance = new Ai());
            }
        }

        private Ai()
        {
            this.nextMoveGuess = new Playfield { mana = -100 };

            this.mainTurnSimulator = new MiniSimulator(maxdeep, maxwide, 0); // 0 for unlimited
            this.mainTurnSimulator.setPrintingstuff(true);

            /*this.nextTurnSimulator = new MiniSimulatorNextTurn();
            this.enemyTurnSim = new EnemyTurnSimulator();
            this.enemySecondTurnSim = new EnemyTurnSimulator();*/

            for (int i = 0; i < Settings.Instance.numberOfThreads; i++)
            {
                this.nextTurnSimulator.Add(new MiniSimulatorNextTurn());
                this.enemyTurnSim.Add(new EnemyTurnSimulator());
                this.enemySecondTurnSim.Add(new EnemyTurnSimulator());

                this.nextTurnSimulator[i].thread = i;
                this.enemyTurnSim[i].thread = i;
                this.enemySecondTurnSim[i].thread = i;
            }

        }

        public void setMaxWide(int mw)
        {
            this.maxwide = mw;
            if (maxwide <= 100) this.maxwide = 100;
            this.mainTurnSimulator.updateParams(maxdeep, maxwide, 0);
        }

        public void setTwoTurnSimulation(bool stts, int amount)
        {
            this.mainTurnSimulator.setSecondTurnSimu(stts, amount);
            this.secondturnsim = stts;
            Settings.Instance.secondTurnAmount = amount;
        }

        public void updateTwoTurnSim()
        {
            this.mainTurnSimulator.setSecondTurnSimu(Settings.Instance.simulateEnemysTurn, Settings.Instance.secondTurnAmount);
        }

        public void setPlayAround()
        {
            this.mainTurnSimulator.setPlayAround(Settings.Instance.playarround, Settings.Instance.playaroundprob, Settings.Instance.playaroundprob2);
        }

        private void doallmoves(bool test, bool isLethalCheck)
        {
            //set maxwide to the value for the first-turn-sim.
            foreach (EnemyTurnSimulator ets in enemyTurnSim)
            {
                ets.setMaxwideFirstStep(true);
            }

            foreach (EnemyTurnSimulator ets in enemySecondTurnSim)
            {
                ets.setMaxwideFirstStep(false);
            }

            if (isLethalCheck) this.posmoves[0].enemySecretList.Clear();
            this.mainTurnSimulator.doallmoves(this.posmoves[0], isLethalCheck);

            Playfield bestplay = this.mainTurnSimulator.bestboard;
            float bestval = this.mainTurnSimulator.bestmoveValue;

            help.loggonoff(true);
            help.logg("-------------------------------------");
            help.logg("value of best board " + bestval);

            if (isLethalCheck)
            {
                this.lethalMissing = bestplay.enemyHero.armor + bestplay.enemyHero.Hp;//RR
                help.logg("missing dmg to lethal " + this.lethalMissing);
            }
            else
            {
                this.lethalMissing = 130;
            }

            this.bestActions.Clear();
            this.bestmove = null;
            foreach (Action a in bestplay.playactions)
            {
                this.bestActions.Add(new Action(a));
                a.print();
            }
            //this.bestActions.Add(new Action(actionEnum.endturn, null, null, 0, null, 0, 0));

            if (this.bestActions.Count >= 1)
            {
                this.bestmove = this.bestActions[0];
                this.bestActions.RemoveAt(0);
            }
            this.bestmoveValue = bestval;

            if (bestmove != null && bestmove.actionType != actionEnum.endturn) // save the guessed move, so we doesnt need to recalc!
            {
                this.nextMoveGuess = new Playfield();

                this.nextMoveGuess.doAction(bestmove);
            }
            else
            {
                nextMoveGuess.mana = -100;
            }

        }

        public void setBestMoves(List<Action> alist, float value)
        {
            help.logg("set best action-----------------------------------");
            this.bestActions.Clear();
            this.bestmove = null;

            foreach (Action a in alist)
            {
                help.logg("-a-");
                this.bestActions.Add(new Action(a));
                this.bestActions[this.bestActions.Count - 1].print();
            }
            //this.bestActions.Add(new Action(actionEnum.endturn, null, null, 0, null, 0, 0));

            if (this.bestActions.Count >= 1)
            {
                this.bestmove = this.bestActions[0];
                this.bestActions.RemoveAt(0);
            }

            this.nextMoveGuess = new Playfield();
            //only debug:
            //this.nextMoveGuess.printBoardDebug();

            if (bestmove != null && bestmove.actionType != actionEnum.endturn) // save the guessed move, so we doesnt need to recalc!
            {
                Helpfunctions.Instance.logg("nmgsim-");
                try
                {
                    this.nextMoveGuess.doAction(bestmove);
                    this.bestmove = this.nextMoveGuess.playactions[this.nextMoveGuess.playactions.Count - 1];
                }
                catch (Exception ex)
                {
                    Helpfunctions.Instance.logg("Message ---");
                    Helpfunctions.Instance.logg("Message ---" + ex.Message);
                    Helpfunctions.Instance.logg("Source ---" + ex.Source);
                    Helpfunctions.Instance.logg("StackTrace ---" + ex.StackTrace);
                    Helpfunctions.Instance.logg("TargetSite ---\n{0}" + ex.TargetSite);

                }
                Helpfunctions.Instance.logg("nmgsime-");


            }
            else
            {
                nextMoveGuess.mana = -100;
            }
        }

        public void doNextCalcedMove()
        {
            help.logg("noRecalcNeeded!!!-----------------------------------");
            //this.bestboard.printActions();

            this.bestmove = null;
            if (this.bestActions.Count >= 1)
            {
                this.bestmove = this.bestActions[0];
                this.bestActions.RemoveAt(0);
            }
            if (this.nextMoveGuess == null) this.nextMoveGuess = new Playfield();
            //this.nextMoveGuess.printBoardDebug();

            if (bestmove != null && bestmove.actionType != actionEnum.endturn)  // save the guessed move, so we doesnt need to recalc!
            {
                //this.nextMoveGuess = new Playfield();
                Helpfunctions.Instance.logg("nmgsim-");
                try
                {
                    this.nextMoveGuess.doAction(bestmove);
                    this.bestmove = this.nextMoveGuess.playactions[this.nextMoveGuess.playactions.Count - 1];
                }
                catch (Exception ex)
                {
                    Helpfunctions.Instance.logg("Message ---");
                    Helpfunctions.Instance.logg("Message ---" + ex.Message);
                    Helpfunctions.Instance.logg("Source ---" + ex.Source);
                    Helpfunctions.Instance.logg("StackTrace ---" + ex.StackTrace);
                    Helpfunctions.Instance.logg("TargetSite ---\n{0}" + ex.TargetSite);

                }
                Helpfunctions.Instance.logg("nmgsime-");

            }
            else
            {
                //Helpfunctions.Instance.logg("nd trn");
                nextMoveGuess.mana = -100;
            }

        }

        public void dosomethingclever(Behavior bbase)
        {
            //return;
            //turncheck
            //help.moveMouse(950,750);
            //help.Screenshot();
            this.botBase = bbase;
            hp.updatePositions();

            posmoves.Clear();
            posmoves.Add(new Playfield());
            posmoves[0].sEnemTurn = Settings.Instance.simulateEnemysTurn;
            /* foreach (var item in this.posmoves[0].owncards)
             {
                 help.logg("card " + item.handcard.card.name + " is playable :" + item.handcard.card.canplayCard(posmoves[0]) + " cost/mana: " + item.handcard.card.cost + "/" + posmoves[0].mana);
             }
             */
            //help.logg("is hero ready?" + posmoves[0].ownHeroReady);

            help.loggonoff(false);
            //do we need to recalc?
            help.logg("recalc-check###########");
            if (this.dontRecalc && posmoves[0].isEqual(this.nextMoveGuess, true))
            {
                doNextCalcedMove();
            }
            else
            {
                help.logg("Leathal-check###########");
                bestmoveValue = -1000000;
                DateTime strt = DateTime.Now;
                if (useLethalCheck)
                {
                    strt = DateTime.Now;
                    doallmoves(false, true);
                    help.logg("calculated " + (DateTime.Now - strt).TotalSeconds);
                }

                if (bestmoveValue < 10000)
                {
                    posmoves.Clear();
                    posmoves.Add(new Playfield());
                    posmoves[0].sEnemTurn = Settings.Instance.simulateEnemysTurn;
                    help.logg("no lethal, do something random######");
                    strt = DateTime.Now;
                    doallmoves(false, false);
                    help.logg("calculated " + (DateTime.Now - strt).TotalSeconds);

                }
            }


            //help.logging(true);

        }

        public void autoTester(bool printstuff, string data = "")
        {
            help.logg("simulating board ");

            BoardTester bt = new BoardTester(data);
            if (!bt.datareaded) return;
            hp.printHero();
            hp.printOwnMinions();
            hp.printEnemyMinions();
            hm.printcards();
            //calculate the stuff
            posmoves.Clear();
            posmoves.Add(new Playfield());
            posmoves[0].sEnemTurn = Settings.Instance.simulateEnemysTurn;
            foreach (Playfield p in this.posmoves)
            {
                p.printBoard();
            }
            help.logg("ownminionscount " + posmoves[0].ownMinions.Count);
            help.logg("owncardscount " + posmoves[0].owncards.Count);

            foreach (var item in this.posmoves[0].owncards)
            {
                help.logg("card " + item.card.name + " is playable :" + item.canplayCard(posmoves[0]) + " cost/mana: " + item.manacost + "/" + posmoves[0].mana);
            }
            help.logg("ability " + posmoves[0].ownHeroAblility.card.name + " is playable :" + posmoves[0].ownHeroAblility.card.canplayCard(posmoves[0], 2) + " cost/mana: " + posmoves[0].ownHeroAblility.card.getManaCost(posmoves[0], 2) + "/" + posmoves[0].mana);

            // lethalcheck + normal
            DateTime strt = DateTime.Now;
            doallmoves(false, true);
            help.logg("calculated " + (DateTime.Now - strt).TotalSeconds);
            double timeneeded = 0;
            if (bestmoveValue < 10000)
            {
                posmoves.Clear();
                posmoves.Add(new Playfield());
                posmoves[0].sEnemTurn = Settings.Instance.simulateEnemysTurn;
                strt = DateTime.Now;
                doallmoves(false, false);
                timeneeded = (DateTime.Now - strt).TotalSeconds;
                help.logg("calculated " + (DateTime.Now - strt).TotalSeconds);
            }

            if (printstuff)
            {
                this.mainTurnSimulator.printPosmoves();
                simmulateWholeTurn();
                help.logg("calculated " + timeneeded);
            }
        }

        public void simmulateWholeTurn()
        {
            help.ErrorLog("########################################################################################################");
            help.ErrorLog("simulate best board");
            help.ErrorLog("########################################################################################################");
            //this.bestboard.printActions();

            Playfield tempbestboard = new Playfield();

            tempbestboard.printBoard();

            if (bestmove != null && bestmove.actionType != actionEnum.endturn)  // save the guessed move, so we doesnt need to recalc!
            {
                bestmove.print();

                tempbestboard.doAction(bestmove);

            }
            else
            {
                tempbestboard.mana = -100;
            }
            help.logg("-------------");
            tempbestboard.printBoard();

            foreach (Action bestmovee in this.bestActions)
            {

                help.logg("stepp");


                if (bestmovee != null && bestmove.actionType != actionEnum.endturn)  // save the guessed move, so we doesnt need to recalc!
                {
                    bestmovee.print();

                    tempbestboard.doAction(bestmovee);

                }
                else
                {
                    tempbestboard.mana = -100;
                }
                help.logg("-------------");
                tempbestboard.printBoard();
            }

            //help.logg("AFTER ENEMY TURN:" );
            tempbestboard.sEnemTurn = true;
            tempbestboard.endTurn(false, this.playaround, false, Settings.Instance.playaroundprob, Settings.Instance.playaroundprob2);
            help.logg("ENEMY TURN:-----------------------------");
            tempbestboard.value = int.MinValue;
            tempbestboard.prepareNextTurn(tempbestboard.isOwnTurn);
            Ai.Instance.enemyTurnSim[0].simulateEnemysTurn(tempbestboard, true, playaround, true, Settings.Instance.playaroundprob, Settings.Instance.playaroundprob2);
        }

        public void simmulateWholeTurnandPrint()
        {
            help.ErrorLog("###################################");
            help.ErrorLog("what would silverfish do?---------");
            help.ErrorLog("###################################");
            if (this.bestmoveValue >= 10000) help.ErrorLog("DETECTED LETHAL ###################################");
            //this.bestboard.printActions();

            Playfield tempbestboard = new Playfield();

            if (bestmove != null && bestmove.actionType != actionEnum.endturn)  // save the guessed move, so we doesnt need to recalc!
            {

                tempbestboard.doAction(bestmove);
                tempbestboard.printActionforDummies(tempbestboard.playactions[tempbestboard.playactions.Count - 1]);

                if (this.bestActions.Count == 0)
                {
                    help.ErrorLog("end turn");
                }
            }
            else
            {
                tempbestboard.mana = -100;
                help.ErrorLog("end turn");
            }


            foreach (Action bestmovee in this.bestActions)
            {

                if (bestmovee != null && bestmove.actionType != actionEnum.endturn)  // save the guessed move, so we doesnt need to recalc!
                {
                    //bestmovee.print();
                    tempbestboard.doAction(bestmovee);
                    tempbestboard.printActionforDummies(tempbestboard.playactions[tempbestboard.playactions.Count - 1]);

                }
                else
                {
                    tempbestboard.mana = -100;
                    help.ErrorLog("end turn");
                }
            }
        }

        public void updateEntitiy(int old, int newone)
        {
            Helpfunctions.Instance.logg("entityupdate! " + old + " to " + newone);
            if (this.nextMoveGuess != null)
            {
                foreach (Minion m in this.nextMoveGuess.ownMinions)
                {
                    if (m.entitiyID == old) m.entitiyID = newone;
                }
                foreach (Minion m in this.nextMoveGuess.enemyMinions)
                {
                    if (m.entitiyID == old) m.entitiyID = newone;
                }
            }
            foreach (Action a in this.bestActions)
            {
                if (a.own != null && a.own.entitiyID == old) a.own.entitiyID = newone;
                if (a.target != null && a.target.entitiyID == old) a.target.entitiyID = newone;
                if (a.card != null && a.card.entity == old) a.card.entity = newone;
            }

        }

    }

    public class MiniSimulator
    {
        //#####################################################################################################################
        private int maxdeep = 6;
        private int maxwide = 10;
        private int totalboards = 50;
        private bool usePenalityManager = true;
        private bool useCutingTargets = true;
        private bool dontRecalc = true;
        private bool useLethalCheck = true;
        private bool useComparison = true;


        private bool printNormalstuff = false;

        List<Playfield> posmoves = new List<Playfield>(7000);
        List<Playfield> twoturnfields = new List<Playfield>(500);

        List<List<Playfield>> threadresults = new List<List<Playfield>>(64);
        private int dirtyTwoTurnSim = 256;

        public Action bestmove = null;
        public float bestmoveValue = 0;
        public Playfield bestboard = new Playfield();

        public Behavior botBase = null;
        private int calculated = 0;

        private bool simulateSecondTurn = false;
        private bool playaround = false;
        private int playaroundprob = 50;
        private int playaroundprob2 = 80;

        Movegenerator movegen = Movegenerator.Instance;

        PenalityManager pen = PenalityManager.Instance;

        public MiniSimulator()
        {
        }
        public MiniSimulator(int deep, int wide, int ttlboards)
        {
            this.maxdeep = deep;
            this.maxwide = wide;
            this.totalboards = ttlboards;
        }

        public void updateParams(int deep, int wide, int ttlboards)
        {
            this.maxdeep = deep;
            this.maxwide = wide;
            this.totalboards = ttlboards;
        }

        public void setPrintingstuff(bool sp)
        {
            this.printNormalstuff = sp;
        }

        public void setSecondTurnSimu(bool sts, int amount)
        {
            //this.simulateSecondTurn = sts;
            this.dirtyTwoTurnSim = amount;
        }

        public void setPlayAround(bool spa, int pprob, int pprob2)
        {
            this.playaround = spa;
            this.playaroundprob = pprob;
            this.playaroundprob2 = pprob2;
        }

        private void addToPosmoves(Playfield pf)
        {
            if (pf.ownHero.Hp <= 0) return;
            /*foreach (Playfield p in this.posmoves)
            {
                if (pf.isEqual(p, false)) return;
            }*/
            this.posmoves.Add(pf);

            //posmoves.Sort((a, b) => -(botBase.getPlayfieldValue(a)).CompareTo(botBase.getPlayfieldValue(b)));//want to keep the best
            //if (posmoves.Count > this.maxwide) posmoves.RemoveAt(this.maxwide);
            if (this.totalboards >= 1)
            {
                this.calculated++;
            }
        }

        private void startEnemyTurnSim(Playfield p, bool simulateTwoTurns, bool print)
        {
            if (p.guessingHeroHP >= 1)
            {
                //simulateEnemysTurn(simulateTwoTurns, playaround, print, pprob, pprob2);
                p.prepareNextTurn(p.isOwnTurn);

                Ai.Instance.enemyTurnSim[0].simulateEnemysTurn(p, simulateTwoTurns, playaround, print, playaroundprob, playaroundprob2);

            }
            p.complete = true;
        }

        public float doallmoves(Playfield playf, bool isLethalCheck)
        {
            //Helpfunctions.Instance.logg("NXTTRN" + playf.mana);
            if (botBase == null) botBase = Ai.Instance.botBase;
            bool test = false;
            this.posmoves.Clear();
            this.twoturnfields.Clear();
            this.addToPosmoves(playf);
            bool havedonesomething = true;
            List<Playfield> temp = new List<Playfield>();
            int deep = 0;
            //Helpfunctions.Instance.logg("NXTTRN" + playf.mana + " " + posmoves.Count);
            this.calculated = 0;
            while (havedonesomething)
            {
                if (this.printNormalstuff) Helpfunctions.Instance.logg("ailoop");
                GC.Collect();
                temp.Clear();
                temp.AddRange(this.posmoves);
                havedonesomething = false;
                Playfield bestold = null;
                float bestoldval = -20000000;
                foreach (Playfield p in temp)
                {

                    if (p.complete || p.ownHero.Hp <= 0)
                    {
                        continue;
                    }

                    //gernerate actions and play them!
                    List<Action> actions = movegen.getMoveList(p, isLethalCheck, usePenalityManager, useCutingTargets);
                    foreach (Action a in actions)
                    {
                        //if (deep == 0 && a.actionType == actionEnum.attackWithMinion) Helpfunctions.Instance.ErrorLog("play " + a.own.entitiyID + " -> " + a.target.entitiyID);
                        havedonesomething = true;
                        Playfield pf = new Playfield(p);
                        pf.doAction(a);
                        addToPosmoves(pf);
                    }

                    // end the turn of the current board (only if its not a lethalcheck)
                    if (isLethalCheck)
                    {
                        p.complete = true;
                    }
                    else
                    {
                        //end turn of enemy
                        p.endTurn(this.simulateSecondTurn, this.playaround, false, this.playaroundprob, this.playaroundprob2);
                        //simulate the enemys response
                        this.startEnemyTurnSim(p, this.simulateSecondTurn, false);
                    }

                    //sort stupid stuff ouf

                    if (botBase.getPlayfieldValue(p) > bestoldval)
                    {
                        bestoldval = botBase.getPlayfieldValue(p);
                        bestold = p;
                    }
                    if (!test)
                    {
                        posmoves.Remove(p);
                    }

                    if (this.calculated > this.totalboards) break;
                }

                if (!test && bestoldval >= -10000 && bestold != null)
                {
                    this.posmoves.Add(bestold);
                }

                //Helpfunctions.Instance.loggonoff(true);
                if (this.printNormalstuff)
                {
                    int donec = 0;
                    foreach (Playfield p in posmoves)
                    {
                        if (p.complete) donec++;
                    }
                    Helpfunctions.Instance.logg("deep " + deep + " len " + this.posmoves.Count + " dones " + donec);
                }

                if (!test)
                {
                    cuttingposibilities();
                }

                if (this.printNormalstuff)
                {
                    Helpfunctions.Instance.logg("cut to len " + this.posmoves.Count);
                }
                //Helpfunctions.Instance.loggonoff(false);
                deep++;

                if (this.calculated > this.totalboards) break;
                if (deep >= this.maxdeep) break;//remove this?
            }

            foreach (Playfield p in posmoves)//temp
            {
                if (!p.complete)
                {
                    if (isLethalCheck)
                    {
                        p.complete = true;
                    }
                    else
                    {
                        p.endTurn(this.simulateSecondTurn, this.playaround, false, this.playaroundprob, this.playaroundprob2);
                        this.startEnemyTurnSim(p, this.simulateSecondTurn, false);
                    }
                }
            }

            // search the best play...........................................................

            //do dirtytwoturnsim first :D
            if (!isLethalCheck) doDirtyTwoTurnsim();

            if (!isLethalCheck) this.dirtyTwoTurnSim /= 2;

            // Helpfunctions.Instance.logg("find best ");
            if (posmoves.Count >= 1)
            {
                float bestval = int.MinValue;
                int bestanzactions = 1000;
                Playfield bestplay = posmoves[0];//temp[0]
                foreach (Playfield p in posmoves)//temp
                {
                    float val = botBase.getPlayfieldValue(p);
                    if (bestval <= val)
                    {
                        if (bestval == val && bestanzactions < p.playactions.Count) continue;
                        bestplay = p;
                        bestval = val;
                        bestanzactions = p.playactions.Count;
                    }

                }

                this.bestmove = bestplay.getNextAction();
                this.bestmoveValue = bestval;
                this.bestboard = new Playfield(bestplay);
                //Helpfunctions.Instance.logg("return");
                return bestval;
            }
            //Helpfunctions.Instance.logg("return");
            this.bestmove = null;
            this.bestmoveValue = -100000;
            this.bestboard = playf;
            return -10000;
        }

        public void doDirtyTwoTurnsim()
        {
            //return;
            if (this.dirtyTwoTurnSim == 0) return;
            this.posmoves.Clear();
            int thread = 0;
            //DateTime started = DateTime.Now;

            //set maxwide of enemyturnsimulator's to second step (this value is higher than the maxwide in first step) 
            foreach (EnemyTurnSimulator ets in Ai.Instance.enemyTurnSim)
            {
                ets.setMaxwideSecondStep(true);
            }

            if (Settings.Instance.numberOfThreads == 1)
            {
                foreach (Playfield p in this.twoturnfields)
                {

                    if (p.guessingHeroHP >= 1)
                    {
                        p.value = int.MinValue;
                        //simulateEnemysTurn(simulateTwoTurns, playaround, print, pprob, pprob2);
                        p.prepareNextTurn(p.isOwnTurn);
                        Ai.Instance.enemyTurnSim[thread].simulateEnemysTurn(p, true, playaround, false, this.playaroundprob, this.playaroundprob2);
                    }
                    else
                    {
                        //p.value = -10000;
                    }
                    //Ai.Instance.enemyTurnSim.simulateEnemysTurn(p, true, this.playaround, false, this.playaroundprob, this.playaroundprob2);
                    this.posmoves.Add(p);
                }
            }
            else
            {
                //multithreading!

                List<System.Threading.Thread> tasks = new List<System.Threading.Thread>(Settings.Instance.numberOfThreads);
                for (int kl = 0; kl < Settings.Instance.numberOfThreads; kl++)
                {
                    if (this.threadresults.Count > kl)
                    {
                        this.threadresults[kl].Clear();
                        continue;
                    }
                    this.threadresults.Add(new List<Playfield>());
                }


                int k = 0;
                for (k = 0; k < Settings.Instance.numberOfThreads; k++)
                {
                    //System.Threading.Thread threadl = new System.Threading.Thread(() => this.Workthread(test, botBase, isLethalCheck, playfieldsTasklist[k], threadnumbers[k]));
                    System.Threading.Thread threadl = new System.Threading.Thread(new System.Threading.ParameterizedThreadStart(this.dirtyWorkthread));
                    //System.Threading.Tasks.Task tsk = new System.Threading.Tasks.Task(this.Workthread, (object)new threadobject(test, botBase, isLethalCheck, playfieldsTasklist[k], threadnumbers[k]));
                    int i = k;
                    threadl.Start((object)i);

                    tasks.Add(threadl);

                }

                System.Threading.Thread.Sleep(1);

                for (int j = 0; j < Settings.Instance.numberOfThreads; j++)
                {
                    tasks[j].Join();
                    posmoves.AddRange(this.threadresults[j]);
                }


            }

            //just for debugging
            posmoves.Sort((a, b) => -(botBase.getPlayfieldValue(a)).CompareTo(botBase.getPlayfieldValue(b)));//want to keep the best

            //Helpfunctions.Instance.ErrorLog("time needed for parallel: " + (DateTime.Now - started).TotalSeconds);
        }

        //workthread for dirtyTwoTurnsim
        private void dirtyWorkthread(object to)
        {
            int threadnumber = (int)to;
            //Helpfunctions.Instance.ErrorLog("Hi, i'm no " + threadnumber);
            for (int i = 0; i < this.twoturnfields.Count; i++)
            {
                if (i % Settings.Instance.numberOfThreads == threadnumber)
                {
                    //if(threadnumber ==0)Helpfunctions.Instance.ErrorLog("no " + threadnumber + " calculates " + i);
                    Playfield p = this.twoturnfields[i];
                    if (p.guessingHeroHP >= 1)
                    {
                        p.value = int.MinValue;
                        //simulateEnemysTurn(simulateTwoTurns, playaround, print, pprob, pprob2);
                        p.prepareNextTurn(p.isOwnTurn);
                        Ai.Instance.enemyTurnSim[threadnumber].simulateEnemysTurn(p, true, playaround, false, this.playaroundprob, this.playaroundprob2);
                    }
                    else
                    {
                        //p.value = -10000;
                    }
                    //Ai.Instance.enemyTurnSim.simulateEnemysTurn(p, true, this.playaround, false, this.playaroundprob, this.playaroundprob2);


                    this.threadresults[threadnumber].Add(p);

                }
            }

        }



        public void cuttingposibilities()
        {
            // take the x best values
            int takenumber = this.maxwide;
            List<Playfield> temp = new List<Playfield>();
            posmoves.Sort((a, b) => -(botBase.getPlayfieldValue(a)).CompareTo(botBase.getPlayfieldValue(b)));//want to keep the best

            if (this.useComparison)
            {
                int i = 0;
                int max = Math.Min(posmoves.Count, this.maxwide);

                Playfield p = null;
                Playfield pp = null;
                //foreach (Playfield p in posmoves)
                for (i = 0; i < max; i++)
                {
                    p = posmoves[i];
                    int hash = p.GetHashCode();
                    p.hashcode = hash;
                    bool found = false;
                    //foreach (Playfield pp in temp)
                    for (int j = 0; j < temp.Count; j++)
                    {
                        pp = temp[j];
                        if (pp.hashcode == p.hashcode)
                        {
                            if (pp.isEqualf(p))
                            {
                                found = true;
                                break;
                            }
                        }
                    }
                    if (!found) temp.Add(p);
                    //i++;
                    //if (i >= this.maxwide) break;

                }


            }
            else
            {
                temp.AddRange(posmoves);
            }
            posmoves.Clear();
            posmoves.AddRange(temp.GetRange(0, Math.Min(takenumber, temp.Count)));

            //twoturnfields!
            if (this.dirtyTwoTurnSim == 0) return;
            temp.Clear();
            temp.AddRange(this.twoturnfields);
            temp.AddRange(posmoves.GetRange(0, Math.Min(this.dirtyTwoTurnSim, posmoves.Count)));
            temp.Sort((a, b) => -(botBase.getPlayfieldValue(a)).CompareTo(botBase.getPlayfieldValue(b)));
            this.twoturnfields.Clear();

            if (this.useComparison)
            {
                int i = 0;
                int max = Math.Min(temp.Count, this.dirtyTwoTurnSim);

                Playfield p = null;
                Playfield pp = null;
                //foreach (Playfield p in posmoves)
                for (i = 0; i < max; i++)
                {
                    p = temp[i];
                    int hash = p.GetHashCode();
                    p.hashcode = hash;
                    bool found = false;
                    //foreach (Playfield pp in temp)
                    for (int j = 0; j < twoturnfields.Count; j++)
                    {
                        pp = twoturnfields[j];
                        if (pp.hashcode == p.hashcode)
                        {
                            if (pp.isEqualf(p))
                            {
                                found = true;
                                break;
                            }
                        }
                    }
                    if (!found) twoturnfields.Add(p);
                    //i++;
                    //if (i >= this.maxwide) break;

                }


            }






            //this.twoturnfields.AddRange(temp.GetRange(0, Math.Min(this.dirtyTwoTurnSim, temp.Count)));

            //Helpfunctions.Instance.ErrorLog(this.twoturnfields.Count + "");

            //posmoves.Clear();
            //posmoves.AddRange(Helpfunctions.TakeList(temp, takenumber));

        }

        public List<targett> cutAttackTargets(List<targett> oldlist, Playfield p, bool own)
        {
            List<targett> retvalues = new List<targett>();
            List<Minion> addedmins = new List<Minion>(8);

            bool priomins = false;
            List<targett> retvaluesPrio = new List<targett>();
            foreach (targett t in oldlist)
            {
                if ((own && t.target == 200) || (!own && t.target == 100))
                {
                    retvalues.Add(t);
                    continue;
                }
                if ((own && t.target >= 10 && t.target <= 19) || (!own && t.target >= 0 && t.target <= 9))
                {
                    Minion m = null;
                    if (own) m = p.enemyMinions[t.target - 10];
                    if (!own) m = p.ownMinions[t.target];
                    /*if (penman.priorityDatabase.ContainsKey(m.name))
                    {
                        //retvalues.Add(t);
                        retvaluesPrio.Add(t);
                        priomins = true;
                        //help.logg(m.name + " is added to targetlist");
                        continue;
                    }*/


                    bool goingtoadd = true;
                    List<Minion> temp = new List<Minion>(addedmins);
                    bool isSpecial = m.handcard.card.isSpecialMinion;
                    foreach (Minion mnn in temp)
                    {
                        // special minions are allowed to attack in silended and unsilenced state!
                        //help.logg(mnn.silenced + " " + m.silenced + " " + mnn.name + " " + m.name + " " + penman.specialMinions.ContainsKey(m.name));

                        bool otherisSpecial = mnn.handcard.card.isSpecialMinion;

                        if ((!isSpecial || (isSpecial && m.silenced)) && (!otherisSpecial || (otherisSpecial && mnn.silenced))) // both are not special, if they are the same, dont add
                        {
                            if (mnn.Angr == m.Angr && mnn.Hp == m.Hp && mnn.divineshild == m.divineshild && mnn.taunt == m.taunt && mnn.poisonous == m.poisonous) goingtoadd = false;
                            continue;
                        }

                        if (isSpecial == otherisSpecial && !m.silenced && !mnn.silenced) // same are special
                        {
                            if (m.name != mnn.name) // different name -> take it
                            {
                                continue;
                            }
                            // same name -> test whether they are equal
                            if (mnn.Angr == m.Angr && mnn.Hp == m.Hp && mnn.divineshild == m.divineshild && mnn.taunt == m.taunt && mnn.poisonous == m.poisonous) goingtoadd = false;
                            continue;
                        }

                    }

                    if (goingtoadd)
                    {
                        addedmins.Add(m);
                        retvalues.Add(t);
                        //help.logg(m.name + " " + m.id +" is added to targetlist");
                    }
                    else
                    {
                        //help.logg(m.name + " is not needed to attack");
                        continue;
                    }

                }
            }
            //help.logg("end targetcutting");
            if (priomins) return retvaluesPrio;

            return retvalues;
        }

        public void printPosmoves()
        {
            int i = 0;
            foreach (Playfield p in this.posmoves)
            {
                p.printBoard();
                i++;
                if (i >= 200) break;
            }
        }

    }

    public class EnemyTurnSimulator
    {

        public int thread = 0;

        private List<Playfield> posmoves = new List<Playfield>(7000);
        //public int maxwide = 20;
        Movegenerator movegen = Movegenerator.Instance;
        public int maxwide = 20;

        public void setMaxwideFirstStep(bool firstTurn)
        {
            maxwide = Settings.Instance.enemyTurnMaxWide;
            if (!firstTurn) maxwide = Settings.Instance.enemyTurnMaxWide;
        }

        public void setMaxwideSecondStep(bool firstTurn)
        {
            maxwide = Settings.Instance.enemyTurnMaxWideSecondTime;
            if (!firstTurn) maxwide = Settings.Instance.enemyTurnMaxWide;
        }

        public void simulateEnemysTurn(Playfield rootfield, bool simulateTwoTurns, bool playaround, bool print, int pprob, int pprob2)
        {

            bool havedonesomething = true;
            posmoves.Clear();
            if (print)
            {
                Helpfunctions.Instance.ErrorLog("board at enemyturn start-----------------------------");
                rootfield.printBoard();
            }
            posmoves.Add(new Playfield(rootfield));
            //posmoves[0].prepareNextTurn(false);
            List<Playfield> temp = new List<Playfield>();
            int deep = 0;
            int enemMana = Math.Min(rootfield.enemyMaxMana + 1, 10);

            if (playaround && !rootfield.loatheb)
            {
                float oldval = Ai.Instance.botBase.getPlayfieldValue(posmoves[0]);
                posmoves[0].value = int.MinValue;
                enemMana = posmoves[0].EnemyCardPlaying(rootfield.enemyHeroName, enemMana, rootfield.enemyAnzCards, pprob, pprob2);
                float newval = Ai.Instance.botBase.getPlayfieldValue(posmoves[0]);
                posmoves[0].value = int.MinValue;
                posmoves[0].enemyAnzCards--;
                posmoves[0].triggerCardsChanged(false);
                if (oldval < newval)
                {
                    posmoves.Clear();
                    posmoves.Add(new Playfield(rootfield));
                }
            }



            //play ability!
            if (posmoves[0].enemyAbilityReady && enemMana >= 2 && posmoves[0].enemyHeroAblility.card.canplayCard(posmoves[0], 0) && !rootfield.loatheb)
            {
                int abilityPenality = 0;

                havedonesomething = true;
                // if we have mage or priest, we have to target something####################################################
                if (posmoves[0].enemyHeroName == HeroEnum.mage || posmoves[0].enemyHeroName == HeroEnum.priest || posmoves[0].enemyHeroName == HeroEnum.hunter)
                {

                    List<Minion> trgts = posmoves[0].enemyHeroAblility.card.getTargetsForCardEnemy(posmoves[0]);
                    foreach (Minion trgt in trgts)
                    {
                        if (trgt.isHero) continue;
                        Action a = new Action(actionEnum.useHeroPower, posmoves[0].enemyHeroAblility, null, 0, trgt, abilityPenality, 0);
                        Playfield pf = new Playfield(posmoves[0]);
                        pf.doAction(a);
                        posmoves.Add(pf);
                    }
                }
                else
                {
                    // the other classes dont have to target####################################################
                    Action a = new Action(actionEnum.useHeroPower, posmoves[0].enemyHeroAblility, null, 0, null, abilityPenality, 0);
                    Playfield pf = new Playfield(posmoves[0]);
                    pf.doAction(a);
                    posmoves.Add(pf);
                }

            }


            foreach (Minion m in posmoves[0].enemyMinions)
            {
                if (m.Angr == 0) continue;
                m.numAttacksThisTurn = 0;
                m.playedThisTurn = false;
                m.updateReadyness();
            }

            doSomeBasicEnemyAi(posmoves[0]);

            int boardcount = 0;
            //movegen...

            int i = 0;
            int count = 0;
            Playfield p = null;

            while (havedonesomething)
            {

                temp.Clear();
                temp.AddRange(posmoves);
                havedonesomething = false;
                Playfield bestold = null;
                float bestoldval = 20000000;

                //foreach (Playfield p in temp)
                count = temp.Count;
                for (i = 0; i < count; i++)
                {
                    p = temp[i];
                    if (p.complete)
                    {
                        continue;
                    }

                    List<Action> actions = movegen.getEnemyMoveList(p, false, true, true, 1);// 1 for not using ability moves

                    foreach (Action a in actions)
                    {
                        havedonesomething = true;
                        Playfield pf = new Playfield(p);
                        pf.doAction(a);
                        posmoves.Add(pf);
                        boardcount++;
                    }

                    p.endEnemyTurn();
                    p.guessingHeroHP = rootfield.guessingHeroHP;
                    if (Ai.Instance.botBase.getPlayfieldValue(p) < bestoldval) // want the best enemy-play-> worst for us
                    {
                        bestoldval = Ai.Instance.botBase.getPlayfieldValue(p);
                        bestold = p;
                    }
                    posmoves.Remove(p);

                    if (boardcount >= maxwide) break;
                }

                if (bestoldval <= 10000 && bestold != null)
                {
                    posmoves.Add(bestold);
                }

                deep++;
                if (boardcount >= maxwide) break;
            }

            //foreach (Playfield p in posmoves)
            count = posmoves.Count;
            for (i = 0; i < count; i++)
            {

                if (!posmoves[i].complete) posmoves[i].endEnemyTurn();
            }

            float bestval = int.MaxValue;
            Playfield bestplay = posmoves[0];

            //foreach (Playfield p in posmoves)
            count = posmoves.Count;
            for (i = 0; i < count; i++)
            {
                p = posmoves[i];
                p.guessingHeroHP = rootfield.guessingHeroHP;
                float val = Ai.Instance.botBase.getPlayfieldValue(p);
                if (bestval > val)// we search the worst value
                {
                    bestplay = p;
                    bestval = val;
                }
            }
            if (print)
            {
                Helpfunctions.Instance.ErrorLog("best enemy board----------------------------------");
                bestplay.printBoard();
            }
            rootfield.value = bestplay.value;
            if (simulateTwoTurns && bestplay.value > -1000)
            {
                bestplay.prepareNextTurn(true);
                rootfield.value = Settings.Instance.firstweight * bestval + Settings.Instance.secondweight * Ai.Instance.nextTurnSimulator[this.thread].doallmoves(bestplay, false, print);
            }


        }

        CardDB.Card flame = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_614t);

        private void doSomeBasicEnemyAi(Playfield p)
        {
            if (p.enemyHeroName == HeroEnum.mage)
            {
                if (Probabilitymaker.Instance.enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_561)) p.ownHero.Hp = Math.Max(5, p.ownHero.Hp - 7);
            }

            //play some cards (to not overdraw)
            if (p.enemyAnzCards >= 8)
            {
                p.enemyAnzCards--;
                p.triggerCardsChanged(false);
            }
            if (p.enemyAnzCards >= 4)
            {
                p.enemyAnzCards--;
                p.triggerCardsChanged(false);
            }
            if (p.enemyAnzCards >= 2)
            {
                p.enemyAnzCards--;
                p.triggerCardsChanged(false);
            }

            //int i = 0;
            //int count = 0;


            foreach (Minion m in p.enemyMinions.ToArray())
            {
                if (m.silenced) continue;
                if (p.enemyAnzCards >= 2 && (m.name == CardDB.cardName.gadgetzanauctioneer || m.name == CardDB.cardName.starvingbuzzard))
                {
                    if (p.enemyDeckSize >= 1)
                    {
                        p.drawACard(CardDB.cardName.unknown, false);
                    }
                }
                if (m.name == CardDB.cardName.northshirecleric)
                {
                    int anz = 0;
                    foreach (Minion mnn in p.enemyMinions)
                    {
                        if (mnn.wounded) anz++;
                    }
                    anz = Math.Min(anz, 3);
                    for (int i = 0; i < anz; i++)
                    {
                        if (p.enemyDeckSize >= 1)
                        {
                            p.drawACard(CardDB.cardName.unknown, false);
                        }
                    }
                }

                if (m.name == CardDB.cardName.illidanstormrage && p.enemyAnzCards >= 1)
                {
                    p.callKid(flame, p.enemyMinions.Count, false);
                }

                if (m.name == CardDB.cardName.questingadventurer && p.enemyAnzCards >= 1)
                {
                    p.minionGetBuffed(m, 1, 1);
                    if (p.enemyAnzCards >= 3 && p.enemyMaxMana >= 5)
                    {
                        p.minionGetBuffed(m, 1, 1);
                    }
                }

                if (m.name == CardDB.cardName.manaaddict && p.enemyAnzCards >= 1)
                {
                    p.minionGetTempBuff(m, 2, 0);
                    if (p.enemyAnzCards >= 3 && p.enemyMaxMana >= 5)
                    {
                        p.minionGetTempBuff(m, 2, 0);
                    }
                }

                if (m.name == CardDB.cardName.manawyrm && p.enemyAnzCards >= 1)
                {
                    p.minionGetBuffed(m, 1, 0);
                    if (p.enemyAnzCards >= 3 && p.enemyMaxMana >= 5)
                    {
                        p.minionGetBuffed(m, 1, 0);
                    }
                }

                if (m.name == CardDB.cardName.secretkeeper && p.enemyAnzCards >= 3)
                {
                    p.minionGetBuffed(m, 1, 1);
                }

                if (m.name == CardDB.cardName.unboundelemental && p.enemyAnzCards >= 2)
                {
                    p.minionGetBuffed(m, 1, 1);
                }

                if (m.name == CardDB.cardName.murloctidecaller && p.enemyAnzCards >= 2)
                {
                    p.minionGetBuffed(m, 1, 0);
                }

                if (m.name == CardDB.cardName.undertaker && p.enemyAnzCards >= 2)
                {
                    p.minionGetBuffed(m, 1, 1);
                }

                if (m.name == CardDB.cardName.frothingberserker && p.enemyMinions.Count + p.ownMinions.Count >= 3)
                {
                    p.minionGetBuffed(m, 1, 0);
                }

                if (m.name == CardDB.cardName.gurubashiberserker && m.Hp >= 5 && p.enemyAnzCards >= 3)
                {
                    p.minionGetBuffed(m, 3, 0);
                }

                if (m.name == CardDB.cardName.lightwarden)
                {
                    int anz = 0;
                    foreach (Minion mnn in p.enemyMinions)
                    {
                        if (mnn.wounded) anz++;
                    }
                    if (p.enemyHero.wounded) anz++;
                    if (anz >= 2) p.minionGetBuffed(m, 2, 0);
                }
            }

            if (p.enemyMinions.Count < 7)
            {
                p.callKid(this.flame, p.enemyMinions.Count, false);
                int bval = 1;
                if (p.enemyMaxMana > 4) bval = 2;
                if (p.enemyMaxMana > 7) bval = 3;
                if (p.enemyMinions.Count >= 1) p.minionGetBuffed(p.enemyMinions[p.enemyMinions.Count - 1], bval - 1, bval);
            }
        }


    }

    public class MiniSimulatorNextTurn
    {
        //#####################################################################################################################
        //public int maxdeep = 6;
        //public int maxwide = 10;
        //public int totalboards = 50;

        public int thread = 0;

        private bool usePenalityManager = true;
        private bool useCutingTargets = true;
        private bool dontRecalc = true;
        private bool useLethalCheck = true;
        private bool useComparison = true;

        public bool doEnemySecondTurn = false;

        List<Playfield> posmoves = new List<Playfield>(7000);

        public Action bestmove = null;
        public float bestmoveValue = 0;
        public Playfield bestboard = new Playfield();

        public Behavior botBase = null;
        private int calculated = 0;

        private bool simulateSecondTurn = false;

        Movegenerator movegen = Movegenerator.Instance;


        public MiniSimulatorNextTurn()
        {
        }



        private void addToPosmoves(Playfield pf, int totalboards)
        {
            if (pf.ownHero.Hp <= 0) return;
            /*foreach (Playfield p in this.posmoves)
            {
                if (pf.isEqual(p, false)) return;
            }*/
            this.posmoves.Add(pf);
            //posmoves.Sort((a, b) => -(botBase.getPlayfieldValue(a)).CompareTo(botBase.getPlayfieldValue(b)));//want to keep the best
            //if (posmoves.Count > this.maxwide) posmoves.RemoveAt(this.maxwide);
            if (totalboards >= 1)
            {
                this.calculated++;
            }
        }

        private void startEnemyTurnSim(Playfield p, bool simulateTwoTurns, bool print, bool playaround, int playaroundprob, int playaroundprob2)
        {
            if (p.guessingHeroHP >= 1)
            {
                //simulateEnemysTurn(simulateTwoTurns, playaround, print, pprob, pprob2);
                p.prepareNextTurn(p.isOwnTurn);

                Ai.Instance.enemySecondTurnSim[this.thread].simulateEnemysTurn(p, simulateTwoTurns, playaround, print, playaroundprob, playaroundprob2);
                /*
                if (p.turnCounter >= 2)
                    Ai.Instance.enemySecondTurnSim.simulateEnemysTurn(p, simulateTwoTurns, playaround, print, playaroundprob, playaroundprob2);
                else
                    Ai.Instance.enemyTurnSim.simulateEnemysTurn(p, simulateTwoTurns, playaround, print, playaroundprob, playaroundprob2);
                */
            }
            p.complete = true;
        }

        public float doallmoves(Playfield playf, bool isLethalCheck, bool print = false)
        {

            //todo only one time!
            this.doEnemySecondTurn = Settings.Instance.simEnemySecondTurn;
            int totalboards = Settings.Instance.nextTurnTotalBoards;
            int maxwide = Settings.Instance.nextTurnMaxWide;
            int maxdeep = Settings.Instance.nextTurnDeep;
            bool playaround = Settings.Instance.playarround;
            int playaroundprob = Settings.Instance.playaroundprob;
            int playaroundprob2 = Settings.Instance.playaroundprob2;


            //Helpfunctions.Instance.logg("NXTTRN" + playf.mana);
            if (botBase == null) botBase = Ai.Instance.botBase;
            bool test = false;
            this.posmoves.Clear();
            this.addToPosmoves(playf, totalboards);
            bool havedonesomething = true;
            List<Playfield> temp = new List<Playfield>();
            int deep = 0;
            //Helpfunctions.Instance.logg("NXTTRN" + playf.mana + " " + posmoves.Count);
            this.calculated = 0;
            while (havedonesomething)
            {
                //if (this.printNormalstuff) Helpfunctions.Instance.logg("ailoop");
                //GC.Collect();
                temp.Clear();
                temp.AddRange(this.posmoves);
                havedonesomething = false;
                Playfield bestold = null;
                float bestoldval = -20000000;
                foreach (Playfield p in temp)
                {

                    if (p.complete || p.ownHero.Hp <= 0)
                    {
                        continue;
                    }

                    List<Action> actions = movegen.getMoveList(p, isLethalCheck, usePenalityManager, useCutingTargets);
                    foreach (Action a in actions)
                    {
                        havedonesomething = true;
                        Playfield pf = new Playfield(p);
                        pf.doAction(a);
                        addToPosmoves(pf, totalboards);
                    }


                    if (isLethalCheck)
                    {
                        p.complete = true;
                    }
                    else
                    {
                        p.sEnemTurn = this.doEnemySecondTurn;
                        p.endTurn(this.simulateSecondTurn, playaround, false, playaroundprob, playaroundprob2);
                        this.startEnemyTurnSim(p, this.simulateSecondTurn, false, playaround, playaroundprob, playaroundprob2);
                    }

                    //sort stupid stuff ouf

                    if (botBase.getPlayfieldValue(p) > bestoldval)
                    {
                        bestoldval = botBase.getPlayfieldValue(p);
                        bestold = p;
                    }
                    if (!test)
                    {
                        posmoves.Remove(p);
                    }

                    if (this.calculated > totalboards) break;
                }

                if (!test && bestoldval >= -10000 && bestold != null)
                {
                    this.posmoves.Add(bestold);
                }

                //Helpfunctions.Instance.loggonoff(true);
                /*if (this.printNormalstuff)
                {
                    int donec = 0;
                    foreach (Playfield p in posmoves)
                    {
                        if (p.complete) donec++;
                    }
                    Helpfunctions.Instance.logg("deep " + deep + " len " + this.posmoves.Count + " dones " + donec);
                }*/

                if (!test)
                {
                    cuttingposibilities(maxwide);
                }

                //if (this.printNormalstuff) Helpfunctions.Instance.logg("cut to len " + this.posmoves.Count);
                //Helpfunctions.Instance.loggonoff(false);
                deep++;

                if (this.calculated > totalboards) break;
                if (deep >= maxdeep) break;//remove this?
            }

            foreach (Playfield p in posmoves)//temp
            {
                if (!p.complete)
                {
                    if (isLethalCheck)
                    {
                        p.complete = true;
                    }
                    else
                    {
                        p.sEnemTurn = this.doEnemySecondTurn;
                        p.endTurn(this.simulateSecondTurn, playaround, false, playaroundprob, playaroundprob2);
                        this.startEnemyTurnSim(p, this.simulateSecondTurn, false, playaround, playaroundprob, playaroundprob2);
                    }
                }
            }
            // Helpfunctions.Instance.logg("find best ");
            if (posmoves.Count >= 1)
            {
                float bestval = int.MinValue;
                int bestanzactions = 1000;
                Playfield bestplay = posmoves[0];//temp[0]
                foreach (Playfield p in posmoves)//temp
                {
                    float val = botBase.getPlayfieldValue(p);
                    if (bestval <= val)
                    {
                        if (bestval == val && bestanzactions < p.playactions.Count) continue;
                        bestplay = p;
                        bestval = val;
                        bestanzactions = p.playactions.Count;
                    }

                }
                this.bestboard = new Playfield(bestplay);

                if (print)
                {
                    Helpfunctions.Instance.ErrorLog("best board after your second turn (value included enemy second turn)----------");
                    bestplay.printBoard();
                    bestplay.value = int.MinValue;
                    bestplay.sEnemTurn = this.doEnemySecondTurn;
                    Ai.Instance.enemySecondTurnSim[this.thread].simulateEnemysTurn(bestplay, false, playaround, false, playaroundprob, playaroundprob2);
                    //Ai.Instance.enemySecondTurnSim.simulateEnemysTurn(bestplay, false, false, true, 100, 100); //dont play arround in enemys second turn

                }
                this.bestmove = bestplay.getNextAction();
                this.bestmoveValue = bestval;
                this.bestboard = new Playfield(bestplay);
                //Helpfunctions.Instance.logg("return");
                return bestval;
            }
            //Helpfunctions.Instance.logg("return");
            this.bestmove = null;
            this.bestmoveValue = -100000;
            this.bestboard = playf;
            return -10000;
        }

        public void cuttingposibilities(int maxwide)
        {
            // take the x best values
            List<Playfield> temp = new List<Playfield>();
            posmoves.Sort((a, b) => -(botBase.getPlayfieldValue(a)).CompareTo(botBase.getPlayfieldValue(b)));//want to keep the best

            if (this.useComparison)
            {
                int i = 0;
                int max = Math.Min(posmoves.Count, maxwide);

                Playfield p = null;
                Playfield pp = null;
                //foreach (Playfield p in posmoves)
                for (i = 0; i < max; i++)
                {
                    p = posmoves[i];
                    int hash = p.GetHashCode();
                    p.hashcode = hash;
                    bool found = false;
                    //foreach (Playfield pp in temp)
                    for (int j = 0; j < temp.Count; j++)
                    {
                        pp = temp[j];
                        if (pp.hashcode == p.hashcode)
                        {
                            if (pp.isEqualf(p))
                            {
                                found = true;
                                break;
                            }
                        }
                    }
                    if (!found) temp.Add(p);
                    //i++;
                    //if (i >= this.maxwide) break;

                }


            }
            else
            {
                temp.AddRange(posmoves);
            }
            posmoves.Clear();
            posmoves.AddRange(temp.GetRange(0, Math.Min(maxwide, temp.Count)));
            //posmoves.Clear();
            //posmoves.AddRange(Helpfunctions.TakeList(temp, takenumber));

        }

        public List<targett> cutAttackTargets(List<targett> oldlist, Playfield p, bool own)
        {
            List<targett> retvalues = new List<targett>();
            List<Minion> addedmins = new List<Minion>(8);

            bool priomins = false;
            List<targett> retvaluesPrio = new List<targett>();
            foreach (targett t in oldlist)
            {
                if ((own && t.target == 200) || (!own && t.target == 100))
                {
                    retvalues.Add(t);
                    continue;
                }
                if ((own && t.target >= 10 && t.target <= 19) || (!own && t.target >= 0 && t.target <= 9))
                {
                    Minion m = null;
                    if (own) m = p.enemyMinions[t.target - 10];
                    if (!own) m = p.ownMinions[t.target];
                    /*if (penman.priorityDatabase.ContainsKey(m.name))
                    {
                        //retvalues.Add(t);
                        retvaluesPrio.Add(t);
                        priomins = true;
                        //help.logg(m.name + " is added to targetlist");
                        continue;
                    }*/


                    bool goingtoadd = true;
                    List<Minion> temp = new List<Minion>(addedmins);
                    bool isSpecial = m.handcard.card.isSpecialMinion;
                    foreach (Minion mnn in temp)
                    {
                        // special minions are allowed to attack in silended and unsilenced state!
                        //help.logg(mnn.silenced + " " + m.silenced + " " + mnn.name + " " + m.name + " " + penman.specialMinions.ContainsKey(m.name));

                        bool otherisSpecial = mnn.handcard.card.isSpecialMinion;

                        if ((!isSpecial || (isSpecial && m.silenced)) && (!otherisSpecial || (otherisSpecial && mnn.silenced))) // both are not special, if they are the same, dont add
                        {
                            if (mnn.Angr == m.Angr && mnn.Hp == m.Hp && mnn.divineshild == m.divineshild && mnn.taunt == m.taunt && mnn.poisonous == m.poisonous) goingtoadd = false;
                            continue;
                        }

                        if (isSpecial == otherisSpecial && !m.silenced && !mnn.silenced) // same are special
                        {
                            if (m.name != mnn.name) // different name -> take it
                            {
                                continue;
                            }
                            // same name -> test whether they are equal
                            if (mnn.Angr == m.Angr && mnn.Hp == m.Hp && mnn.divineshild == m.divineshild && mnn.taunt == m.taunt && mnn.poisonous == m.poisonous) goingtoadd = false;
                            continue;
                        }

                    }

                    if (goingtoadd)
                    {
                        addedmins.Add(m);
                        retvalues.Add(t);
                        //help.logg(m.name + " " + m.id +" is added to targetlist");
                    }
                    else
                    {
                        //help.logg(m.name + " is not needed to attack");
                        continue;
                    }

                }
            }
            //help.logg("end targetcutting");
            if (priomins) return retvaluesPrio;

            return retvalues;
        }

        public void printPosmoves()
        {
            foreach (Playfield p in this.posmoves)
            {
                p.printBoard();
            }
        }

    }

    public class Movegenerator
    {
        PenalityManager pen = PenalityManager.Instance;

        private static Movegenerator instance;

        public static Movegenerator Instance
        {
            get
            {
                return instance ?? (instance = new Movegenerator());
            }
        }

        private Movegenerator()
        {
        }


        public List<Action> doAllChoices(Playfield p, Handmanager.Handcard hc, bool lethalcheck, bool usePenalityManager)
        {
            List<Action> returnlist = new List<Action>();

            if (hc.card.type == CardDB.cardtype.MOB && p.ownMinions.Count >= 7) return returnlist;

            for (int i = 1; i < 3; i++)
            {
                CardDB.Card c = hc.card;
                if (c.name == CardDB.cardName.keeperofthegrove)
                {
                    if (i == 1)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_166a);
                    }
                    if (i == 2)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_166b);
                    }
                }

                if (c.name == CardDB.cardName.starfall)
                {
                    if (i == 1)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.NEW1_007b);
                    }
                    if (i == 2)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.NEW1_007a);
                    }
                }

                if (c.name == CardDB.cardName.ancientoflore)
                {
                    if (i == 1)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.NEW1_008a);
                    }
                    if (i == 2)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.NEW1_008b);
                    }
                }

                if (c.name == CardDB.cardName.powerofthewild)
                {
                    if (i == 1)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_160b);
                    }
                    if (i == 2)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_160a);
                    }
                }
                if (c.name == CardDB.cardName.ancientofwar)
                {

                    if (i == 1)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_178a);
                    }
                    if (i == 2)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_178b);
                    }
                }
                if (c.name == CardDB.cardName.druidoftheclaw)
                {
                    if (i == 1)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_165t1);
                    }
                    if (i == 2)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_165t2);
                    }
                }
                //cenarius dont need
                if (c.name == CardDB.cardName.keeperofthegrove)//keeper of the grove
                {

                    if (i == 1)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_166a);
                    }
                    if (i == 2)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_166b);
                    }
                }
                if (c.name == CardDB.cardName.markofnature)
                {
                    if (i == 1)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_155a);
                    }
                    if (i == 2)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_155b);
                    }
                }
                if (c.name == CardDB.cardName.nourish)
                {
                    if (i == 1)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_164a);
                    }
                    if (i == 2)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_164b);
                    }
                }
                if (c.name == CardDB.cardName.wrath)
                {
                    if (i == 1)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_154a);
                    }
                    if (i == 2)
                    {
                        c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_154b);
                    }
                }

                if (c.canplayCard(p, hc.manacost))
                {

                    int bestplace = p.getBestPlace(c, lethalcheck);
                    List<Minion> trgts = c.getTargetsForCard(p);
                    int cardplayPenality = 0;
                    if (trgts.Count == 0)
                    {


                        if (usePenalityManager)
                        {
                            cardplayPenality = pen.getPlayCardPenality(hc.card, null, p, i, lethalcheck);
                            if (cardplayPenality <= 499)
                            {
                                //help.logg(hc.card.name + " is played");
                                //pf.playCard(hc, hc.position - 1, hc.entity, -1, -1, i, bestplace, cardplayPenality);
                                // i is the choice
                                Action a = new Action(actionEnum.playcard, hc, null, bestplace, null, cardplayPenality, i);
                                //pf.playCard(hc, hc.position - 1, hc.entity, -1, -1, 0, bestplace, cardplayPenality);
                                returnlist.Add(a);
                            }
                        }
                        else
                        {
                            //pf.playCard(hc, hc.position - 1, hc.entity, -1, -1, i, bestplace, cardplayPenality);

                            Action a = new Action(actionEnum.playcard, hc, null, bestplace, null, cardplayPenality, i);
                            returnlist.Add(a);
                        }

                    }
                    else
                    {
                        foreach (Minion trgt in trgts)
                        {

                            if (usePenalityManager)
                            {
                                cardplayPenality = pen.getPlayCardPenality(hc.card, trgt, p, i, lethalcheck);

                                if (cardplayPenality <= 499)
                                {
                                    //help.logg(hc.card.name + " is played");
                                    //pf.playCard(hc, hc.position - 1, hc.entity, trgt.target, trgt.targetEntity, i, bestplace, cardplayPenality);

                                    Action a = new Action(actionEnum.playcard, hc, null, bestplace, trgt, cardplayPenality, i); //i is the choice
                                    returnlist.Add(a);
                                }
                            }
                            else
                            {
                                //pf.playCard(hc, hc.position - 1, hc.entity, trgt.target, trgt.targetEntity, i, bestplace, cardplayPenality);

                                Action a = new Action(actionEnum.playcard, hc, null, bestplace, trgt, cardplayPenality, i); //i is the choice
                                returnlist.Add(a);
                            }

                        }
                    }

                }

            }


            return returnlist;
        }

        public List<Action> getMoveList(Playfield p, bool isLethalCheck, bool usePenalityManager, bool useCutingTargets)
        {
            //generates only own moves

            List<Action> ret = new List<Action>();

            if (p.complete || p.ownHero.Hp <= 0)
            {
                return ret;
            }

            //play cards:

            List<CardDB.cardName> playedcards = new List<CardDB.cardName>();

            bool superplacement = false;
            bool useplacement = Settings.Instance.simulatePlacement && p.turnCounter == 0 && p.ownMinions.Count >= 2;
            foreach (Minion hc in p.ownMinions)
            {
                if (hc.handcard.card.name == CardDB.cardName.direwolfalpha || hc.handcard.card.name == CardDB.cardName.flametonguetotem || hc.handcard.card.name == CardDB.cardName.defenderofargus)
                {
                    superplacement = true;
                    break;
                }

            }

            foreach (Handmanager.Handcard hc in p.owncards)
            {
                CardDB.Card c = hc.card;
                //help.logg("try play crd" + c.name + " " + c.getManaCost(p) + " " + c.canplayCard(p));
                if (playedcards.Contains(c.name)) continue; // dont play the same card in one loop
                playedcards.Add(c.name);

                if (c.choice)
                {
                    ret.AddRange(this.doAllChoices(p, hc, isLethalCheck, usePenalityManager));
                }
                else
                {
                    int bestplace = p.getBestPlace(c, isLethalCheck);
                    if (hc.canplayCard(p))
                    {
                        List<Minion> trgts = c.getTargetsForCard(p);

                        if (isLethalCheck && trgts.Count >= 1 && (c.damagesTarget || c.damagesTargetWithSpecial))// only target enemy hero during Lethal check!
                        {
                            if (trgts.Count >= 1 && trgts[0].isHero && !trgts[0].own) // first minion is enemy hero (or he is not in list)
                            {
                                trgts.Clear();
                                trgts.Add(p.enemyHero);
                            }
                            else
                            {
                                // no enemy hero -> enemy have taunts ->kill the taunts from left to right
                                if (trgts.Count >= 1)
                                {
                                    Minion trg = trgts[0];
                                    trgts.Clear();
                                    trgts.Add(trg);
                                }
                            }
                        }


                        int cardplayPenality = 0;

                        if (trgts.Count == 0)
                        {


                            if (usePenalityManager)
                            {
                                cardplayPenality = pen.getPlayCardPenality(c, null, p, 0, isLethalCheck);
                                if (cardplayPenality <= 499)
                                {

                                    if (useplacement && ((hc.card.name == CardDB.cardName.direwolfalpha || hc.card.name == CardDB.cardName.flametonguetotem || hc.card.name == CardDB.cardName.defenderofargus) || (superplacement && hc.card.type == CardDB.cardtype.MOB)))
                                    {
                                        int adding = 1;
                                        int subbing = 0;
                                        if (hc.card.name == CardDB.cardName.direwolfalpha || hc.card.name == CardDB.cardName.flametonguetotem)//|| hc.card.name == CardDB.cardName.defenderofargus)
                                        {
                                            adding = 2;
                                            subbing = 2;
                                        }
                                        for (int placer = 0; placer < p.ownMinions.Count - subbing; placer++)
                                        {
                                            Action a = new Action(actionEnum.playcard, hc, null, placer + adding, null, cardplayPenality, 0);
                                            //Helpfunctions.Instance.ErrorLog("place " +hc.card.name + " on pos " + (placer+adding) + " mincount " + p.ownMinions.Count);
                                            //pf.playCard(hc, hc.position - 1, hc.entity, -1, -1, 0, bestplace, cardplayPenality);
                                            ret.Add(a);
                                        }
                                    }
                                    else
                                    {
                                        Action a = new Action(actionEnum.playcard, hc, null, bestplace, null, cardplayPenality, 0);
                                        //pf.playCard(hc, hc.position - 1, hc.entity, -1, -1, 0, bestplace, cardplayPenality);
                                        ret.Add(a);
                                    }
                                }
                            }
                            else
                            {
                                Action a = new Action(actionEnum.playcard, hc, null, bestplace, null, cardplayPenality, 0);
                                //pf.playCard(hc, hc.position - 1, hc.entity, -1, -1, 0, bestplace, cardplayPenality);
                                ret.Add(a);
                            }


                        }
                        else
                        {

                            foreach (Minion trgt in trgts)
                            {


                                if (usePenalityManager)
                                {
                                    cardplayPenality = pen.getPlayCardPenality(c, trgt, p, 0, isLethalCheck);
                                    if (cardplayPenality <= 499)
                                    {
                                        //pf.playCard(hc, hc.position - 1, hc.entity, trgt.target, trgt.targetEntity, 0, bestplace, cardplayPenality);
                                        Action a = new Action(actionEnum.playcard, hc, null, bestplace, trgt, cardplayPenality, 0);
                                        ret.Add(a);

                                    }
                                }
                                else
                                {

                                    //pf.playCard(hc, hc.position - 1, hc.entity, trgt.target, trgt.targetEntity, 0, bestplace, cardplayPenality);
                                    Action a = new Action(actionEnum.playcard, hc, null, bestplace, trgt, cardplayPenality, 0);
                                    ret.Add(a);
                                }

                            }

                        }


                    }
                }
            }

            // attack with minions ###############################################################################################################

            List<Minion> playedMinions = new List<Minion>(8);
            bool attackordermatters = this.didAttackOrderMatters(p);
            foreach (Minion m in p.ownMinions)
            {

                if (m.Ready && m.Angr >= 1 && !m.frozen)
                {
                    //BEGIN:cut (double/similar) attacking minions out#####################################
                    // DONT LET SIMMILAR MINIONS ATTACK IN ONE TURN (example 3 unlesh the hounds-hounds doesnt need to simulated hole)
                    if (attackordermatters)
                    {
                        List<Minion> tempoo = new List<Minion>(playedMinions);
                        bool dontattacked = true;
                        bool isSpecial = m.handcard.card.isSpecialMinion;
                        foreach (Minion mnn in tempoo)
                        {
                            // special minions are allowed to attack in silended and unsilenced state!
                            //help.logg(mnn.silenced + " " + m.silenced + " " + mnn.name + " " + m.name + " " + penman.specialMinions.ContainsKey(m.name));

                            bool otherisSpecial = mnn.handcard.card.isSpecialMinion;

                            if ((!isSpecial || (isSpecial && m.silenced)) && (!otherisSpecial || (otherisSpecial && mnn.silenced))) // both are not special, if they are the same, dont add
                            {
                                if (mnn.Angr == m.Angr && mnn.Hp == m.Hp && mnn.divineshild == m.divineshild && mnn.taunt == m.taunt && mnn.poisonous == m.poisonous) dontattacked = false;
                                continue;
                            }

                            if (isSpecial == otherisSpecial && !m.silenced && !mnn.silenced) // same are special
                            {
                                if (m.name != mnn.name) // different name -> take it
                                {
                                    continue;
                                }
                                // same name -> test whether they are equal
                                if (mnn.Angr == m.Angr && mnn.Hp == m.Hp && mnn.divineshild == m.divineshild && mnn.taunt == m.taunt && mnn.poisonous == m.poisonous) dontattacked = false;
                                continue;
                            }

                        }


                        if (dontattacked)
                        {
                            playedMinions.Add(m);
                        }
                        else
                        {
                            //help.logg(m.name + " doesnt need to attack!");
                            continue;
                        }
                    }
                    //END: cut (double/similar) attacking minions out#####################################

                    //help.logg(m.name + " is going to attack!");
                    List<Minion> trgts = p.getAttackTargets(true);


                    if (isLethalCheck)// only target enemy hero during Lethal check!
                    {
                        if (trgts.Count >= 1 && trgts[0].isHero) // first minion is always hero if existent
                        {
                            trgts.Clear();
                            trgts.Add(p.enemyHero);
                        }
                        else
                        {
                            // no enemy hero -> enemy have taunts ->kill the taunts from left to right
                            if (trgts.Count >= 1)
                            {
                                Minion trg = trgts[0];
                                trgts.Clear();
                                trgts.Add(trg);
                            }
                        }
                    }
                    else
                    {
                        if (useCutingTargets) trgts = this.cutAttackTargets(trgts, p, true);
                    }

                    foreach (Minion trgt in trgts)
                    {


                        int attackPenality = 0;

                        if (usePenalityManager)
                        {
                            attackPenality = pen.getAttackWithMininonPenality(m, p, trgt, isLethalCheck);
                            if (attackPenality <= 499)
                            {
                                //pf.attackWithMinion(m, trgt.target, trgt.targetEntity, attackPenality);

                                Action a = new Action(actionEnum.attackWithMinion, null, m, 0, trgt, attackPenality, 0);
                                ret.Add(a);
                            }
                        }
                        else
                        {
                            //pf.attackWithMinion(m, trgt.target, trgt.targetEntity, attackPenality);
                            Action a = new Action(actionEnum.attackWithMinion, null, m, 0, trgt, attackPenality, 0);
                            ret.Add(a);

                        }


                    }
                    if ((!m.stealth || isLethalCheck) && p.enemySecretCount == 0 && trgts.Count == 1 && trgts[0].isHero)//only enemy hero is available als attack
                    {
                        break;
                    }

                    if (!attackordermatters) break;
                }

            }


            // attack with hero
            if (p.ownHero.Ready && p.ownHero.Angr >= 1)
            {
                List<Minion> trgts = p.getAttackTargets(true);

                if (isLethalCheck)// only target enemy hero during Lethal check!
                {
                    if (trgts.Count >= 1 && trgts[0].isHero && !trgts[0].own)
                    {
                        trgts.Clear();
                        trgts.Add(p.enemyHero);
                    }
                    else
                    {
                        // no enemy hero -> enemy have taunts ->kill the taunts from left to right
                        if (trgts.Count >= 1)
                        {
                            Minion trg = trgts[0];
                            trgts.Clear();
                            trgts.Add(trg);
                        }
                    }
                }
                else
                {
                    if (useCutingTargets) trgts = this.cutAttackTargets(trgts, p, true);
                }

                foreach (Minion trgt in trgts)
                {
                    int heroAttackPen = 0;
                    if (usePenalityManager)
                    {
                        heroAttackPen = pen.getAttackWithHeroPenality(trgt, p, isLethalCheck);
                    }
                    //pf.attackWithWeapon(trgt.target, trgt.targetEntity, heroAttackPen);
                    Action a = new Action(actionEnum.attackWithHero, null, p.ownHero, 0, trgt, heroAttackPen, 0);
                    ret.Add(a);

                }
            }

            // use ability
            /// TODO check if ready after manaup
            if (p.ownAbilityReady && p.mana >= 2 && p.ownHeroAblility.card.canplayCard(p, 2))
            {
                int abilityPenality = 0;
                // if we have mage or priest, we have to target something####################################################
                if (p.ownHeroAblility.card.cardIDenum == CardDB.cardIDEnum.CS2_034 || p.ownHeroAblility.card.cardIDenum == CardDB.cardIDEnum.CS1h_001 || p.ownHeroAblility.card.cardIDenum == CardDB.cardIDEnum.EX1_625t || p.ownHeroAblility.card.cardIDenum == CardDB.cardIDEnum.EX1_625t2 || p.ownHeroAblility.card.cardIDenum == CardDB.cardIDEnum.DS1h_292)
                {
                    List<Minion> trgts = p.ownHeroAblility.card.getTargetsForCard(p);
                    if (isLethalCheck && (p.ownHeroName == HeroEnum.mage || (p.ownHeroName == HeroEnum.priest && (p.ownHeroAblility.card.name != CardDB.cardName.lesserheal || (p.ownHeroAblility.card.name == CardDB.cardName.lesserheal && p.anzOwnAuchenaiSoulpriest >= 1)))))// only target enemy hero during Lethal check!
                    {
                        if (trgts.Count >= 1 && trgts[0].entitiyID == p.enemyHero.entitiyID)
                        {
                            trgts.Clear();
                            trgts.Add(p.enemyHero);
                        }
                        else
                        {
                            // no enemy hero -> enemy have taunts ->kill the taunts from left to right
                            if (trgts.Count >= 1)
                            {
                                Minion trg = trgts[0];
                                trgts.Clear();
                                trgts.Add(trg);
                            }
                        }
                    }

                    foreach (Minion trgt in trgts)
                    {



                        if (usePenalityManager)
                        {
                            abilityPenality = pen.getPlayCardPenality(p.ownHeroAblility.card, trgt, p, 0, isLethalCheck);
                            if (abilityPenality <= 499)
                            {
                                //pf.activateAbility(p.ownHeroAblility, trgt.target, trgt.targetEntity, abilityPenality);
                                Action a = new Action(actionEnum.useHeroPower, p.ownHeroAblility, null, 0, trgt, abilityPenality, 0);
                                ret.Add(a);
                            }
                        }
                        else
                        {
                            //pf.activateAbility(p.ownHeroAblility, trgt.target, trgt.targetEntity, abilityPenality);
                            Action a = new Action(actionEnum.useHeroPower, p.ownHeroAblility, null, 0, trgt, abilityPenality, 0);
                            ret.Add(a);
                        }

                    }
                }
                else
                {
                    // the other classes dont have to target####################################################
                    //Playfield pf = new Playfield(p);

                    if (usePenalityManager)
                    {
                        abilityPenality = pen.getPlayCardPenality(p.ownHeroAblility.card, null, p, 0, isLethalCheck);
                        if (abilityPenality <= 499)
                        {
                            //havedonesomething = true;
                            //pf.activateAbility(p.ownHeroAblility, -1, -1, abilityPenality);
                            Action a = new Action(actionEnum.useHeroPower, p.ownHeroAblility, null, 0, null, abilityPenality, 0);
                            ret.Add(a);
                        }
                    }
                    else
                    {
                        //havedonesomething = true;
                        //pf.activateAbility(p.ownHeroAblility, -1, -1, abilityPenality);
                        Action a = new Action(actionEnum.useHeroPower, p.ownHeroAblility, null, 0, null, abilityPenality, 0);
                        ret.Add(a);
                    }

                }

            }



            return ret;
        }

        //turndeep = progress of current players turn
        public List<Action> getEnemyMoveList(Playfield p, bool isLethalCheck, bool usePenalityManager, bool useCutingTargets, int turndeep)
        {
            //generates only own moves

            List<Action> ret = new List<Action>();

            if (p.complete || p.ownHero.Hp <= 0)
            {
                return ret;
            }


            //if he can use ability use it on his turnstart or never!###########################################################################################
            if (turndeep == 0 && p.enemyAbilityReady && p.mana >= 2 && p.enemyHeroAblility.card.canplayCard(p, 0) && !p.loatheb)
            {
                int abilityPenality = 0;

                // if we have mage or priest, we have to target something####################################################
                if (p.enemyHeroName == HeroEnum.mage || p.enemyHeroName == HeroEnum.priest)
                {
                    List<Minion> trgts = p.enemyHeroAblility.card.getTargetsForCardEnemy(p);
                    foreach (Minion trgt in trgts)
                    {
                        if (trgt.isHero) continue;//dont target hero
                        Action a = new Action(actionEnum.useHeroPower, null, null, 0, trgt, abilityPenality, 0);
                        ret.Add(a);
                    }
                }
                else
                {
                    // the other classes dont have to target####################################################
                    Action a = new Action(actionEnum.useHeroPower, null, null, 0, null, abilityPenality, 0);
                    ret.Add(a);
                }
                return ret;
            }


            // attack with minions ###############################################################################################################

            List<Minion> playedMinions = new List<Minion>(8);
            bool attackordermatters = this.didAttackOrderMatters(p);

            foreach (Minion m in p.enemyMinions)
            {

                if (m.Ready && m.Angr >= 1 && !m.frozen)
                {
                    //BEGIN:cut (double/similar) attacking minions out#####################################
                    // DONT LET SIMMILAR MINIONS ATTACK IN ONE TURN (example 3 unlesh the hounds-hounds doesnt need to simulated hole)
                    if (attackordermatters)
                    {
                        List<Minion> tempoo = new List<Minion>(playedMinions);
                        bool dontattacked = true;
                        bool isSpecial = m.handcard.card.isSpecialMinion;
                        foreach (Minion mnn in tempoo)
                        {
                            // special minions are allowed to attack in silended and unsilenced state!
                            //help.logg(mnn.silenced + " " + m.silenced + " " + mnn.name + " " + m.name + " " + penman.specialMinions.ContainsKey(m.name));

                            bool otherisSpecial = mnn.handcard.card.isSpecialMinion;

                            if ((!isSpecial || (isSpecial && m.silenced)) && (!otherisSpecial || (otherisSpecial && mnn.silenced))) // both are not special, if they are the same, dont add
                            {
                                if (mnn.Angr == m.Angr && mnn.Hp == m.Hp && mnn.divineshild == m.divineshild && mnn.taunt == m.taunt && mnn.poisonous == m.poisonous) dontattacked = false;
                                continue;
                            }

                            if (isSpecial == otherisSpecial && !m.silenced && !mnn.silenced) // same are special
                            {
                                if (m.name != mnn.name) // different name -> take it
                                {
                                    continue;
                                }
                                // same name -> test whether they are equal
                                if (mnn.Angr == m.Angr && mnn.Hp == m.Hp && mnn.divineshild == m.divineshild && mnn.taunt == m.taunt && mnn.poisonous == m.poisonous) dontattacked = false;
                                continue;
                            }

                        }

                        if (dontattacked)
                        {
                            playedMinions.Add(m);
                        }
                        else
                        {
                            //help.logg(m.name + " doesnt need to attack!");
                            continue;
                        }
                    }
                    //END: cut (double/similar) attacking minions out#####################################

                    //help.logg(m.name + " is going to attack!");
                    List<Minion> trgts = p.getAttackTargets(false);

                    if (useCutingTargets) trgts = this.cutAttackTargets(trgts, p, false);

                    foreach (Minion trgt in trgts)
                    {
                        Action a = new Action(actionEnum.attackWithMinion, null, m, 0, trgt, this.pen.getAttackWithMininonPenality(m, p, trgt, false), 0);
                        ret.Add(a);
                    }


                    if ((!m.stealth) && trgts.Count == 1 && trgts[0].isHero)//only enemy hero is available als attack
                    {
                        break;
                    }
                    if (!attackordermatters) break;
                }


            }


            // attack with hero
            if (p.enemyHero.Ready && p.enemyHero.Angr >= 1)
            {
                List<Minion> trgts = p.getAttackTargets(false);

                if (useCutingTargets) trgts = this.cutAttackTargets(trgts, p, false);

                foreach (Minion trgt in trgts)
                {
                    //pf.attackWithWeapon(trgt.target, trgt.targetEntity, heroAttackPen);
                    Action a = new Action(actionEnum.attackWithHero, null, p.enemyHero, 0, trgt, 0, 0);
                    ret.Add(a);
                }
            }



            return ret;
        }

        public List<Minion> cutAttackTargets(List<Minion> oldlist, Playfield p, bool own)
        {
            //sorts out attack targets (minion + hero attack)
            oldlist.Sort((a, b) => -(a.Hp.CompareTo(b.Hp)));
            List<Minion> retvalues = new List<Minion>(oldlist.Count);
            List<Minion> addedmins = new List<Minion>(oldlist.Count);

            foreach (Minion m in oldlist)
            {
                if (m.isHero)
                {
                    retvalues.Add(m);
                    continue;
                }
                if (true)
                {

                    bool goingtoadd = true;
                    bool isSpecial = m.handcard.card.isSpecialMinion;
                    foreach (Minion mnn in addedmins)
                    {
                        // special minions are allowed to attack in silended and unsilenced state!
                        //help.logg(mnn.silenced + " " + m.silenced + " " + mnn.name + " " + m.name + " " + penman.specialMinions.ContainsKey(m.name));

                        bool otherisSpecial = mnn.handcard.card.isSpecialMinion;

                        if ((!isSpecial || (isSpecial && m.silenced)) && (!otherisSpecial || (otherisSpecial && mnn.silenced))) // both are not special, if they are the same, dont add
                        {
                            if (mnn.Angr == m.Angr && mnn.Hp <= m.Hp && mnn.divineshild == m.divineshild && mnn.taunt == m.taunt && mnn.poisonous == m.poisonous && m.handcard.card.isToken == mnn.handcard.card.isToken) goingtoadd = false;
                            continue;
                        }

                        if (isSpecial == otherisSpecial && !m.silenced && !mnn.silenced) // same are special
                        {
                            if (m.name != mnn.name) // different name -> take it
                            {
                                continue;
                            }
                            // same name -> test whether they are equal
                            if (mnn.Angr == m.Angr && mnn.Hp == m.Hp && mnn.divineshild == m.divineshild && mnn.taunt == m.taunt && mnn.poisonous == m.poisonous && m.handcard.card.isToken == mnn.handcard.card.isToken) goingtoadd = false;
                            continue;
                        }

                    }

                    if (goingtoadd)
                    {
                        addedmins.Add(m);
                        retvalues.Add(m);
                        //help.logg(m.name + " " + m.id +" is added to targetlist");
                    }
                    else
                    {
                        //help.logg(m.name + " is not needed to attack");
                        continue;
                    }

                }
            }
            //help.logg("end targetcutting");

            return retvalues;
        }

        public bool didAttackOrderMatters(Playfield p)
        {
            //return true;
            if (p.isOwnTurn)
            {
                if (p.enemySecretCount >= 1) return true;
                if (p.enemyHero.immune) return true;

            }
            else
            {
                if (p.ownHero.immune) return true;
            }
            List<Minion> enemym = (p.isOwnTurn) ? p.enemyMinions : p.ownMinions;
            List<Minion> ownm = (p.isOwnTurn) ? p.ownMinions : p.enemyMinions;

            int strongestAttack = 0;
            foreach (Minion m in enemym)
            {
                if (m.Angr > strongestAttack) strongestAttack = m.Angr;
                if (m.taunt) return true;
                if (m.name == CardDB.cardName.dancingswords || m.name == CardDB.cardName.deathlord) return true;
            }

            int haspets = 0;
            bool hashyena = false;
            bool hasJuggler = false;
            bool spawnminions = false;
            foreach (Minion m in ownm)
            {
                if (m.name == CardDB.cardName.cultmaster) return true;
                if (m.name == CardDB.cardName.knifejuggler) hasJuggler = true;
                if (m.Ready && m.Angr >= 1)
                {
                    if (m.AdjacentAngr >= 1) return true;//wolphalfa or flametongue is in play
                    if (m.name == CardDB.cardName.northshirecleric) return true;
                    if (m.name == CardDB.cardName.armorsmith) return true;
                    if (m.name == CardDB.cardName.loothoarder) return true;
                    //if (m.name == CardDB.cardName.madscientist) return true; // dont change the tactic
                    if (m.name == CardDB.cardName.sylvanaswindrunner) return true;
                    if (m.name == CardDB.cardName.darkcultist) return true;
                    if (m.ownBlessingOfWisdom >= 1) return true;
                    if (m.name == CardDB.cardName.acolyteofpain) return true;
                    if (m.name == CardDB.cardName.frothingberserker) return true;
                    if (m.name == CardDB.cardName.flesheatingghoul) return true;
                    if (m.name == CardDB.cardName.bloodmagethalnos) return true;
                    if (m.name == CardDB.cardName.webspinner) return true;
                    if (m.name == CardDB.cardName.tirionfordring) return true;
                    if (m.name == CardDB.cardName.baronrivendare) return true;


                    //if (m.name == CardDB.cardName.manawraith) return true;
                    //buffing minions (attack with them last)
                    if (m.name == CardDB.cardName.raidleader || m.name == CardDB.cardName.stormwindchampion || m.name == CardDB.cardName.timberwolf || m.name == CardDB.cardName.southseacaptain || m.name == CardDB.cardName.murlocwarleader || m.name == CardDB.cardName.grimscaleoracle || m.name == CardDB.cardName.leokk) return true;


                    if (m.name == CardDB.cardName.scavenginghyena) hashyena = true;
                    if (m.handcard.card.race == 20) haspets++;
                    if (m.name == CardDB.cardName.harvestgolem || m.name == CardDB.cardName.hauntedcreeper || m.souloftheforest >= 1 || m.ancestralspirit >= 1 || m.name == CardDB.cardName.nerubianegg || m.name == CardDB.cardName.savannahhighmane || m.name == CardDB.cardName.sludgebelcher || m.name == CardDB.cardName.cairnebloodhoof || m.name == CardDB.cardName.feugen || m.name == CardDB.cardName.stalagg || m.name == CardDB.cardName.thebeast) spawnminions = true;

                }
            }

            if (haspets >= 1 && hashyena) return true;
            if (hasJuggler && spawnminions) return true;




            return false;
        }
    }

    public class Handmanager
    {

        public class Handcard
        {
            public int position = 0;
            public int entity = -1;
            public int manacost = 1000;
            public int addattack = 0;
            public int addHp = 0;
            public CardDB.Card card;

            public Handcard()
            {
                card = CardDB.Instance.unknownCard;
            }
            public Handcard(Handcard hc)
            {
                this.position = hc.position;
                this.entity = hc.entity;
                this.manacost = hc.manacost;
                this.card = hc.card;
                this.addattack = hc.addattack;
                this.addHp = hc.addHp;
            }
            public Handcard(CardDB.Card c)
            {
                this.position = 0;
                this.entity = -1;
                this.card = c;
                this.addattack = 0;
                this.addHp = 0;
            }
            public int getManaCost(Playfield p)
            {
                return this.card.getManaCost(p, this.manacost);
            }
            public bool canplayCard(Playfield p)
            {
                return this.card.canplayCard(p, this.manacost);
            }
        }

        public List<Handcard> handCards = new List<Handcard>();

        public int anzcards = 0;

        public int enemyAnzCards = 0;

        private int ownPlayerController = 0;

        Helpfunctions help;
        CardDB cdb = CardDB.Instance;

        private static Handmanager instance;

        public static Handmanager Instance
        {
            get
            {
                return instance ?? (instance = new Handmanager());
            }
        }


        private Handmanager()
        {
            this.help = Helpfunctions.Instance;

        }

        public void clearAll()
        {
            this.handCards.Clear();
            this.anzcards = 0;
            this.enemyAnzCards = 0;
            this.ownPlayerController = 0;
        }

        public void setOwnPlayer(int player)
        {
            this.ownPlayerController = player;
        }




        public void setHandcards(List<Handcard> hc, int anzown, int anzenemy)
        {
            this.handCards.Clear();
            foreach (Handcard h in hc)
            {
                this.handCards.Add(new Handcard(h));
            }
            //this.handCards.AddRange(hc);
            this.handCards.Sort((a, b) => a.position.CompareTo(b.position));
            this.anzcards = anzown;
            this.enemyAnzCards = anzenemy;
        }


        public void printcards(bool writeTobuffer = false)
        {
            help.logg("Own Handcards: ");
            foreach (Handmanager.Handcard c in this.handCards)
            {
                help.logg("pos " + c.position + " " + c.card.name + " " + c.manacost + " entity " + c.entity + " " + c.card.cardIDenum + " " + c.addattack);
            }
            help.logg("Enemy cards: " + this.enemyAnzCards);

            //todo print died minions this turn!

            /*if(Ai.Instance.playaround)
            {
                if(Hrtprozis.Instance.enemyHeroname == HeroEnum.mage)
                {
                    help.logg("probs: "  + Probabilitymaker.Instance.anzCardsInDeck(CardDB.cardIDEnum.CS2_032) + " " + Probabilitymaker.Instance.anzCardsInDeck(CardDB.cardIDEnum.CS2_028));
                }

                if (Hrtprozis.Instance.enemyHeroname == HeroEnum.warrior)
                {
                    help.logg("probs: "  + Probabilitymaker.Instance.anzCardsInDeck(CardDB.cardIDEnum.EX1_400));
                }

                if (Hrtprozis.Instance.enemyHeroname == HeroEnum.hunter)
                {
                    help.logg("probs: "  + Probabilitymaker.Instance.anzCardsInDeck(CardDB.cardIDEnum.EX1_538));
                }

                if (Hrtprozis.Instance.enemyHeroname == HeroEnum.priest)
                {
                    help.logg("probs: "  + Probabilitymaker.Instance.anzCardsInDeck(CardDB.cardIDEnum.CS1_112));
                }

                if (Hrtprozis.Instance.enemyHeroname == HeroEnum.shaman)
                {
                    help.logg("probs: "  + Probabilitymaker.Instance.anzCardsInDeck(CardDB.cardIDEnum.EX1_259));
                }

                if (Hrtprozis.Instance.enemyHeroname == HeroEnum.pala)
                {
                    help.logg("probs: "  + Probabilitymaker.Instance.anzCardsInDeck(CardDB.cardIDEnum.CS2_093));
                }

                if (Hrtprozis.Instance.enemyHeroname == HeroEnum.druid)
                {
                    help.logg("probs: "  + Probabilitymaker.Instance.anzCardsInDeck(CardDB.cardIDEnum.CS2_012));
                }
            }*/

            if (writeTobuffer)
            {
                help.writeToBuffer("Own Handcards: ");
                foreach (Handmanager.Handcard c in this.handCards)
                {
                    help.writeToBuffer("pos " + c.position + " " + c.card.name + " " + c.manacost + " entity " + c.entity + " " + c.card.cardIDenum + " " + c.addattack);
                }
                help.writeToBuffer("Enemy cards: " + this.enemyAnzCards);

                //todo print died minions this turn!

            }
        }


    }

    public enum HeroEnum
    {
        None,
        druid,
        hogger,
        hunter,
        priest,
        warlock,
        thief,
        pala,
        warrior,
        shaman,
        mage,
        lordjaraxxus
    }

    public class Hrtprozis
    {


        public int attackFaceHp = 15;
        public int ownHeroFatigue = 0;
        public int ownDeckSize = 30;
        public int enemyDeckSize = 30;
        public int enemyHeroFatigue = 0;

        public int ownHeroEntity = -1;
        public int enemyHeroEntitiy = -1;
        public DateTime roundstart = DateTime.Now;
        public int currentMana = 0;

        public int heroHp = 30, enemyHp = 30;
        public int heroAtk = 0, enemyAtk = 0;
        public int heroDefence = 0, enemyDefence = 0;
        public bool ownheroisread = false;
        public int ownHeroNumAttacksThisTurn = 0;
        public bool ownHeroWindfury = false;
        public bool herofrozen = false;
        public bool enemyfrozen = false;

        public List<CardDB.cardIDEnum> ownSecretList = new List<CardDB.cardIDEnum>();
        public int enemySecretCount = 0;



        public HeroEnum heroname = HeroEnum.druid, enemyHeroname = HeroEnum.druid;
        public CardDB.Card heroAbility;
        public bool ownAbilityisReady = false;
        public CardDB.Card enemyAbility;
        public int numOptionsPlayedThisTurn = 0;
        public int numMinionsPlayedThisTurn = 0;

        public int cardsPlayedThisTurn = 0;
        public int ueberladung = 0;

        public int ownMaxMana = 0;
        public int enemyMaxMana = 0;

        public int enemyWeaponDurability = 0;
        public int enemyWeaponAttack = 0;
        public CardDB.cardName enemyHeroWeapon = CardDB.cardName.unknown;

        public int heroWeaponDurability = 0;
        public int heroWeaponAttack = 0;
        public CardDB.cardName ownHeroWeapon = CardDB.cardName.unknown;

        public bool heroImmuneToDamageWhileAttacking = false;
        public bool heroImmune = false;
        public bool enemyHeroImmune = false;


        public List<Minion> ownMinions = new List<Minion>();
        public List<Minion> enemyMinions = new List<Minion>();
        public Minion ownHero = new Minion();
        public Minion enemyHero = new Minion();

        Helpfunctions help = Helpfunctions.Instance;
        //Imagecomparer icom = Imagecomparer.Instance;
        //HrtNumbers hrtnumbers = HrtNumbers.Instance;
        CardDB cdb = CardDB.Instance;

        private int ownPlayerController = 0;

        private static Hrtprozis instance;

        public static Hrtprozis Instance
        {
            get
            {
                return instance ?? (instance = new Hrtprozis());
            }
        }



        private Hrtprozis()
        {
        }

        public void setAttackFaceHP(int hp)
        {
            this.attackFaceHp = hp;
        }

        public void clearAll()
        {
            ownHeroEntity = -1;
            enemyHeroEntitiy = -1;
            currentMana = 0;
            heroHp = 30;
            enemyHp = 30;
            heroAtk = 0;
            enemyAtk = 0;
            heroDefence = 0; enemyDefence = 0;
            ownheroisread = false;
            ownAbilityisReady = false;
            ownHeroNumAttacksThisTurn = 0;
            ownHeroWindfury = false;
            ownSecretList.Clear();
            enemySecretCount = 0;
            heroname = HeroEnum.druid;
            enemyHeroname = HeroEnum.druid;
            heroAbility = new CardDB.Card();
            enemyAbility = new CardDB.Card();
            herofrozen = false;
            enemyfrozen = false;
            numMinionsPlayedThisTurn = 0;
            cardsPlayedThisTurn = 0;
            ueberladung = 0;
            ownMaxMana = 0;
            enemyMaxMana = 0;
            enemyWeaponDurability = 0;
            enemyWeaponAttack = 0;
            heroWeaponDurability = 0;
            heroWeaponAttack = 0;
            heroImmuneToDamageWhileAttacking = false;
            ownMinions.Clear();
            enemyMinions.Clear();
            heroImmune = false;
            enemyHeroImmune = false;
            this.ownHeroWeapon = CardDB.cardName.unknown;
            this.enemyHeroWeapon = CardDB.cardName.unknown;
        }


        public void setOwnPlayer(int player)
        {
            this.ownPlayerController = player;
        }

        public int getOwnController()
        {
            return this.ownPlayerController;
        }

        public string heroIDtoName(string s)
        {
            string retval = "druid";

            if (s == "XXX_040")
            {
                retval = "hogger";
            }
            if (s == "HERO_05")
            {
                retval = "hunter";
            }
            if (s == "HERO_09")
            {
                retval = "priest";
            }
            if (s == "HERO_06")
            {
                retval = "druid";
            }
            if (s == "HERO_07")
            {
                retval = "warlock";
            }
            if (s == "HERO_03")
            {
                retval = "thief";
            }
            if (s == "HERO_04")
            {
                retval = "pala";
            }
            if (s == "HERO_01")
            {
                retval = "warrior";
            }
            if (s == "HERO_02")
            {
                retval = "shaman";
            }
            if (s == "HERO_08")
            {
                retval = "mage";
            }
            if (s == "EX1_323h")
            {
                retval = "lordjaraxxus";
            }

            return retval;
        }

        public HeroEnum heroNametoEnum(string s)
        {

            if (s == "hogger")
            {
                return HeroEnum.hogger;
            }
            if (s == "hunter")
            {
                return HeroEnum.hunter;
            }
            if (s == "priest")
            {
                return HeroEnum.priest;
            }
            if (s == "druid")
            {
                return HeroEnum.druid;
            }
            if (s == "warlock")
            {
                return HeroEnum.warlock;
            }
            if (s == "thief")
            {
                return HeroEnum.thief;
            }
            if (s == "pala")
            {
                return HeroEnum.pala;
            }
            if (s == "warrior")
            {
                return HeroEnum.warrior;
            }
            if (s == "shaman")
            {
                return HeroEnum.shaman;
            }
            if (s == "mage")
            {
                return HeroEnum.mage;
            }
            if (s == "lordjaraxxus")
            {
                return HeroEnum.lordjaraxxus;
            }

            return HeroEnum.None;
        }


        public void updateMinions(List<Minion> om, List<Minion> em)
        {
            this.ownMinions.Clear();
            this.enemyMinions.Clear();
            foreach (var item in om)
            {
                this.ownMinions.Add(new Minion(item));
            }
            //this.ownMinions.AddRange(om);
            foreach (var item in em)
            {
                this.enemyMinions.Add(new Minion(item));
            }
            //this.enemyMinions.AddRange(em);

            //sort them 
            updatePositions();
        }

        public void updateSecretStuff(List<string> ownsecs, int numEnemSec)
        {
            this.ownSecretList.Clear();
            foreach (string s in ownsecs)
            {
                this.ownSecretList.Add(CardDB.Instance.cardIdstringToEnum(s));
            }
            this.enemySecretCount = numEnemSec;
        }

        public void updatePlayer(int maxmana, int currentmana, int cardsplayedthisturn, int numMinionsplayed, int optionsPlayedThisTurn, int recall, int heroentity, int enemyentity)
        {
            this.currentMana = currentmana;
            this.ownMaxMana = maxmana;
            this.cardsPlayedThisTurn = cardsplayedthisturn;
            this.numMinionsPlayedThisTurn = numMinionsplayed;
            this.ueberladung = recall;
            this.ownHeroEntity = heroentity;
            this.enemyHeroEntitiy = enemyentity;
            this.numOptionsPlayedThisTurn = optionsPlayedThisTurn;
        }

        public void updateOwnHero(string weapon, int watt, int wdur, string heron, CardDB.Card hab, bool habrdy, Minion Hero)
        {
            this.ownHeroWeapon = CardDB.Instance.cardNamestringToEnum(weapon);
            this.heroWeaponAttack = watt;
            this.heroWeaponDurability = wdur;

            this.heroname = this.heroNametoEnum(heron);

            this.heroAbility = hab;
            this.ownAbilityisReady = habrdy;

            this.ownHero = new Minion(Hero);
            this.ownHero.updateReadyness();
        }

        public void updateEnemyHero(string weapon, int weaponAttack, int weaponDurability, string heron, int enemMaxMana, CardDB.Card eab, Minion enemyHero)
        {
            this.enemyHeroWeapon = CardDB.Instance.cardNamestringToEnum(weapon);
            this.enemyWeaponAttack = weaponAttack;
            this.enemyWeaponDurability = weaponDurability;

            this.enemyMaxMana = enemMaxMana;

            this.enemyHeroname = this.heroNametoEnum(heron);

            this.enemyAbility = eab;

            this.enemyHero = new Minion(enemyHero);

        }

        public void updateFatigueStats(int ods, int ohf, int eds, int ehf)
        {
            this.ownDeckSize = ods;
            this.ownHeroFatigue = ohf;
            this.enemyDeckSize = eds;
            this.enemyHeroFatigue = ehf;
        }

        public void updatePositions()
        {
            this.ownMinions.Sort((a, b) => a.zonepos.CompareTo(b.zonepos));
            this.enemyMinions.Sort((a, b) => a.zonepos.CompareTo(b.zonepos));
            int i = 0;
            foreach (Minion m in this.ownMinions)
            {
                i++;
                m.zonepos = i;

            }
            i = 0;
            foreach (Minion m in this.enemyMinions)
            {
                i++;
                m.zonepos = i;
            }

            /*List<Minion> temp = new List<Minion>();
            temp.AddRange(ownMinions);
            this.ownMinions.Clear();
            this.ownMinions.AddRange(temp.OrderBy(x => x.zonepos).ToList());
            temp.Clear();
            temp.AddRange(enemyMinions);
            this.enemyMinions.Clear();
            this.enemyMinions.AddRange(temp.OrderBy(x => x.zonepos).ToList());*/

        }

        private Minion createNewMinion(Handmanager.Handcard hc, int id)
        {
            Minion m = new Minion
            {
                handcard = new Handmanager.Handcard(hc),
                zonepos = id + 1,
                entitiyID = hc.entity,
                Angr = hc.card.Attack,
                Hp = hc.card.Health,
                maxHp = hc.card.Health,
                name = hc.card.name,
                playedThisTurn = true,
                numAttacksThisTurn = 0
            };


            if (hc.card.windfury) m.windfury = true;
            if (hc.card.tank) m.taunt = true;
            if (hc.card.Charge)
            {
                m.Ready = true;
                m.charge = 1;
            }
            if (hc.card.Shield) m.divineshild = true;
            if (hc.card.poisionous) m.poisonous = true;

            if (hc.card.Stealth) m.stealth = true;

            if (m.name == CardDB.cardName.lightspawn && !m.silenced)
            {
                m.Angr = m.Hp;
            }


            return m;
        }


        public void printHero(bool writetobuffer = false)
        {
            help.logg("player:");
            help.logg(this.numMinionsPlayedThisTurn + " " + this.cardsPlayedThisTurn + " " + this.ueberladung + " " + this.ownPlayerController);

            help.logg("ownhero:");
            help.logg(this.heroname + " " + this.ownHero.Hp + " " + this.ownHero.maxHp + " " + this.ownHero.armor + " " + this.ownHero.immuneWhileAttacking + " " + this.ownHero.immune + " " + this.ownHero.entitiyID + " " + this.ownHero.Ready + " " + this.ownHero.numAttacksThisTurn + " " + this.ownHero.frozen + " " + this.ownHero.Angr + " " + this.ownHero.tempAttack);
            help.logg("weapon: " + heroWeaponAttack + " " + heroWeaponDurability + " " + ownHeroWeapon);
            help.logg("ability: " + this.ownAbilityisReady + " " + this.heroAbility.cardIDenum);
            string secs = "";
            foreach (CardDB.cardIDEnum sec in this.ownSecretList)
            {
                secs += sec + " ";
            }
            help.logg("osecrets: " + secs);
            help.logg("enemyhero:");
            help.logg(this.enemyHeroname + " " + this.enemyHero.Hp + " " + this.enemyHero.maxHp + " " + this.enemyHero.armor + " " + this.enemyHero.frozen + " " + this.enemyHero.immune + " " + this.enemyHero.entitiyID);
            help.logg("weapon: " + this.enemyWeaponAttack + " " + this.enemyWeaponDurability + " " + this.enemyHeroWeapon);
            help.logg("ability: " + "true" + " " + this.enemyAbility.cardIDenum);
            help.logg("fatigue: " + this.ownDeckSize + " " + this.ownHeroFatigue + " " + this.enemyDeckSize + " " + this.enemyHeroFatigue);

            if (writetobuffer)
            {
                help.writeToBuffer("player:");
                help.writeToBuffer(this.numMinionsPlayedThisTurn + " " + this.cardsPlayedThisTurn + " " + this.ueberladung + " " + this.ownPlayerController);

                help.writeToBuffer("ownhero:");
                help.writeToBuffer(this.heroname + " " + this.ownHero.Hp + " " + this.ownHero.maxHp + " " + this.ownHero.armor + " " + this.ownHero.immuneWhileAttacking + " " + this.ownHero.immune + " " + this.ownHero.entitiyID + " " + this.ownHero.Ready + " " + this.ownHero.numAttacksThisTurn + " " + this.ownHero.frozen + " " + this.ownHero.Angr + " " + this.ownHero.tempAttack);
                help.writeToBuffer("weapon: " + heroWeaponAttack + " " + heroWeaponDurability + " " + ownHeroWeapon);
                help.writeToBuffer("ability: " + this.ownAbilityisReady + " " + this.heroAbility.cardIDenum);
                secs = "";
                foreach (CardDB.cardIDEnum sec in this.ownSecretList)
                {
                    secs += sec + " ";
                }
                help.writeToBuffer("osecrets: " + secs);
                help.writeToBuffer("enemyhero:");
                help.writeToBuffer(this.enemyHeroname + " " + this.enemyHero.Hp + " " + this.enemyHero.maxHp + " " + this.enemyHero.armor + " " + this.enemyHero.frozen + " " + this.enemyHero.immune + " " + this.enemyHero.entitiyID);
                help.writeToBuffer("weapon: " + this.enemyWeaponAttack + " " + this.enemyWeaponDurability + " " + this.enemyHeroWeapon);
                help.writeToBuffer("ability: " + "true" + " " + this.enemyAbility.cardIDenum);
                help.writeToBuffer("fatigue: " + this.ownDeckSize + " " + this.ownHeroFatigue + " " + this.enemyDeckSize + " " + this.enemyHeroFatigue);
            }
        }


        public void printOwnMinions(bool writetobuffer = false)
        {
            help.logg("OwnMinions:");
            if (writetobuffer) help.writeToBuffer("OwnMinions:");
            foreach (Minion m in this.ownMinions)
            {
                string mini = m.name + " " + m.handcard.card.cardIDenum + " zp:" + m.zonepos + " e:" + m.entitiyID + " A:" + m.Angr + " H:" + m.Hp + " mH:" + m.maxHp + " rdy:" + m.Ready + " natt:" + m.numAttacksThisTurn;
                if (m.exhausted) mini += " ex";
                if (m.taunt) mini += " tnt";
                if (m.frozen) mini += " frz";
                if (m.silenced) mini += " silenced";
                if (m.divineshild) mini += " divshield";
                if (m.playedThisTurn) mini += " ptt";
                if (m.windfury) mini += " wndfr";
                if (m.stealth) mini += " stlth";
                if (m.poisonous) mini += " poi";
                if (m.immune) mini += " imm";
                if (m.concedal) mini += " cncdl";
                if (m.destroyOnOwnTurnStart) mini += " dstrOwnTrnStrt";
                if (m.destroyOnOwnTurnEnd) mini += " dstrOwnTrnnd";
                if (m.destroyOnEnemyTurnStart) mini += " dstrEnmTrnStrt";
                if (m.destroyOnEnemyTurnEnd) mini += " dstrEnmTrnnd";
                if (m.shadowmadnessed) mini += " shdwmdnssd";
                if (m.cantLowerHPbelowONE) mini += " cantLowerHpBelowOne";

                if (m.charge >= 1) mini += " chrg(" + m.charge + ")";
                if (m.AdjacentAngr >= 1) mini += " adjaattk(" + m.AdjacentAngr + ")";
                if (m.tempAttack >= 1) mini += " tmpattck(" + m.tempAttack + ")";
                if (m.spellpower >= 1) mini += " spllpwr(" + m.spellpower + ")";

                if (m.ancestralspirit >= 1) mini += " ancstrl(" + m.ancestralspirit + ")";
                if (m.ownBlessingOfWisdom >= 1) mini += " ownBlssng(" + m.ownBlessingOfWisdom + ")";
                if (m.enemyBlessingOfWisdom >= 1) mini += " enemyBlssng(" + m.enemyBlessingOfWisdom + ")";
                if (m.souloftheforest >= 1) mini += " souloffrst(" + m.souloftheforest + ")";




                help.logg(mini);
                if (writetobuffer) help.writeToBuffer(mini);
            }

        }

        public void printEnemyMinions(bool writetobuffer = false)
        {
            help.logg("EnemyMinions:");
            if (writetobuffer) help.writeToBuffer("EnemyMinions:");
            foreach (Minion m in this.enemyMinions)
            {
                string mini = m.name + " " + m.handcard.card.cardIDenum + " zp:" + m.zonepos + " e:" + m.entitiyID + " A:" + m.Angr + " H:" + m.Hp + " mH:" + m.maxHp + " rdy:" + m.Ready;// +" natt:" + m.numAttacksThisTurn;
                if (m.exhausted) mini += " ex";
                if (m.taunt) mini += " tnt";
                if (m.frozen) mini += " frz";
                if (m.silenced) mini += " silenced";
                if (m.divineshild) mini += " divshield";
                if (m.playedThisTurn) mini += " ptt";
                if (m.windfury) mini += " wndfr";
                if (m.stealth) mini += " stlth";
                if (m.poisonous) mini += " poi";
                if (m.immune) mini += " imm";
                if (m.concedal) mini += " cncdl";
                if (m.destroyOnOwnTurnStart) mini += " dstrOwnTrnStrt";
                if (m.destroyOnOwnTurnEnd) mini += " dstrOwnTrnnd";
                if (m.destroyOnEnemyTurnStart) mini += " dstrEnmTrnStrt";
                if (m.destroyOnEnemyTurnEnd) mini += " dstrEnmTrnnd";
                if (m.shadowmadnessed) mini += " shdwmdnssd";
                if (m.cantLowerHPbelowONE) mini += " cantLowerHpBelowOne";

                if (m.charge >= 1) mini += " chrg(" + m.charge + ")";
                if (m.AdjacentAngr >= 1) mini += " adjaattk(" + m.AdjacentAngr + ")";
                if (m.tempAttack >= 1) mini += " tmpattck(" + m.tempAttack + ")";
                if (m.spellpower >= 1) mini += " spllpwr(" + m.spellpower + ")";

                if (m.ancestralspirit >= 1) mini += " ancstrl(" + m.ancestralspirit + ")";
                if (m.ownBlessingOfWisdom >= 1) mini += " ownBlssng(" + m.ownBlessingOfWisdom + ")";
                if (m.enemyBlessingOfWisdom >= 1) mini += " enemyBlssng(" + m.enemyBlessingOfWisdom + ")";
                if (m.souloftheforest >= 1) mini += " souloffrst(" + m.souloftheforest + ")";

                help.logg(mini);
                if (writetobuffer) help.writeToBuffer(mini);
            }

        }


    }

    public class PenalityManager
    {
        //todo acolyteofpain
        //todo better aoe-penality

        ComboBreaker cb;


        Dictionary<CardDB.cardName, int> HealTargetDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> HealHeroDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> HealAllDatabase = new Dictionary<CardDB.cardName, int>();


        Dictionary<CardDB.cardName, int> DamageAllDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> DamageHeroDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> DamageRandomDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> DamageAllEnemysDatabase = new Dictionary<CardDB.cardName, int>();

        Dictionary<CardDB.cardName, int> enrageDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> silenceDatabase = new Dictionary<CardDB.cardName, int>();

        Dictionary<CardDB.cardName, int> heroAttackBuffDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> attackBuffDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> healthBuffDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> tauntBuffDatabase = new Dictionary<CardDB.cardName, int>();

        Dictionary<CardDB.cardName, int> lethalHelpers = new Dictionary<CardDB.cardName, int>();


        Dictionary<CardDB.cardName, int> cardDiscardDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> destroyOwnDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> destroyDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> buffingMinionsDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> buffing1TurnDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> heroDamagingAoeDatabase = new Dictionary<CardDB.cardName, int>();
        Dictionary<CardDB.cardName, int> randomEffects = new Dictionary<CardDB.cardName, int>();

        Dictionary<CardDB.cardName, int> silenceTargets = new Dictionary<CardDB.cardName, int>();

        Dictionary<CardDB.cardName, int> returnHandDatabase = new Dictionary<CardDB.cardName, int>();

        Dictionary<CardDB.cardName, int> priorityDatabase = new Dictionary<CardDB.cardName, int>();

        public Dictionary<CardDB.cardName, int> DamageTargetDatabase = new Dictionary<CardDB.cardName, int>();
        public Dictionary<CardDB.cardName, int> DamageTargetSpecialDatabase = new Dictionary<CardDB.cardName, int>();
        public Dictionary<CardDB.cardName, int> cardDrawBattleCryDatabase = new Dictionary<CardDB.cardName, int>();
        public Dictionary<CardDB.cardName, int> priorityTargets = new Dictionary<CardDB.cardName, int>();
        public Dictionary<CardDB.cardName, int> specialMinions = new Dictionary<CardDB.cardName, int>(); //minions with cardtext, but no battlecry


        private static PenalityManager instance;

        public static PenalityManager Instance
        {
            get
            {
                return instance ?? (instance = new PenalityManager());
            }
        }

        private PenalityManager()
        {
            setupHealDatabase();
            setupEnrageDatabase();
            setupDamageDatabase();
            setupPriorityList();
            setupsilenceDatabase();
            setupAttackBuff();
            setupHealthBuff();
            setupCardDrawBattlecry();
            setupDiscardCards();
            setupDestroyOwnCards();
            setupSpecialMins();
            setupEnemyTargetPriority();
            setupHeroDamagingAOE();
            setupBuffingMinions();
            setupRandomCards();
            setupLethalHelpMinions();
            setupSilenceTargets();
        }

        public void setCombos()
        {
            this.cb = ComboBreaker.Instance;
        }

        public int getAttackWithMininonPenality(Minion m, Playfield p, Minion target, bool lethal)
        {
            int pen = 0;
            pen = getAttackSecretPenality(m, p, target);
            if (!lethal && m.name == CardDB.cardName.bloodimp) pen = 50;
            if (m.name == CardDB.cardName.leeroyjenkins)
            {
                if (!target.own)
                {
                    if (target.name == CardDB.cardName.whelp) return 500;
                }

            }
            return pen;
        }

        public int getAttackWithHeroPenality(Minion target, Playfield p, bool leathal)
        {
            int retval = 0;

            if (!leathal && p.ownWeaponName == CardDB.cardName.swordofjustice)
            {
                return 28;
            }

            if (p.ownWeaponDurability == 1 && p.ownWeaponName == CardDB.cardName.eaglehornbow)
            {
                foreach (Handmanager.Handcard hc in p.owncards)
                {
                    if (hc.card.name == CardDB.cardName.arcaneshot || hc.card.name == CardDB.cardName.killcommand) return -p.ownWeaponAttack - 1;
                }
                if (p.ownSecretsIDList.Count >= 1) return 20;

                foreach (Handmanager.Handcard hc in p.owncards)
                {
                    if (hc.card.Secret) return 20;
                }
            }

            //no penality, but a bonus, if he has weapon on hand!
            if (target.isHero && !target.own && p.ownWeaponName == CardDB.cardName.gorehowl && p.ownWeaponAttack >= 3)
            {
                return 10;
            }
            if (p.ownWeaponDurability >= 1)
            {
                bool hasweapon = false;
                foreach (Handmanager.Handcard c in p.owncards)
                {
                    if (c.card.type == CardDB.cardtype.WEAPON) hasweapon = true;
                }
                if (p.ownWeaponAttack == 1 && p.ownHeroName == HeroEnum.thief) hasweapon = true;
                if (hasweapon) retval = -p.ownWeaponAttack - 1; // so he doesnt "lose" the weapon in evaluation :D
            }
            if (p.ownWeaponAttack == 1 && p.ownHeroName == HeroEnum.thief) retval += -1;
            return retval;
        }

        public int getPlayCardPenality(CardDB.Card card, Minion target, Playfield p, int choice, bool lethal)
        {
            int retval = 0;
            CardDB.cardName name = card.name;
            //there is no reason to buff HP of minon (because it is not healed)

            int abuff = getAttackBuffPenality(card, target, p, choice, lethal);
            int tbuff = getTauntBuffPenality(name, target, p, choice);
            if (name == CardDB.cardName.markofthewild && ((abuff >= 500 && tbuff == 0) || (abuff == 0 && tbuff >= 500)))
            {
                retval = 0;
            }
            else
            {
                retval += abuff + tbuff;
            }
            retval += getHPBuffPenality(card, target, p, choice);
            retval += getSilencePenality(name, target, p, choice, lethal);
            retval += getDamagePenality(name, target, p, choice, lethal);
            retval += getHealPenality(name, target, p, choice, lethal);
            //if(retval < 500) 
            retval += getCardDrawPenality(name, target, p, choice, lethal);
            retval += getCardDrawofEffectMinions(card, p);
            retval += getCardDiscardPenality(name, p);
            retval += getDestroyOwnPenality(name, target, p, lethal);

            retval += getDestroyPenality(name, target, p, lethal);
            retval += getSpecialCardComboPenalitys(card, target, p, lethal, choice);
            retval += getRandomPenaltiy(card, p, target);
            if (!lethal)
            {
                retval += cb.getPenalityForDestroyingCombo(card, p);
                retval += cb.getPlayValue(card.cardIDenum);
            }

            retval += playSecretPenality(card, p);
            retval += getPlayCardSecretPenality(card, p);

            //Helpfunctions.Instance.ErrorLog("retval " + retval);
            return retval;
        }

        private int getAttackBuffPenality(CardDB.Card card, Minion target, Playfield p, int choice, bool lethal)
        {
            CardDB.cardName name = card.name;
            if (name == CardDB.cardName.darkwispers && choice != 2) return 0;
            int pen = 0;
            //buff enemy?

            if (!lethal && (card.name == CardDB.cardName.savageroar || card.name == CardDB.cardName.bloodlust))
            {
                int targets = 0;
                foreach (Minion m in p.ownMinions)
                {
                    if (m.Ready) targets++;
                }
                if ((p.ownHero.Ready || p.ownHero.numAttacksThisTurn == 0) && card.name == CardDB.cardName.savageroar) targets++;

                if (targets <= 2)
                {
                    return 20;
                }
            }

            if (!this.attackBuffDatabase.ContainsKey(name)) return 0;
            if (target == null) return 60;
            if (!target.isHero && !target.own)
            {
                if (card.type == CardDB.cardtype.MOB && p.ownMinions.Count == 0) return 0;
                //allow it if you have biggamehunter
                foreach (Handmanager.Handcard hc in p.owncards)
                {
                    if (hc.card.name == CardDB.cardName.biggamehunter) return 5;
                    if (hc.card.name == CardDB.cardName.shadowworddeath) return 5;
                }
                if (card.name == CardDB.cardName.crueltaskmaster || card.name == CardDB.cardName.innerrage)
                {
                    Minion m = target;

                    if (m.Hp == 1)
                    {
                        return 0;
                    }

                    if (!m.wounded && (m.Angr >= 4 || m.Hp >= 5))
                    {
                        foreach (Handmanager.Handcard hc in p.owncards)
                        {
                            if (hc.card.name == CardDB.cardName.execute) return 0;
                        }
                    }
                    pen = 30;
                }
                else
                {
                    pen = 500;
                }
            }
            if (!target.isHero && target.own)
            {
                Minion m = target;
                if (!m.Ready)
                {
                    return 50;
                }
                if (m.Hp == 1 && !m.divineshild && !this.buffing1TurnDatabase.ContainsKey(name))
                {
                    return 10;
                }
            }

            if (card.name == CardDB.cardName.blessingofmight) return 6;
            return pen;
        }

        private int getHPBuffPenality(CardDB.Card card, Minion target, Playfield p, int choice)
        {
            CardDB.cardName name = card.name;
            if (name == CardDB.cardName.darkwispers && choice != 2) return 0;
            int pen = 0;
            //buff enemy?
            if (!this.healthBuffDatabase.ContainsKey(name)) return 0;
            if (!target.own && !this.tauntBuffDatabase.ContainsKey(name))
            {
                pen = 500;
            }

            return pen;
        }


        private int getTauntBuffPenality(CardDB.cardName name, Minion target, Playfield p, int choice)
        {
            int pen = 0;
            //buff enemy?
            if (!this.tauntBuffDatabase.ContainsKey(name)) return 0;
            if (name == CardDB.cardName.markofnature && choice != 2) return 0;
            if (name == CardDB.cardName.darkwispers && choice != 2) return 0;

            if (!target.isHero && !target.own)
            {
                //allow it if you have black knight
                foreach (Handmanager.Handcard hc in p.owncards)
                {
                    if (hc.card.name == CardDB.cardName.theblackknight) return 0;
                }

                // allow taunting if target is priority and others have taunt
                bool enemyhasTaunts = false;
                foreach (Minion mnn in p.enemyMinions)
                {
                    if (mnn.taunt)
                    {
                        enemyhasTaunts = true;
                        break;
                    }
                }
                if (enemyhasTaunts && this.priorityDatabase.ContainsKey(target.name) && !target.silenced && !target.taunt)
                {
                    return 0;
                }

                pen = 500;
            }

            return pen;
        }

        private int getSilencePenality(CardDB.cardName name, Minion target, Playfield p, int choice, bool lethal)
        {
            int pen = 0;
            if (name == CardDB.cardName.keeperofthegrove && choice != 2) return 0; // look at damage penality in this case

            if (target == null)
            {
                if (name == CardDB.cardName.ironbeakowl || name == CardDB.cardName.spellbreaker)
                {

                    return 20;
                }
                return 0;
            }

            if (target.own)
            {
                if (this.silenceDatabase.ContainsKey(name))
                {
                    // no pen if own is enrage
                    if ((!target.silenced && (target.name == CardDB.cardName.ancientwatcher || target.name == CardDB.cardName.ragnarosthefirelord || target.name == CardDB.cardName.mogortheogre || target.name == CardDB.cardName.animagolem)) || target.Angr < target.handcard.card.Attack || target.maxHp < target.handcard.card.Health || (target.frozen && !target.playedThisTurn && target.numAttacksThisTurn == 0))
                    {
                        return 0;
                    }


                    pen += 500;
                }
            }



            if (!target.own)
            {
                if (this.silenceDatabase.ContainsKey(name))
                {
                    // no pen if own is enrage
                    Minion m = target;//

                    if (!m.silenced && (m.name == CardDB.cardName.ancientwatcher || m.name == CardDB.cardName.ragnarosthefirelord))
                    {
                        return 500;
                    }

                    if (lethal)
                    {
                        //during lethal we only silence taunt, or if its a mob (owl/spellbreaker) + we can give him charge
                        if (m.taunt || (name == CardDB.cardName.ironbeakowl && (p.ownMinions.Find(x => x.name == CardDB.cardName.tundrarhino) != null || p.ownMinions.Find(x => x.name == CardDB.cardName.warsongcommander) != null || p.owncards.Find(x => x.card.name == CardDB.cardName.charge) != null)) || (name == CardDB.cardName.spellbreaker && p.owncards.Find(x => x.card.name == CardDB.cardName.charge) != null)) return 0;

                        return 500;
                    }
                    if (m.handcard.card.name == CardDB.cardName.venturecomercenary && !m.silenced && (m.Angr <= m.handcard.card.Attack && m.maxHp <= m.handcard.card.Health))
                    {
                        return 30;
                    }

                    if (priorityDatabase.ContainsKey(m.name) && !m.silenced)
                    {
                        return 0;
                    }

                    if (this.silenceTargets.ContainsKey(m.name) && !m.silenced)
                    {
                        return 0;
                    }

                    if (m.handcard.card.deathrattle && !m.silenced)
                    {
                        return 0;
                    }

                    //silence nothing
                    //todo add "new" enchantments (good or bad ones)
                    if (m.Angr <= m.handcard.card.Attack && m.maxHp <= m.handcard.card.Health && !m.taunt && !m.windfury && !m.divineshild && !m.poisonous && !this.specialMinions.ContainsKey(name))
                    {
                        if (name == CardDB.cardName.keeperofthegrove) return 500;
                        return 30;
                    }



                    return 5;
                }
            }

            return pen;

        }

        private int getDamagePenality(CardDB.cardName name, Minion target, Playfield p, int choice, bool lethal)
        {
            int pen = 0;

            if (name == CardDB.cardName.shieldslam && p.ownHero.armor == 0) return 500;
            if (name == CardDB.cardName.savagery && p.ownHero.Angr == 0) return 500;
            if (name == CardDB.cardName.keeperofthegrove && choice != 1) return 0; // look at silence penality

            if (this.DamageAllDatabase.ContainsKey(name) || (p.anzOwnAuchenaiSoulpriest >= 1 && HealAllDatabase.ContainsKey(name))) // aoe penality
            {

                if (p.enemyMinions.Count == 0) return 300;

                foreach (Minion m in p.enemyMinions)
                {
                    if ((m.Angr >= 4 || m.Hp >= 5) && !m.wounded)
                    {
                        foreach (Handmanager.Handcard hc in p.owncards)
                        {
                            if (hc.card.name == CardDB.cardName.execute) return 0;
                        }
                    }
                }

                if (p.enemyMinions.Count <= 1 || p.enemyMinions.Count + 1 <= p.ownMinions.Count || p.ownMinions.Count >= 3)
                {
                    return 30;
                }
            }

            if (this.DamageAllEnemysDatabase.ContainsKey(name)) // aoe penality
            {
                if (p.enemyMinions.Count == 0) return 300;
                foreach (Minion m in p.enemyMinions)
                {
                    if ((m.Angr >= 4 || m.Hp >= 5) && !m.wounded)
                    {
                        foreach (Handmanager.Handcard hc in p.owncards)
                        {
                            if (hc.card.name == CardDB.cardName.execute) return 0;
                        }
                    }
                }

                if (name == CardDB.cardName.holynova)
                {
                    int targets = p.enemyMinions.Count;
                    foreach (Minion m in p.ownMinions)
                    {
                        if (m.wounded) targets++;
                    }
                    if (targets <= 2)
                    {
                        return 20;
                    }

                }
                if (p.enemyMinions.Count <= 2)
                {
                    return 20 * (3 - p.enemyMinions.Count);
                }
            }

            if (target == null) return 0;

            if (target.own && target.isHero)
            {
                if (DamageTargetDatabase.ContainsKey(name) || DamageTargetSpecialDatabase.ContainsKey(name) || (p.anzOwnAuchenaiSoulpriest >= 1 && HealTargetDatabase.ContainsKey(name)))
                {
                    pen = 500;
                }
            }

            if (!lethal && !target.own && target.isHero)
            {
                if (name == CardDB.cardName.baneofdoom)
                {
                    pen = 500;
                }
            }

            if (target.own && !target.isHero)
            {
                if (DamageTargetDatabase.ContainsKey(name) || (p.anzOwnAuchenaiSoulpriest >= 1 && HealTargetDatabase.ContainsKey(name)))
                {
                    // no pen if own is enrage
                    Minion m = target;

                    //standard ones :D (mostly carddraw
                    if (enrageDatabase.ContainsKey(m.name) && !m.wounded && m.Ready)
                    {
                        return pen;
                    }

                    // no pen if we have battlerage for example
                    int dmg = this.DamageTargetDatabase.ContainsKey(name) ? this.DamageTargetDatabase[name] : this.HealTargetDatabase[name];

                    if (m.name == CardDB.cardName.madscientist && p.ownHeroName == HeroEnum.hunter) return 500;
                    if (m.handcard.card.deathrattle) return 10;
                    if (m.Hp > dmg)
                    {
                        if (m.name == CardDB.cardName.acolyteofpain && p.owncards.Count <= 3) return 0;
                        foreach (Handmanager.Handcard hc in p.owncards)
                        {
                            if (hc.card.name == CardDB.cardName.battlerage) return pen;
                            if (hc.card.name == CardDB.cardName.rampage) return pen;
                        }
                    }


                    pen = 500;
                }

                //special cards
                if (DamageTargetSpecialDatabase.ContainsKey(name))
                {
                    int dmg = DamageTargetSpecialDatabase[name];
                    Minion m = target;
                    if ((name == CardDB.cardName.crueltaskmaster || name == CardDB.cardName.innerrage) && m.Hp >= 2) return 0;
                    if ((name == CardDB.cardName.demonfire || name == CardDB.cardName.demonheart) && (TAG_RACE)m.handcard.card.race == TAG_RACE.DEMON) return 0;
                    if (name == CardDB.cardName.earthshock && m.Hp >= 2)
                    {
                        if ((!m.silenced && (m.name == CardDB.cardName.ancientwatcher || m.name == CardDB.cardName.ragnarosthefirelord)) || m.Angr < m.handcard.card.Attack || m.maxHp < m.handcard.card.Health || (m.frozen && !m.playedThisTurn && m.numAttacksThisTurn == 0))
                            return 0;
                        if (priorityDatabase.ContainsKey(m.name) && !m.silenced)
                        {
                            return 500;
                        }
                    }
                    if (name == CardDB.cardName.earthshock)//dont silence other own minions
                    {
                        return 500;
                    }

                    // no pen if own is enrage
                    if (enrageDatabase.ContainsKey(m.name) && !m.wounded && m.Ready)
                    {
                        return pen;
                    }

                    // no pen if we have battlerage for example

                    if (m.Hp > dmg)
                    {
                        foreach (Handmanager.Handcard hc in p.owncards)
                        {
                            if (hc.card.name == CardDB.cardName.battlerage) return pen;
                            if (hc.card.name == CardDB.cardName.rampage) return pen;
                        }
                    }

                    pen = 500;
                }
            }
            if (!target.own && !target.isHero)
            {
                if (DamageTargetSpecialDatabase.ContainsKey(name) || DamageTargetDatabase.ContainsKey(name))
                {
                    Minion m = target;
                    if (name == CardDB.cardName.soulfire && m.maxHp <= 2) pen = 10;

                    if (name == CardDB.cardName.baneofdoom && m.Hp >= 3) pen = 10;

                    if (name == CardDB.cardName.shieldslam && (m.Hp <= 4 || m.Angr <= 4)) pen = 20;
                }
            }

            return pen;
        }

        private int getHealPenality(CardDB.cardName name, Minion target, Playfield p, int choice, bool lethal)
        {
            ///Todo healpenality for aoe heal
            ///todo auchenai soulpriest
            if (p.anzOwnAuchenaiSoulpriest >= 1) return 0;
            if (name == CardDB.cardName.ancientoflore && choice != 2) return 0;
            int pen = 0;
            int heal = 0;
            /*if (HealHeroDatabase.ContainsKey(name))
            {
                heal = HealHeroDatabase[name];
                if (target == 200) pen = 500; // dont heal enemy
                if ((target == 100 || target == -1) && p.ownHeroHp + heal > 30) pen = p.ownHeroHp + heal - 30;
            }*/

            if (name == CardDB.cardName.treeoflife)
            {
                int mheal = 0;
                int wounded = 0;
                //int eheal = 0;
                if (p.ownHero.wounded) wounded++;
                foreach (Minion mi in p.ownMinions)
                {
                    mheal += Math.Min((mi.maxHp - mi.Hp), 4);
                    if (mi.wounded) wounded++;
                }
                //Console.WriteLine(mheal + " circle");
                if (mheal == 0) return 500;
                if (mheal <= 7 && wounded <= 2) return 20;
            }

            if (name == CardDB.cardName.circleofhealing)
            {
                int mheal = 0;
                int wounded = 0;
                //int eheal = 0;
                foreach (Minion mi in p.ownMinions)
                {
                    mheal += Math.Min((mi.maxHp - mi.Hp), 4);
                    if (mi.wounded) wounded++;
                }
                //Console.WriteLine(mheal + " circle");
                if (mheal == 0) return 500;
                if (mheal <= 7 && wounded <= 2) return 20;
            }

            if (HealTargetDatabase.ContainsKey(name))
            {
                if (target == null) return 10;
                //Helpfunctions.Instance.ErrorLog("pencheck for " + name + " " + target.entitiyID + " " + target.isHero  + " " + target.own);
                heal = HealTargetDatabase[name];
                if (target.isHero && !target.own) return 510; // dont heal enemy
                //Helpfunctions.Instance.ErrorLog("pencheck for " + name + " " + target.entitiyID + " " + target.isHero + " " + target.own);
                if ((target.isHero && target.own) && p.ownHero.Hp == 30) return 150;
                if ((target.isHero && target.own) && p.ownHero.Hp + heal - 1 > 30) pen = p.ownHero.Hp + heal - 30;
                Minion m = new Minion();

                if (!target.isHero && target.own)
                {
                    m = target;
                    int wasted = 0;
                    if (m.Hp == m.maxHp) return 500;
                    if (m.Hp + heal - 1 > m.maxHp) wasted = m.Hp + heal - m.maxHp;
                    pen = wasted;

                    if (m.taunt && wasted <= 2 && m.Hp < m.maxHp) pen -= 5; // if we heal a taunt, its good :D

                    if (m.Hp + heal <= m.maxHp) pen = -1;
                }

                if (!target.isHero && !target.own)
                {
                    m = target;
                    if (m.Hp == m.maxHp) return 500;
                    // no penality if we heal enrage enemy
                    if (enrageDatabase.ContainsKey(m.name))
                    {
                        return pen;
                    }
                    // no penality if we have heal-trigger :D
                    int i = 0;
                    foreach (Minion mnn in p.ownMinions)
                    {
                        if (mnn.name == CardDB.cardName.northshirecleric) i++;
                        if (mnn.name == CardDB.cardName.lightwarden) i++;
                    }
                    foreach (Minion mnn in p.enemyMinions)
                    {
                        if (mnn.name == CardDB.cardName.northshirecleric) i--;
                        if (mnn.name == CardDB.cardName.lightwarden) i--;
                    }
                    if (i >= 1) return pen;

                    // no pen if we have slam

                    foreach (Handmanager.Handcard hc in p.owncards)
                    {
                        if (hc.card.name == CardDB.cardName.slam && m.Hp < 2) return pen;
                        if (hc.card.name == CardDB.cardName.backstab) return pen;
                    }

                    pen = 500;
                }


            }

            return pen;
        }

        private int getCardDrawPenality(CardDB.cardName name, Minion target, Playfield p, int choice, bool lethal)
        {
            // penality if carddraw is late or you have enough cards
            int pen = 0;
            if (!cardDrawBattleCryDatabase.ContainsKey(name)) return 0;
            if (name == CardDB.cardName.ancientoflore && choice != 1) return 0;
            if (name == CardDB.cardName.wrath && choice != 2) return 0;
            if (name == CardDB.cardName.nourish && choice != 2) return 0;
            if (name == CardDB.cardName.grovetender && choice != 2) return 0;

            int carddraw = cardDrawBattleCryDatabase[name];
            if (name == CardDB.cardName.harrisonjones)
            {
                carddraw = p.enemyWeaponDurability;
                if (carddraw == 0 && (p.enemyHeroName != HeroEnum.mage && p.enemyHeroName != HeroEnum.warlock && p.enemyHeroName != HeroEnum.priest)) return 5;
            }
            if (name == CardDB.cardName.divinefavor)
            {
                carddraw = p.enemyAnzCards - (p.owncards.Count);
                if (carddraw <= 0) return 500;
            }

            if (name == CardDB.cardName.battlerage)
            {
                carddraw = 0;
                foreach (Minion mnn in p.ownMinions)
                {
                    if (mnn.wounded) carddraw++;
                }
                if (carddraw == 0) return 500;
            }

            if (name == CardDB.cardName.slam)
            {
                Minion m = target;
                carddraw = 0;
                if (m != null && m.Hp >= 3) carddraw = 1;
                if (carddraw == 0) return 4;
            }

            if (name == CardDB.cardName.mortalcoil)
            {
                Minion m = target;
                carddraw = 0;
                if (m != null && m.Hp == 1) carddraw = 1;
                if (carddraw == 0) return 15;
            }

            if (name == CardDB.cardName.lifetap)
            {
                if (lethal) return 500; //RR no benefit for lethal check
                int minmana = 10;
                bool cardOnLimit = false;
                foreach (Handmanager.Handcard hc in p.owncards)
                {
                    if (hc.manacost <= minmana)
                    {
                        minmana = hc.manacost;
                    }
                    //if (hc.getManaCost(p) == p.ownMaxMana)
                    int manac = hc.getManaCost(p);
                    if (manac > p.ownMaxMana - 2 && manac <= p.ownMaxMana)
                    {
                        cardOnLimit = true;
                    }

                }

                if (Ai.Instance.botBase is BehaviorRush && p.ownMaxMana <= 3 && cardOnLimit) return 6; //RR penalization for drawing the 3 first turns if we have a card in hand that we won't be able to play in Rush


                if (p.owncards.Count + p.cardsPlayedThisTurn <= 5 && minmana > p.ownMaxMana) return 0;
                if (p.owncards.Count + p.cardsPlayedThisTurn > 5) return 25;
                return Math.Max(-carddraw + 2 * p.optionsPlayedThisTurn + p.ownMaxMana - p.mana, 0);
            }

            if (p.owncards.Count + carddraw > 10) return 15 * (p.owncards.Count + carddraw - 10);
            if (p.owncards.Count + p.cardsPlayedThisTurn > 5) return (5 * carddraw) + 1;

            return -carddraw + 2 * p.optionsPlayedThisTurn + p.ownMaxMana - p.mana;
            /*pen = -carddraw + p.ownMaxMana - p.mana;
            return pen;*/
        }

        private int getCardDrawofEffectMinions(CardDB.Card card, Playfield p)
        {
            int pen = 0;
            int carddraw = 0;
            if (card.type == CardDB.cardtype.SPELL)
            {
                foreach (Minion mnn in p.ownMinions)
                {
                    if (mnn.name == CardDB.cardName.gadgetzanauctioneer) carddraw++;
                }
            }

            if (card.type == CardDB.cardtype.MOB && (TAG_RACE)card.race == TAG_RACE.PET)
            {
                foreach (Minion mnn in p.ownMinions)
                {
                    if (mnn.name == CardDB.cardName.starvingbuzzard) carddraw++;
                }
            }

            if (carddraw == 0) return 0;

            if (p.owncards.Count >= 5) return 0;
            pen = -carddraw + p.ownMaxMana - p.mana + p.optionsPlayedThisTurn;

            return pen;
        }

        private int getRandomPenaltiy(CardDB.Card card, Playfield p, Minion target)
        {
            if (p.turnCounter >= 1)
            {
                return 0;
            }

            if (!this.randomEffects.ContainsKey(card.name) && !this.cardDrawBattleCryDatabase.ContainsKey(card.name))
            {
                return 0;
            }

            if (card.name == CardDB.cardName.brawl)
            {
                return 0;
            }

            if ((card.name == CardDB.cardName.cleave || card.name == CardDB.cardName.multishot)
                && p.enemyMinions.Count == 2)
            {
                return 0;
            }

            if ((card.name == CardDB.cardName.deadlyshot) && p.enemyMinions.Count == 1)
            {
                return 0;
            }

            if ((card.name == CardDB.cardName.arcanemissiles || card.name == CardDB.cardName.avengingwrath)
                && p.enemyMinions.Count == 0)
            {
                return 0;
            }

            int cards = 0;
            cards = this.randomEffects.ContainsKey(card.name) ? this.randomEffects[card.name] : this.cardDrawBattleCryDatabase[card.name];

            bool first = true;
            bool hasgadget = false;
            bool hasstarving = false;
            bool hasknife = false;
            foreach (Minion mnn in p.ownMinions)
            {
                if (mnn.name == CardDB.cardName.gadgetzanauctioneer)
                {
                    hasgadget = true;
                }

                if (mnn.name == CardDB.cardName.starvingbuzzard)
                {
                    hasstarving = true;
                }

                if (mnn.name == CardDB.cardName.knifejuggler)
                {
                    hasknife = true;
                }
            }

            foreach (Action a in p.playactions)
            {
                if (a.actionType == actionEnum.attackWithHero)
                {
                    first = false;
                    continue;
                }

                if (a.actionType == actionEnum.useHeroPower
                    && (p.ownHeroName != HeroEnum.shaman && p.ownHeroName != HeroEnum.warlock))
                {
                    first = false;
                    continue;
                }

                if (a.actionType == actionEnum.attackWithMinion)
                {
                    first = false;
                    continue;
                }

                if (a.actionType == actionEnum.playcard)
                {
                    if (card.name == CardDB.cardName.knifejuggler && card.type == CardDB.cardtype.MOB)
                    {
                        continue;
                    }

                    if (this.cardDrawBattleCryDatabase.ContainsKey(a.card.card.name))
                    {
                        continue;
                    }

                    if (hasgadget && card.type == CardDB.cardtype.SPELL)
                    {
                        continue;
                    }

                    if (hasstarving && (TAG_RACE)card.race == TAG_RACE.PET)
                    {
                        continue;
                    }

                    if (hasknife && card.type == CardDB.cardtype.MOB)
                    {
                        continue;
                    }

                    first = false;
                }
            }

            if (first == false)
            {
                return cards + p.playactions.Count + 1;
            }

            return 0;
        }

        private int getCardDiscardPenality(CardDB.cardName name, Playfield p)
        {
            if (p.owncards.Count <= 1) return 0;
            if (p.ownMaxMana <= 3) return 0;
            int pen = 0;
            if (this.cardDiscardDatabase.ContainsKey(name))
            {
                int newmana = p.mana - cardDiscardDatabase[name];
                bool canplayanothercard = false;
                foreach (Handmanager.Handcard hc in p.owncards)
                {
                    if (this.cardDiscardDatabase.ContainsKey(hc.card.name)) continue;
                    if (hc.card.getManaCost(p, hc.manacost) <= newmana)
                    {
                        canplayanothercard = true;
                    }
                }
                if (canplayanothercard) pen += 20;

            }

            return pen;
        }

        private int getDestroyOwnPenality(CardDB.cardName name, Minion target, Playfield p, bool lethal)
        {
            if (!this.destroyOwnDatabase.ContainsKey(name)) return 0;
            int pen = 0;
            if ((name == CardDB.cardName.brawl || name == CardDB.cardName.deathwing || name == CardDB.cardName.twistingnether) && p.mobsplayedThisTurn >= 1) return 500;

            if (name == CardDB.cardName.brawl || name == CardDB.cardName.twistingnether)
            {
                if (name == CardDB.cardName.brawl && p.ownMinions.Count + p.enemyMinions.Count <= 1) return 500;
                int highminion = 0;
                int veryhighminion = 0;
                foreach (Minion m in p.enemyMinions)
                {
                    if (m.Angr >= 5 || m.Hp >= 5) highminion++;
                    if (m.Angr >= 8 || m.Hp >= 8) veryhighminion++;
                }

                if (highminion >= 2 || veryhighminion >= 1)
                {
                    return 0;
                }

                if (p.enemyMinions.Count <= 2 || p.enemyMinions.Count + 2 <= p.ownMinions.Count || p.ownMinions.Count >= 3)
                {
                    return 30;
                }
            }
            if (target == null) return 0;
            if (target.own && !target.isHero)
            {
                // dont destroy owns ;_; (except mins with deathrattle effects)

                Minion m = target;
                if (m.handcard.card.deathrattle) return 10;
                if (lethal && name == CardDB.cardName.sacrificialpact)
                {
                    int beasts = 0;
                    foreach (Minion mm in p.ownMinions)
                    {
                        if (mm.Ready && mm.handcard.card.name == CardDB.cardName.lightwarden) beasts++;
                    }
                    if (beasts == 0) return 500;
                }
                else
                {

                    return 500;
                }
            }

            return pen;
        }

        private int getDestroyPenality(CardDB.cardName name, Minion target, Playfield p, bool lethal)
        {
            if (!this.destroyDatabase.ContainsKey(name) || lethal) return 0;
            int pen = 0;
            if (target == null) return 0;
            if (target.own && !target.isHero)
            {
                Minion m = target;
                if (!m.handcard.card.deathrattle)
                {
                    pen = 500;
                }
            }
            if (!target.own && !target.isHero)
            {
                // dont destroy owns ;_; (except mins with deathrattle effects)

                Minion m = target;

                if (m.allreadyAttacked)
                {
                    return 50;
                }

                if (name == CardDB.cardName.shadowwordpain)
                {
                    if (this.specialMinions.ContainsKey(m.name) || m.Angr == 3 || m.Hp >= 4)
                    {
                        return 0;
                    }

                    if (m.Angr == 2) return 5;

                    return 10;
                }

                if (m.Angr >= 4 || m.Hp >= 5)
                {
                    pen = 0; // so we dont destroy cheap ones :D
                }
                else
                {
                    pen = 30;
                }

                if (name == CardDB.cardName.mindcontrol && (m.name == CardDB.cardName.direwolfalpha || m.name == CardDB.cardName.raidleader || m.name == CardDB.cardName.flametonguetotem) && p.enemyMinions.Count == 1)
                {
                    pen = 50;
                }

            }

            return pen;
        }

        private int getSpecialCardComboPenalitys(CardDB.Card card, Minion target, Playfield p, bool lethal, int choice)
        {
            CardDB.cardName name = card.name;

            if (lethal && card.type == CardDB.cardtype.MOB)
            {
                if (this.lethalHelpers.ContainsKey(name))
                {
                    return 0;
                }

                if (this.buffingMinionsDatabase.ContainsKey(name))
                {
                    if (name == CardDB.cardName.timberwolf || name == CardDB.cardName.houndmaster)
                    {
                        int beasts = 0;
                        foreach (Minion mm in p.ownMinions)
                        {
                            if ((TAG_RACE)mm.handcard.card.race == TAG_RACE.PET) beasts++;
                        }
                        if (beasts == 0) return 500;
                    }
                    if (name == CardDB.cardName.southseacaptain)
                    {
                        int beasts = 0;
                        foreach (Minion mm in p.ownMinions)
                        {
                            if ((TAG_RACE)mm.handcard.card.race == TAG_RACE.PIRATE) beasts++;
                        }
                        if (beasts == 0) return 500;
                    }
                    if (name == CardDB.cardName.murlocwarleader || name == CardDB.cardName.grimscaleoracle || name == CardDB.cardName.coldlightseer)
                    {
                        int beasts = 0;
                        foreach (Minion mm in p.ownMinions)
                        {
                            if ((TAG_RACE)mm.handcard.card.race == TAG_RACE.MURLOC) beasts++;
                        }
                        if (beasts == 0) return 500;
                    }
                }
                else
                {
                    if (name == CardDB.cardName.theblackknight)
                    {
                        int beasts = 0;
                        foreach (Minion mm in p.enemyMinions)
                        {
                            if (mm.taunt) beasts++;
                        }
                        if (beasts == 0) return 500;
                    }
                    else
                    {
                        if ((this.HealTargetDatabase.ContainsKey(name) || this.HealHeroDatabase.ContainsKey(name) || this.HealAllDatabase.ContainsKey(name)))
                        {
                            int beasts = 0;
                            foreach (Minion mm in p.ownMinions)
                            {
                                if (mm.Ready && mm.handcard.card.name == CardDB.cardName.lightwarden) beasts++;
                            }
                            if (beasts == 0) return 500;
                        }
                        else
                        {
                            if (!(name == CardDB.cardName.nightblade || card.Charge || this.silenceDatabase.ContainsKey(name) || ((TAG_RACE)card.race == TAG_RACE.PET && p.ownMinions.Find(x => x.name == CardDB.cardName.tundrarhino) != null) || (p.ownMinions.Find(x => x.name == CardDB.cardName.warsongcommander) != null && card.Attack <= 3) || p.owncards.Find(x => x.card.name == CardDB.cardName.charge) != null))
                            {
                                return 500;
                            }
                        }
                    }
                }
            }

            //lethal end########################################################

            if (card.name == CardDB.cardName.unstableportal && p.owncards.Count <= 9) return -15;

            if (card.name == CardDB.cardName.daggermastery)
            {
                if (p.ownWeaponAttack >= 2 || p.ownWeaponDurability >= 2) return 5;
            }

            if (card.name == CardDB.cardName.upgrade)
            {
                if (p.ownWeaponDurability == 0)
                {
                    return 16;
                }
            }

            if (card.name == CardDB.cardName.baronrivendare)
            {
                foreach (Minion mnn in p.ownMinions)
                {
                    if (mnn.name == CardDB.cardName.deathlord || mnn.name == CardDB.cardName.zombiechow || mnn.name == CardDB.cardName.dancingswords) return 30;
                }
            }

            //rule for coin on early game
            if (p.ownMaxMana < 3 && card.name == CardDB.cardName.thecoin)
            {
                foreach (Handmanager.Handcard hc in p.owncards)
                {
                    if (hc.manacost <= p.ownMaxMana && hc.card.type == CardDB.cardtype.MOB) return 5;
                }

            }

            if (name == CardDB.cardName.flare && p.enemySecretCount >= 1 && p.playactions.Count == 0)
            {
                return -10;
            }

            //some effects, which are bad :D
            int pen = 0;
            if (name == CardDB.cardName.houndmaster)
            {
                if (target == null) return 50;
            }

            if ((card.name == CardDB.cardName.biggamehunter) && (target == null || target.own))
            {
                return 40;
            }
            if (name == CardDB.cardName.aldorpeacekeeper && target == null)
            {
                pen = 30;
            }

            if (name == CardDB.cardName.emergencycoolant && target != null && target.own)//dont freeze own minions
            {
                pen = 500;
            }

            if (name == CardDB.cardName.shatteredsuncleric && target == null) { pen = 10; }
            if (name == CardDB.cardName.argentprotector)
            {
                if (target == null) { pen = 20; }
                else
                {
                    if (!target.own) { return 500; }
                    if (!target.Ready && !target.handcard.card.isSpecialMinion) { pen = 10; }
                    if (!target.Ready && !target.handcard.card.isSpecialMinion && target.Angr <= 2 && target.Hp <= 2) { pen = 15; }
                }

            }

            if (name == CardDB.cardName.facelessmanipulator)
            {
                if (target == null)
                {
                    return 50;
                }
                if (target.Angr >= 5 || target.handcard.card.cost >= 5 || (target.handcard.card.rarity == 5 || target.handcard.card.cost >= 3))
                {
                    return 0;
                }
                return 49;
            }

            if (name == CardDB.cardName.theblackknight)
            {
                if (target == null)
                {
                    return 50;
                }

                foreach (Minion mnn in p.enemyMinions)
                {
                    if (mnn.taunt && (target.Angr >= 3 || target.Hp >= 3)) return 0;
                }
                return 20;
            }

            //------------------------------------------------------------------------------------------------------
            Minion m = target;

            if (card.name == CardDB.cardName.reincarnate)
            {
                if (m.own)
                {
                    if (m.handcard.card.deathrattle || m.ancestralspirit >= 1 || m.souloftheforest >= 1 || m.enemyBlessingOfWisdom >= 1) return 0;
                    if (m.handcard.card.Charge && ((m.numAttacksThisTurn == 1 && !m.windfury) || (m.numAttacksThisTurn == 2 && m.windfury))) return 0;
                    if (m.wounded || m.Angr < m.handcard.card.Attack || (m.silenced && PenalityManager.instance.specialMinions.ContainsKey(m.name))) return 0;


                    bool hasOnMinionDiesMinion = false;
                    foreach (Minion mnn in p.ownMinions)
                    {
                        if (mnn.name == CardDB.cardName.scavenginghyena && m.handcard.card.race == 20) hasOnMinionDiesMinion = true;
                        if (mnn.name == CardDB.cardName.flesheatingghoul || mnn.name == CardDB.cardName.cultmaster) hasOnMinionDiesMinion = true;
                    }
                    if (hasOnMinionDiesMinion) return 0;

                    return 500;
                }
                else
                {
                    if (m.name == CardDB.cardName.nerubianegg && m.Angr <= 4 && !m.taunt) return 500;
                    if (m.taunt && !m.handcard.card.tank) return 0;
                    if (m.enemyBlessingOfWisdom >= 1) return 0;
                    if (m.Angr > m.handcard.card.Attack || m.Hp > m.handcard.card.Health) return 0;
                    if (m.name == CardDB.cardName.abomination || m.name == CardDB.cardName.zombiechow || m.name == CardDB.cardName.unstableghoul || m.name == CardDB.cardName.dancingswords) return 0;
                    return 500;

                }

            }

            if (card.name == CardDB.cardName.knifejuggler && p.mobsplayedThisTurn > 1 || (p.ownHeroName == HeroEnum.shaman && p.ownAbilityReady == false))
            {
                return 20;
            }

            if (card.name == CardDB.cardName.flametonguetotem && p.ownMinions.Count == 0)
            {
                return 100;
            }

            if (card.name == CardDB.cardName.stampedingkodo)
            {
                bool found = false;
                foreach (Minion mi in p.enemyMinions)
                {
                    if (mi.Angr <= 2) found = true;
                }
                if (!found) return 20;
            }

            if (name == CardDB.cardName.windfury)
            {
                if (!m.own) return 500;
                if (m.own && !m.Ready) return 500;
            }

            if ((name == CardDB.cardName.wildgrowth || name == CardDB.cardName.nourish) && p.ownMaxMana == 9 && !(p.ownHeroName == HeroEnum.thief && p.cardsPlayedThisTurn == 0))
            {
                return 500;
            }

            if (name == CardDB.cardName.ancestralspirit)
            {
                if (!target.own && !target.isHero)
                {
                    if (m.name == CardDB.cardName.deathlord || m.name == CardDB.cardName.zombiechow || m.name == CardDB.cardName.dancingswords) return 0;
                    return 500;
                }
                if (target.own && !target.isHero)
                {
                    if (this.specialMinions.ContainsKey(m.name)) return -5;
                    return 0;
                }

            }

            if (name == CardDB.cardName.sap || name == CardDB.cardName.dream || name == CardDB.cardName.kidnapper)
            {
                if (!m.own && m.name == CardDB.cardName.theblackknight)
                {
                    return 50;
                }
            }

            if (name == CardDB.cardName.sylvanaswindrunner)
            {
                if (p.enemyMinions.Count == 0)
                {
                    return 10;
                }
            }

            if (name == CardDB.cardName.betrayal && !target.own && !target.isHero)
            {
                if (m.Angr == 0) return 30;
                if (p.enemyMinions.Count == 1) return 30;
            }




            if (name == CardDB.cardName.bite)
            {
                if ((p.ownHero.numAttacksThisTurn == 0 || (p.ownHero.windfury && p.ownHero.numAttacksThisTurn == 1)) && !p.ownHero.frozen)
                {

                }
                else
                {
                    return 20;
                }
            }

            if (name == CardDB.cardName.deadlypoison)
            {
                return p.ownWeaponDurability * 2;
            }

            if (name == CardDB.cardName.coldblood)
            {
                if (lethal) return 0;
                return 25;
            }

            if (name == CardDB.cardName.bloodmagethalnos)
            {
                return 10;
            }

            if (name == CardDB.cardName.frostbolt)
            {
                if (!target.own && !target.isHero)
                {
                    if (m.handcard.card.cost <= 2)
                        return 15;
                }
                return 15;
            }

            if (!lethal && choice == 1 && name == CardDB.cardName.druidoftheclaw)
            {
                return 20;
            }


            if (name == CardDB.cardName.poweroverwhelming)
            {
                if (target.own && !target.isHero && !m.Ready)
                {
                    return 500;
                }
            }

            if (name == CardDB.cardName.frothingberserker)
            {
                if (p.cardsPlayedThisTurn >= 1) pen = 5;
            }

            if (name == CardDB.cardName.handofprotection)
            {
                if (m.Hp == 1) pen = 15;
            }

            if (lethal)
            {
                if (name == CardDB.cardName.corruption)
                {
                    int beasts = 0;
                    foreach (Minion mm in p.ownMinions)
                    {
                        if (mm.Ready && (mm.handcard.card.name == CardDB.cardName.questingadventurer || mm.handcard.card.name == CardDB.cardName.archmageantonidas || mm.handcard.card.name == CardDB.cardName.manaaddict || mm.handcard.card.name == CardDB.cardName.manawyrm || mm.handcard.card.name == CardDB.cardName.wildpyromancer)) beasts++;
                    }
                    if (beasts == 0) return 500;
                }
            }

            if (name == CardDB.cardName.divinespirit)
            {
                if (lethal)
                {
                    if (!target.own && !target.isHero)
                    {
                        if (!m.taunt)
                        {
                            return 500;
                        }
                        else
                        {
                            // combo for killing with innerfire and biggamehunter
                            if (p.owncards.Find(x => x.card.name == CardDB.cardName.biggamehunter) != null && p.owncards.Find(x => x.card.name == CardDB.cardName.innerfire) != null && (m.Hp >= 4 || (p.owncards.Find(x => x.card.name == CardDB.cardName.divinespirit) != null && m.Hp >= 2)))
                            {
                                return 0;
                            }
                            return 500;
                        }
                    }
                }
                else
                {
                    if (!target.own && !target.isHero)
                    {

                        // combo for killing with innerfire and biggamehunter
                        if (p.owncards.Find(x => x.card.name == CardDB.cardName.biggamehunter) != null && p.owncards.Find(x => x.card.name == CardDB.cardName.innerfire) != null && m.Hp >= 4)
                        {
                            return 0;
                        }
                        return 500;
                    }

                }

                if (target.own && !target.isHero)
                {

                    if (m.Hp >= 4)
                    {
                        return 0;
                    }
                    return 15;
                }

            }



            if (name == CardDB.cardName.knifejuggler)
            {
                if (p.mobsplayedThisTurn >= 1)
                {
                    return 20;
                }
            }

            if ((name == CardDB.cardName.polymorph || name == CardDB.cardName.hex))
            {



                if (target.own && !target.isHero)
                {
                    return 500;
                }

                if (!target.own && !target.isHero)
                {
                    if (target.allreadyAttacked) return 30;
                    Minion frog = target;
                    if (this.priorityTargets.ContainsKey(frog.name)) return 0;
                    if (frog.Angr >= 4 && frog.Hp >= 4) return 0;
                    return 30;
                }

            }


            if ((name == CardDB.cardName.defenderofargus || name == CardDB.cardName.sunfuryprotector) && p.ownMinions.Count == 1)
            {
                return 40;
            }
            if ((name == CardDB.cardName.defenderofargus || name == CardDB.cardName.sunfuryprotector) && p.ownMinions.Count == 0)
            {
                return 50;
            }

            if (name == CardDB.cardName.unleashthehounds)
            {
                if (p.enemyMinions.Count <= 1)
                {
                    return 20;
                }
            }

            if (name == CardDB.cardName.equality) // aoe penality
            {
                if (p.enemyMinions.Count <= 2 || (p.ownMinions.Count - p.enemyMinions.Count >= 1))
                {
                    return 20;
                }
            }

            if (name == CardDB.cardName.bloodsailraider && p.ownWeaponDurability == 0)
            {
                //if you have bloodsailraider and no weapon equiped, but own a weapon:
                foreach (Handmanager.Handcard hc in p.owncards)
                {
                    if (hc.card.type == CardDB.cardtype.WEAPON) return 10;
                }
            }



            if (name == CardDB.cardName.innerfire)
            {
                if (m.name == CardDB.cardName.lightspawn) pen = 500;
            }

            if (name == CardDB.cardName.huntersmark)
            {
                if (target.own && !target.isHero) pen = 500; // dont use on own minions
                if (!target.own && !target.isHero && (target.Hp <= 4) && target.Angr <= 4) // only use on strong minions
                {
                    pen = 20;
                }
            }


            if ((name == CardDB.cardName.aldorpeacekeeper || name == CardDB.cardName.humility))
            {
                if (target != null)
                {
                    if (target.own) pen = 500; // dont use on own minions
                    if (!target.own && target.Angr <= 3) // only use on strong minions
                    {
                        pen = 30;
                    }
                    if (m.name == CardDB.cardName.lightspawn) pen = 500;
                }
                else
                {
                    pen = 50;
                }
            }



            if (name == CardDB.cardName.defiasringleader && p.cardsPlayedThisTurn == 0)
            { pen = 10; }
            if (name == CardDB.cardName.bloodknight)
            {
                int shilds = 0;
                foreach (Minion min in p.ownMinions)
                {
                    if (min.divineshild)
                    {
                        shilds++;
                    }
                }
                foreach (Minion min in p.enemyMinions)
                {
                    if (min.divineshild)
                    {
                        shilds++;
                    }
                }
                if (shilds == 0)
                {
                    pen = 10;
                }
            }
            if (name == CardDB.cardName.direwolfalpha)
            {
                int ready = 0;
                foreach (Minion min in p.ownMinions)
                {
                    if (min.Ready)
                    { ready++; }
                }
                if (ready == 0)
                { pen = 5; }
            }
            if (name == CardDB.cardName.abusivesergeant)
            {
                int ready = 0;
                foreach (Minion min in p.ownMinions)
                {
                    if (min.Ready)
                    { ready++; }
                }
                if (ready == 0)
                {
                    pen = 5;
                }
            }


            if (returnHandDatabase.ContainsKey(name))
            {
                if (name == CardDB.cardName.vanish)
                {
                    //dont vanish if we have minons on board wich are ready
                    bool haveready = false;
                    foreach (Minion mins in p.ownMinions)
                    {
                        if (mins.Ready) haveready = true;
                    }
                    if (haveready) pen += 10;
                }

                if (target.own && !target.isHero)
                {
                    Minion mnn = target;
                    if (mnn.Ready) pen += 10;
                }
            }

            return pen;
        }

        private int playSecretPenality(CardDB.Card card, Playfield p)
        {
            //penality if we play secret and have playable kirintormage
            int pen = 0;
            if (card.Secret)
            {
                foreach (Handmanager.Handcard hc in p.owncards)
                {
                    if (hc.card.name == CardDB.cardName.kirintormage && p.mana >= hc.getManaCost(p))
                    {
                        pen = 500;
                    }
                }
            }

            return pen;
        }

        ///secret strategys pala
        /// -Attack lowest enemy. If you can’t, use noncombat means to kill it. 
        /// -attack with something able to withstand 2 damage. 
        /// -Then play something that had low health to begin with to dodge Repentance. 
        /// 
        ///secret strategys hunter
        /// - kill enemys with your minions with 2 or less heal.
        ///  - Use the smallest minion available for the first attack 
        ///  - Then smack them in the face with whatever’s left. 
        ///  - If nothing triggered until then, it’s a Snipe, so throw something in front of it that won’t die or is expendable.
        /// 
        ///secret strategys mage
        /// - Play a small minion to trigger Mirror Entity.
        /// Then attack the mage directly with the smallest minion on your side. 
        /// If nothing triggered by that point, it’s either Spellbender or Counterspell, so hold your spells until you can (and have to!) deal with either. 

        private int getPlayCardSecretPenality(CardDB.Card c, Playfield p)
        {
            int pen = 0;
            if (p.enemySecretCount == 0)
            {
                return 0;
            }

            if (c.name == CardDB.cardName.flare)
            {
                return 0;
            }

            int attackedbefore = 0;

            foreach (Minion mnn in p.ownMinions)
            {
                if (mnn.numAttacksThisTurn >= 1)
                {
                    attackedbefore++;
                }
            }

            if (c.name == CardDB.cardName.acidicswampooze
                && (p.enemyHeroName == HeroEnum.warrior || p.enemyHeroName == HeroEnum.thief
                    || p.enemyHeroName == HeroEnum.pala))
            {
                if (p.enemyHeroName == HeroEnum.thief && p.enemyWeaponAttack <= 2)
                {
                    pen += 100;
                }
                else
                {
                    if (p.enemyWeaponAttack <= 1)
                    {
                        pen += 100;
                    }
                }
            }

            if (p.enemyHeroName == HeroEnum.hunter)
            {
                if (c.type == CardDB.cardtype.MOB
                    && (attackedbefore == 0 || c.Health <= 4
                        || (p.enemyHero.Hp >= p.enemyHeroHpStarted && attackedbefore >= 1)))
                {
                    pen += 10;
                }
            }

            if (p.enemyHeroName == HeroEnum.mage)
            {
                if (c.type == CardDB.cardtype.MOB)
                {
                    Minion m = new Minion
                    {
                        Hp = c.Health,
                        maxHp = c.Health,
                        Angr = c.Attack,
                        taunt = c.tank,
                        name = c.name
                    };

                    // play first the small minion:
                    if ((!this.isOwnLowestInHand(m, p) && p.mobsplayedThisTurn == 0)
                        || (p.mobsplayedThisTurn == 0 && attackedbefore >= 1))
                    {
                        pen += 10;
                    }
                }

                if (c.type == CardDB.cardtype.SPELL && p.cardsPlayedThisTurn == p.mobsplayedThisTurn)
                {
                    pen += 10;
                }
            }

            if (p.enemyHeroName == HeroEnum.pala)
            {
                if (c.type == CardDB.cardtype.MOB)
                {
                    Minion m = new Minion
                    {
                        Hp = c.Health,
                        maxHp = c.Health,
                        Angr = c.Attack,
                        taunt = c.tank,
                        name = c.name
                    };
                    if ((!this.isOwnLowestInHand(m, p) && p.mobsplayedThisTurn == 0) || attackedbefore == 0)
                    {
                        pen += 10;
                    }
                }
            }

            return pen;
        }

        private int getAttackSecretPenality(Minion m, Playfield p, Minion target)
        {
            if (p.enemySecretCount == 0)
            {
                return 0;
            }

            int pen = 0;

            int attackedbefore = 0;

            foreach (Minion mnn in p.ownMinions)
            {
                if (mnn.numAttacksThisTurn >= 1) attackedbefore++;
            }

            if (p.enemyHeroName == HeroEnum.hunter)
            {
                bool islow = isOwnLowest(m, p);
                if (attackedbefore == 0 && islow) pen -= 20;
                if (attackedbefore == 0 && !islow) pen += 10;

                if (target.isHero && !target.own && p.enemyMinions.Count >= 1)
                {
                    //penality if we doestn attacked before
                    if (hasMinionsWithLowHeal(p)) pen += 10; //penality if we doestn attacked minions before
                }
            }

            if (p.enemyHeroName == HeroEnum.mage)
            {
                if (p.mobsplayedThisTurn == 0) pen += 10;

                bool islow = isOwnLowest(m, p);

                if (target.isHero && !target.own && !islow)
                {
                    pen += 10;
                }
                if (target.isHero && !target.own && islow && p.mobsplayedThisTurn >= 1)
                {
                    pen -= 20;
                }

            }

            if (p.enemyHeroName == HeroEnum.pala)
            {

                bool islow = isOwnLowest(m, p);

                if (!target.own && !target.isHero && attackedbefore == 0)
                {
                    if (!isEnemyLowest(target, p) || m.Hp <= 2) pen += 5;
                }

                if (target.isHero && !target.own && !islow)
                {
                    pen += 5;
                }

                if (target.isHero && !target.own && p.enemyMinions.Count >= 1 && attackedbefore == 0)
                {
                    pen += 5;
                }

            }


            return pen;
        }






        private int getValueOfMinion(Minion m)
        {
            int ret = 0;
            ret += 2 * m.Angr + m.Hp;
            if (m.taunt) ret += 2;
            if (this.priorityDatabase.ContainsKey(m.name)) ret += 20 + priorityDatabase[m.name];
            return ret;
        }

        private bool isOwnLowest(Minion mnn, Playfield p)
        {
            bool ret = true;
            int val = getValueOfMinion(mnn);
            foreach (Minion m in p.ownMinions)
            {
                if (!m.Ready) continue;
                if (getValueOfMinion(m) < val) ret = false;
            }
            return ret;
        }

        private bool isOwnLowestInHand(Minion mnn, Playfield p)
        {
            bool ret = true;
            Minion m = new Minion();
            int val = getValueOfMinion(mnn);
            foreach (Handmanager.Handcard card in p.owncards)
            {
                if (card.card.type != CardDB.cardtype.MOB) continue;
                CardDB.Card c = card.card;
                m.Hp = c.Health;
                m.maxHp = c.Health;
                m.Angr = c.Attack;
                m.taunt = c.tank;
                m.name = c.name;
                if (getValueOfMinion(m) < val) ret = false;
            }
            return ret;
        }

        private int getValueOfEnemyMinion(Minion m)
        {
            int ret = 0;
            ret += m.Hp;
            if (m.taunt) ret -= 2;
            return ret;
        }

        private bool isEnemyLowest(Minion mnn, Playfield p)
        {
            bool ret = true;
            List<Minion> litt = p.getAttackTargets(true);
            int val = getValueOfEnemyMinion(mnn);
            foreach (Minion m in p.enemyMinions)
            {
                if (litt.Find(x => x.entitiyID == m.entitiyID) == null) continue;
                if (getValueOfEnemyMinion(m) < val) ret = false;
            }
            return ret;
        }

        private bool hasMinionsWithLowHeal(Playfield p)
        {
            bool ret = false;
            foreach (Minion m in p.ownMinions)
            {
                if (m.Hp <= 2 && (m.Ready || this.priorityDatabase.ContainsKey(m.name))) ret = true;
            }
            return ret;
        }

        private void setupEnrageDatabase()
        {
            enrageDatabase.Add(CardDB.cardName.amaniberserker, 0);
            enrageDatabase.Add(CardDB.cardName.angrychicken, 0);
            enrageDatabase.Add(CardDB.cardName.grommashhellscream, 0);
            enrageDatabase.Add(CardDB.cardName.ragingworgen, 0);
            enrageDatabase.Add(CardDB.cardName.spitefulsmith, 0);
            enrageDatabase.Add(CardDB.cardName.taurenwarrior, 0);
            enrageDatabase.Add(CardDB.cardName.warbot, 0);
        }

        private void setupHealDatabase()
        {
            HealAllDatabase.Add(CardDB.cardName.holynova, 2);//to all own minions
            HealAllDatabase.Add(CardDB.cardName.circleofhealing, 4);//allminions
            HealAllDatabase.Add(CardDB.cardName.darkscalehealer, 2);//all friends
            HealAllDatabase.Add(CardDB.cardName.treeoflife, 100);//all friends

            HealHeroDatabase.Add(CardDB.cardName.drainlife, 2);//tohero
            HealHeroDatabase.Add(CardDB.cardName.guardianofkings, 6);//tohero
            HealHeroDatabase.Add(CardDB.cardName.holyfire, 5);//tohero
            HealHeroDatabase.Add(CardDB.cardName.priestessofelune, 4);//tohero
            HealHeroDatabase.Add(CardDB.cardName.sacrificialpact, 5);//tohero
            HealHeroDatabase.Add(CardDB.cardName.siphonsoul, 3); //tohero
            HealHeroDatabase.Add(CardDB.cardName.sealoflight, 4); //tohero
            HealHeroDatabase.Add(CardDB.cardName.antiquehealbot, 8); //tohero

            HealTargetDatabase.Add(CardDB.cardName.lightofthenaaru, 3);
            HealTargetDatabase.Add(CardDB.cardName.ancestralhealing, 1000);
            HealTargetDatabase.Add(CardDB.cardName.ancientsecrets, 5);
            HealTargetDatabase.Add(CardDB.cardName.holylight, 6);
            HealTargetDatabase.Add(CardDB.cardName.earthenringfarseer, 3);
            HealTargetDatabase.Add(CardDB.cardName.healingtouch, 8);
            HealTargetDatabase.Add(CardDB.cardName.layonhands, 8);
            HealTargetDatabase.Add(CardDB.cardName.lesserheal, 2);
            HealTargetDatabase.Add(CardDB.cardName.voodoodoctor, 2);
            HealTargetDatabase.Add(CardDB.cardName.willofmukla, 8);
            HealTargetDatabase.Add(CardDB.cardName.ancientoflore, 5);
            //HealTargetDatabase.Add(CardDB.cardName.divinespirit, 2);
        }

        private void setupDamageDatabase()
        {

            DamageHeroDatabase.Add(CardDB.cardName.headcrack, 2);
            DamageHeroDatabase.Add(CardDB.cardName.shadowbomber, 2);

            DamageAllDatabase.Add(CardDB.cardName.abomination, 2);
            DamageAllDatabase.Add(CardDB.cardName.dreadinfernal, 1);
            DamageAllDatabase.Add(CardDB.cardName.hellfire, 3);
            DamageAllDatabase.Add(CardDB.cardName.whirlwind, 1);
            DamageAllDatabase.Add(CardDB.cardName.yseraawakens, 5);
            DamageAllDatabase.Add(CardDB.cardName.lightbomb, 5);

            DamageAllEnemysDatabase.Add(CardDB.cardName.arcaneexplosion, 1);
            DamageAllEnemysDatabase.Add(CardDB.cardName.shadowflame, 2);
            DamageAllEnemysDatabase.Add(CardDB.cardName.consecration, 1);
            DamageAllEnemysDatabase.Add(CardDB.cardName.fanofknives, 1);
            DamageAllEnemysDatabase.Add(CardDB.cardName.flamestrike, 4);
            DamageAllEnemysDatabase.Add(CardDB.cardName.holynova, 2);
            DamageAllEnemysDatabase.Add(CardDB.cardName.lightningstorm, 2);
            DamageAllEnemysDatabase.Add(CardDB.cardName.stomp, 1);
            DamageAllEnemysDatabase.Add(CardDB.cardName.madbomber, 1);
            DamageAllEnemysDatabase.Add(CardDB.cardName.swipe, 4);//1 to others
            DamageAllEnemysDatabase.Add(CardDB.cardName.bladeflurry, 1);

            DamageRandomDatabase.Add(CardDB.cardName.goblinblastmage, 1);
            DamageRandomDatabase.Add(CardDB.cardName.flamecannon, 4);
            DamageRandomDatabase.Add(CardDB.cardName.arcanemissiles, 1);
            DamageRandomDatabase.Add(CardDB.cardName.avengingwrath, 1);
            DamageRandomDatabase.Add(CardDB.cardName.cleave, 2);
            DamageRandomDatabase.Add(CardDB.cardName.forkedlightning, 2);
            DamageRandomDatabase.Add(CardDB.cardName.multishot, 3);

            DamageTargetSpecialDatabase.Add(CardDB.cardName.crueltaskmaster, 1); // gives 2 attack
            DamageTargetSpecialDatabase.Add(CardDB.cardName.innerrage, 1); // gives 2 attack

            DamageTargetSpecialDatabase.Add(CardDB.cardName.demonfire, 2); // friendly demon get +2/+2
            DamageTargetSpecialDatabase.Add(CardDB.cardName.demonheart, 5);
            DamageTargetSpecialDatabase.Add(CardDB.cardName.earthshock, 1); //SILENCE /good for raggy etc or iced
            DamageTargetSpecialDatabase.Add(CardDB.cardName.hammerofwrath, 3); //draw a card
            DamageTargetSpecialDatabase.Add(CardDB.cardName.holywrath, 2);//draw a card
            DamageTargetSpecialDatabase.Add(CardDB.cardName.roguesdoit, 4);//draw a card
            DamageTargetSpecialDatabase.Add(CardDB.cardName.shiv, 1);//draw a card
            DamageTargetSpecialDatabase.Add(CardDB.cardName.savagery, 1);//dmg=herodamage
            DamageTargetSpecialDatabase.Add(CardDB.cardName.shieldslam, 1);//dmg=armor
            DamageTargetSpecialDatabase.Add(CardDB.cardName.slam, 2);//draw card if it survives
            DamageTargetSpecialDatabase.Add(CardDB.cardName.soulfire, 4);//delete a card


            DamageTargetDatabase.Add(CardDB.cardName.keeperofthegrove, 2); // or silence
            DamageTargetDatabase.Add(CardDB.cardName.wrath, 3);//or 1 + card

            DamageTargetDatabase.Add(CardDB.cardName.steadyshot, 2);//or 1 + card
            DamageTargetDatabase.Add(CardDB.cardName.coneofcold, 1);
            DamageTargetDatabase.Add(CardDB.cardName.arcaneshot, 2);
            DamageTargetDatabase.Add(CardDB.cardName.backstab, 2);
            DamageTargetDatabase.Add(CardDB.cardName.baneofdoom, 2);
            DamageTargetDatabase.Add(CardDB.cardName.barreltoss, 2);
            DamageTargetDatabase.Add(CardDB.cardName.blizzard, 2);
            DamageTargetDatabase.Add(CardDB.cardName.drainlife, 2);
            DamageTargetDatabase.Add(CardDB.cardName.elvenarcher, 1);
            DamageTargetDatabase.Add(CardDB.cardName.eviscerate, 3);
            DamageTargetDatabase.Add(CardDB.cardName.explosiveshot, 5);
            DamageTargetDatabase.Add(CardDB.cardName.fireelemental, 3);
            DamageTargetDatabase.Add(CardDB.cardName.fireball, 6);
            DamageTargetDatabase.Add(CardDB.cardName.fireblast, 1);
            DamageTargetDatabase.Add(CardDB.cardName.frostshock, 1);
            DamageTargetDatabase.Add(CardDB.cardName.frostbolt, 1);
            DamageTargetDatabase.Add(CardDB.cardName.hoggersmash, 4);
            DamageTargetDatabase.Add(CardDB.cardName.holyfire, 5);
            DamageTargetDatabase.Add(CardDB.cardName.holysmite, 2);
            DamageTargetDatabase.Add(CardDB.cardName.icelance, 4);//only if iced
            DamageTargetDatabase.Add(CardDB.cardName.ironforgerifleman, 1);
            DamageTargetDatabase.Add(CardDB.cardName.killcommand, 3);//or 5
            DamageTargetDatabase.Add(CardDB.cardName.lavaburst, 5);
            DamageTargetDatabase.Add(CardDB.cardName.lightningbolt, 2);
            DamageTargetDatabase.Add(CardDB.cardName.mindshatter, 3);
            DamageTargetDatabase.Add(CardDB.cardName.mindspike, 2);
            DamageTargetDatabase.Add(CardDB.cardName.moonfire, 1);
            DamageTargetDatabase.Add(CardDB.cardName.mortalcoil, 1);
            DamageTargetDatabase.Add(CardDB.cardName.mortalstrike, 4);
            DamageTargetDatabase.Add(CardDB.cardName.perditionsblade, 1);
            DamageTargetDatabase.Add(CardDB.cardName.pyroblast, 10);
            DamageTargetDatabase.Add(CardDB.cardName.shadowbolt, 4);
            DamageTargetDatabase.Add(CardDB.cardName.shotgunblast, 1);
            DamageTargetDatabase.Add(CardDB.cardName.si7agent, 2);
            DamageTargetDatabase.Add(CardDB.cardName.starfall, 5);
            DamageTargetDatabase.Add(CardDB.cardName.starfire, 5);//draw a card, but its to strong
            DamageTargetDatabase.Add(CardDB.cardName.stormpikecommando, 5);

            DamageTargetDatabase.Add(CardDB.cardName.darkbomb, 3);
            DamageTargetDatabase.Add(CardDB.cardName.crackle, 3);
            DamageTargetDatabase.Add(CardDB.cardName.implosion, 2);
            DamageTargetDatabase.Add(CardDB.cardName.cobrashot, 3);



        }

        private void setupsilenceDatabase()
        {
            this.silenceDatabase.Add(CardDB.cardName.dispel, 1);
            this.silenceDatabase.Add(CardDB.cardName.earthshock, 1);
            this.silenceDatabase.Add(CardDB.cardName.massdispel, 1);
            this.silenceDatabase.Add(CardDB.cardName.silence, 1);
            this.silenceDatabase.Add(CardDB.cardName.keeperofthegrove, 1);
            this.silenceDatabase.Add(CardDB.cardName.ironbeakowl, 1);
            this.silenceDatabase.Add(CardDB.cardName.spellbreaker, 1);
        }

        private void setupPriorityList()
        {
            this.priorityDatabase.Add(CardDB.cardName.prophetvelen, 5);
            this.priorityDatabase.Add(CardDB.cardName.archmageantonidas, 5);
            this.priorityDatabase.Add(CardDB.cardName.flametonguetotem, 6);
            this.priorityDatabase.Add(CardDB.cardName.raidleader, 5);
            this.priorityDatabase.Add(CardDB.cardName.grimscaleoracle, 5);
            this.priorityDatabase.Add(CardDB.cardName.direwolfalpha, 6);
            this.priorityDatabase.Add(CardDB.cardName.murlocwarleader, 5);
            this.priorityDatabase.Add(CardDB.cardName.southseacaptain, 5);
            this.priorityDatabase.Add(CardDB.cardName.stormwindchampion, 5);
            this.priorityDatabase.Add(CardDB.cardName.timberwolf, 5);
            this.priorityDatabase.Add(CardDB.cardName.leokk, 5);
            this.priorityDatabase.Add(CardDB.cardName.northshirecleric, 5);
            this.priorityDatabase.Add(CardDB.cardName.sorcerersapprentice, 3);
            this.priorityDatabase.Add(CardDB.cardName.summoningportal, 5);
            this.priorityDatabase.Add(CardDB.cardName.pintsizedsummoner, 3);
            this.priorityDatabase.Add(CardDB.cardName.scavenginghyena, 5);
            this.priorityDatabase.Add(CardDB.cardName.manatidetotem, 5);
        }

        private void setupAttackBuff()
        {
            heroAttackBuffDatabase.Add(CardDB.cardName.bite, 4);
            heroAttackBuffDatabase.Add(CardDB.cardName.claw, 2);
            heroAttackBuffDatabase.Add(CardDB.cardName.heroicstrike, 2);

            this.attackBuffDatabase.Add(CardDB.cardName.abusivesergeant, 2);
            this.attackBuffDatabase.Add(CardDB.cardName.bananas, 1);
            this.attackBuffDatabase.Add(CardDB.cardName.bestialwrath, 2); // NEVER ON enemy MINION
            this.attackBuffDatabase.Add(CardDB.cardName.blessingofkings, 4);
            this.attackBuffDatabase.Add(CardDB.cardName.blessingofmight, 3);
            this.attackBuffDatabase.Add(CardDB.cardName.coldblood, 2);
            this.attackBuffDatabase.Add(CardDB.cardName.crueltaskmaster, 2);
            this.attackBuffDatabase.Add(CardDB.cardName.darkirondwarf, 2);
            this.attackBuffDatabase.Add(CardDB.cardName.innerrage, 2);
            this.attackBuffDatabase.Add(CardDB.cardName.markofnature, 4);//choice1 
            this.attackBuffDatabase.Add(CardDB.cardName.markofthewild, 2);
            this.attackBuffDatabase.Add(CardDB.cardName.nightmare, 5); //destroy minion on next turn
            this.attackBuffDatabase.Add(CardDB.cardName.rampage, 3);//only damaged minion 
            this.attackBuffDatabase.Add(CardDB.cardName.uproot, 5);
            this.attackBuffDatabase.Add(CardDB.cardName.velenschosen, 2);

            this.attackBuffDatabase.Add(CardDB.cardName.darkwispers, 5);//choice 2
            this.attackBuffDatabase.Add(CardDB.cardName.whirlingblades, 1);

        }

        private void setupHealthBuff()
        {

            //this.healthBuffDatabase.Add(CardDB.cardName.ancientofwar, 5);//choice2 is only buffing himself!
            this.healthBuffDatabase.Add(CardDB.cardName.bananas, 1);
            this.healthBuffDatabase.Add(CardDB.cardName.blessingofkings, 4);
            this.healthBuffDatabase.Add(CardDB.cardName.markofnature, 4);//choice2
            this.healthBuffDatabase.Add(CardDB.cardName.markofthewild, 2);
            this.healthBuffDatabase.Add(CardDB.cardName.nightmare, 5);
            this.healthBuffDatabase.Add(CardDB.cardName.powerwordshield, 2);
            this.healthBuffDatabase.Add(CardDB.cardName.rampage, 3);
            this.healthBuffDatabase.Add(CardDB.cardName.velenschosen, 4);
            this.healthBuffDatabase.Add(CardDB.cardName.darkwispers, 5);//choice2
            this.healthBuffDatabase.Add(CardDB.cardName.upgradedrepairbot, 4);
            this.healthBuffDatabase.Add(CardDB.cardName.armorplating, 1);
            //this.healthBuffDatabase.Add(CardDB.cardName.rooted, 5);

            this.tauntBuffDatabase.Add(CardDB.cardName.markofnature, 1);
            this.tauntBuffDatabase.Add(CardDB.cardName.markofthewild, 1);
            this.tauntBuffDatabase.Add(CardDB.cardName.darkwispers, 1);
            this.tauntBuffDatabase.Add(CardDB.cardName.rustyhorn, 1);

            //this.tauntBuffDatabase.Add(CardDB.cardName.rooted, 1);


        }

        private void setupCardDrawBattlecry()
        {
            cardDrawBattleCryDatabase.Add(CardDB.cardName.wrath, 1); //choice=2
            cardDrawBattleCryDatabase.Add(CardDB.cardName.ancientoflore, 2);// choice =1
            cardDrawBattleCryDatabase.Add(CardDB.cardName.nourish, 3); //choice = 2
            cardDrawBattleCryDatabase.Add(CardDB.cardName.grovetender, 1); //choice = 2

            cardDrawBattleCryDatabase.Add(CardDB.cardName.ancientteachings, 2);



            cardDrawBattleCryDatabase.Add(CardDB.cardName.excessmana, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.starfire, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.azuredrake, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.coldlightoracle, 2);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.gnomishinventor, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.harrisonjones, 0);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.noviceengineer, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.roguesdoit, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.arcaneintellect, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.hammerofwrath, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.holywrath, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.layonhands, 3);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.massdispel, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.powerwordshield, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.fanofknives, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.shiv, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.sprint, 4);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.farsight, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.lifetap, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.commandingshout, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.shieldblock, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.slam, 1); //if survives
            cardDrawBattleCryDatabase.Add(CardDB.cardName.mortalcoil, 1);//only if kills
            cardDrawBattleCryDatabase.Add(CardDB.cardName.battlerage, 1);//only if wounded own minions
            cardDrawBattleCryDatabase.Add(CardDB.cardName.divinefavor, 1);//only if enemy has more cards than you

            cardDrawBattleCryDatabase.Add(CardDB.cardName.neptulon, 4);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.gnomishexperimenter, 4);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.unstableportal, 1);
            cardDrawBattleCryDatabase.Add(CardDB.cardName.callpet, 1);
        }

        private void setupDiscardCards()
        {
            cardDiscardDatabase.Add(CardDB.cardName.doomguard, 5);
            cardDiscardDatabase.Add(CardDB.cardName.soulfire, 0);
            cardDiscardDatabase.Add(CardDB.cardName.succubus, 2);
        }

        private void setupDestroyOwnCards()
        {
            this.destroyOwnDatabase.Add(CardDB.cardName.brawl, 0);
            this.destroyOwnDatabase.Add(CardDB.cardName.deathwing, 0);
            this.destroyOwnDatabase.Add(CardDB.cardName.twistingnether, 0);
            this.destroyOwnDatabase.Add(CardDB.cardName.naturalize, 0);//not own mins
            this.destroyOwnDatabase.Add(CardDB.cardName.shadowworddeath, 0);//not own mins
            this.destroyOwnDatabase.Add(CardDB.cardName.shadowwordpain, 0);//not own mins
            this.destroyOwnDatabase.Add(CardDB.cardName.siphonsoul, 0);//not own mins
            this.destroyOwnDatabase.Add(CardDB.cardName.biggamehunter, 0);//not own mins
            this.destroyOwnDatabase.Add(CardDB.cardName.hungrycrab, 0);//not own mins
            this.destroyOwnDatabase.Add(CardDB.cardName.sacrificialpact, 0);//not own mins

            this.destroyDatabase.Add(CardDB.cardName.assassinate, 0);//not own mins
            this.destroyDatabase.Add(CardDB.cardName.corruption, 0);//not own mins
            this.destroyDatabase.Add(CardDB.cardName.execute, 0);//not own mins
            this.destroyDatabase.Add(CardDB.cardName.naturalize, 0);//not own mins
            this.destroyDatabase.Add(CardDB.cardName.siphonsoul, 0);//not own mins
            this.destroyDatabase.Add(CardDB.cardName.mindcontrol, 0);//not own mins
            this.destroyDatabase.Add(CardDB.cardName.theblackknight, 0);//not own mins
            this.destroyDatabase.Add(CardDB.cardName.sabotage, 0);//not own mins
            this.destroyDatabase.Add(CardDB.cardName.crush, 0);//not own mins
            this.destroyDatabase.Add(CardDB.cardName.hemetnesingwary, 0);//not own mins

        }

        private void setupReturnBackToHandCards()
        {
            returnHandDatabase.Add(CardDB.cardName.ancientbrewmaster, 0);
            returnHandDatabase.Add(CardDB.cardName.dream, 0);
            returnHandDatabase.Add(CardDB.cardName.kidnapper, 0);//if combo
            returnHandDatabase.Add(CardDB.cardName.shadowstep, 0);
            returnHandDatabase.Add(CardDB.cardName.vanish, 0);
            returnHandDatabase.Add(CardDB.cardName.youthfulbrewmaster, 0);
            returnHandDatabase.Add(CardDB.cardName.timerewinder, 0);
            returnHandDatabase.Add(CardDB.cardName.recycle, 0);
        }

        private void setupHeroDamagingAOE()
        {
            this.heroDamagingAoeDatabase.Add(CardDB.cardName.unknown, 0);
        }

        private void setupSpecialMins()
        {
            this.specialMinions.Add(CardDB.cardName.amaniberserker, 0);
            this.specialMinions.Add(CardDB.cardName.angrychicken, 0);
            this.specialMinions.Add(CardDB.cardName.abomination, 0);
            this.specialMinions.Add(CardDB.cardName.acolyteofpain, 0);
            this.specialMinions.Add(CardDB.cardName.alarmobot, 0);
            this.specialMinions.Add(CardDB.cardName.archmage, 0);
            this.specialMinions.Add(CardDB.cardName.archmageantonidas, 0);
            this.specialMinions.Add(CardDB.cardName.armorsmith, 0);
            this.specialMinions.Add(CardDB.cardName.auchenaisoulpriest, 0);
            this.specialMinions.Add(CardDB.cardName.azuredrake, 0);
            this.specialMinions.Add(CardDB.cardName.barongeddon, 0);
            this.specialMinions.Add(CardDB.cardName.bloodimp, 0);
            this.specialMinions.Add(CardDB.cardName.bloodmagethalnos, 0);
            this.specialMinions.Add(CardDB.cardName.cairnebloodhoof, 0);
            this.specialMinions.Add(CardDB.cardName.cultmaster, 0);
            this.specialMinions.Add(CardDB.cardName.dalaranmage, 0);
            this.specialMinions.Add(CardDB.cardName.demolisher, 0);
            this.specialMinions.Add(CardDB.cardName.direwolfalpha, 0);
            this.specialMinions.Add(CardDB.cardName.doomsayer, 0);
            this.specialMinions.Add(CardDB.cardName.emperorcobra, 0);
            this.specialMinions.Add(CardDB.cardName.etherealarcanist, 0);
            this.specialMinions.Add(CardDB.cardName.flametonguetotem, 0);
            this.specialMinions.Add(CardDB.cardName.flesheatingghoul, 0);
            this.specialMinions.Add(CardDB.cardName.gadgetzanauctioneer, 0);
            this.specialMinions.Add(CardDB.cardName.grimscaleoracle, 0);
            this.specialMinions.Add(CardDB.cardName.grommashhellscream, 0);
            this.specialMinions.Add(CardDB.cardName.gruul, 0);
            this.specialMinions.Add(CardDB.cardName.gurubashiberserker, 0);
            this.specialMinions.Add(CardDB.cardName.harvestgolem, 0);
            this.specialMinions.Add(CardDB.cardName.hogger, 0);
            this.specialMinions.Add(CardDB.cardName.illidanstormrage, 0);
            this.specialMinions.Add(CardDB.cardName.impmaster, 0);
            this.specialMinions.Add(CardDB.cardName.knifejuggler, 0);
            this.specialMinions.Add(CardDB.cardName.koboldgeomancer, 0);
            this.specialMinions.Add(CardDB.cardName.lepergnome, 0);
            this.specialMinions.Add(CardDB.cardName.lightspawn, 0);
            this.specialMinions.Add(CardDB.cardName.lightwarden, 0);
            this.specialMinions.Add(CardDB.cardName.lightwell, 0);
            this.specialMinions.Add(CardDB.cardName.loothoarder, 0);
            this.specialMinions.Add(CardDB.cardName.lorewalkercho, 0);
            this.specialMinions.Add(CardDB.cardName.malygos, 0);
            this.specialMinions.Add(CardDB.cardName.manaaddict, 0);
            this.specialMinions.Add(CardDB.cardName.manatidetotem, 0);
            this.specialMinions.Add(CardDB.cardName.manawraith, 0);
            this.specialMinions.Add(CardDB.cardName.manawyrm, 0);
            this.specialMinions.Add(CardDB.cardName.masterswordsmith, 0);
            this.specialMinions.Add(CardDB.cardName.murloctidecaller, 0);
            this.specialMinions.Add(CardDB.cardName.murlocwarleader, 0);
            this.specialMinions.Add(CardDB.cardName.natpagle, 0);
            this.specialMinions.Add(CardDB.cardName.northshirecleric, 0);
            this.specialMinions.Add(CardDB.cardName.ogremagi, 0);
            this.specialMinions.Add(CardDB.cardName.oldmurkeye, 0);
            this.specialMinions.Add(CardDB.cardName.patientassassin, 0);
            this.specialMinions.Add(CardDB.cardName.pintsizedsummoner, 0);
            this.specialMinions.Add(CardDB.cardName.prophetvelen, 0);
            this.specialMinions.Add(CardDB.cardName.questingadventurer, 0);
            this.specialMinions.Add(CardDB.cardName.ragingworgen, 0);
            this.specialMinions.Add(CardDB.cardName.raidleader, 0);
            this.specialMinions.Add(CardDB.cardName.savannahhighmane, 0);
            this.specialMinions.Add(CardDB.cardName.scavenginghyena, 0);
            this.specialMinions.Add(CardDB.cardName.secretkeeper, 0);
            this.specialMinions.Add(CardDB.cardName.sorcerersapprentice, 0);
            this.specialMinions.Add(CardDB.cardName.southseacaptain, 0);
            this.specialMinions.Add(CardDB.cardName.spitefulsmith, 0);
            this.specialMinions.Add(CardDB.cardName.starvingbuzzard, 0);
            this.specialMinions.Add(CardDB.cardName.stormwindchampion, 0);
            this.specialMinions.Add(CardDB.cardName.summoningportal, 0);
            this.specialMinions.Add(CardDB.cardName.sylvanaswindrunner, 0);
            this.specialMinions.Add(CardDB.cardName.taurenwarrior, 0);
            this.specialMinions.Add(CardDB.cardName.thebeast, 0);
            this.specialMinions.Add(CardDB.cardName.timberwolf, 0);
            this.specialMinions.Add(CardDB.cardName.tirionfordring, 0);
            this.specialMinions.Add(CardDB.cardName.tundrarhino, 0);
            this.specialMinions.Add(CardDB.cardName.unboundelemental, 0);
            //this.specialMinions.Add(CardDB.cardName.venturecomercenary, 0);
            this.specialMinions.Add(CardDB.cardName.violetteacher, 0);
            this.specialMinions.Add(CardDB.cardName.warsongcommander, 0);
            this.specialMinions.Add(CardDB.cardName.waterelemental, 0);

            // naxx cards
            this.specialMinions.Add(CardDB.cardName.baronrivendare, 0);
            this.specialMinions.Add(CardDB.cardName.undertaker, 0);
            this.specialMinions.Add(CardDB.cardName.dancingswords, 0);
            this.specialMinions.Add(CardDB.cardName.darkcultist, 0);
            this.specialMinions.Add(CardDB.cardName.deathlord, 0);
            this.specialMinions.Add(CardDB.cardName.feugen, 0);
            this.specialMinions.Add(CardDB.cardName.stalagg, 0);
            this.specialMinions.Add(CardDB.cardName.hauntedcreeper, 0);
            this.specialMinions.Add(CardDB.cardName.kelthuzad, 0);
            this.specialMinions.Add(CardDB.cardName.madscientist, 0);
            this.specialMinions.Add(CardDB.cardName.maexxna, 0);
            this.specialMinions.Add(CardDB.cardName.nerubarweblord, 0);
            this.specialMinions.Add(CardDB.cardName.shadeofnaxxramas, 0);
            this.specialMinions.Add(CardDB.cardName.unstableghoul, 0);
            this.specialMinions.Add(CardDB.cardName.voidcaller, 0);
            this.specialMinions.Add(CardDB.cardName.anubarambusher, 0);
            this.specialMinions.Add(CardDB.cardName.webspinner, 0);

        }

        private void setupBuffingMinions()
        {
            buffingMinionsDatabase.Add(CardDB.cardName.abusivesergeant, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.captaingreenskin, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.cenarius, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.coldlightseer, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.crueltaskmaster, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.darkirondwarf, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.defenderofargus, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.direwolfalpha, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.flametonguetotem, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.grimscaleoracle, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.houndmaster, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.leokk, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.murlocwarleader, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.raidleader, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.shatteredsuncleric, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.southseacaptain, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.spitefulsmith, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.stormwindchampion, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.templeenforcer, 0);
            buffingMinionsDatabase.Add(CardDB.cardName.timberwolf, 0);

            buffing1TurnDatabase.Add(CardDB.cardName.abusivesergeant, 0);
            buffing1TurnDatabase.Add(CardDB.cardName.darkirondwarf, 0);

        }

        private void setupEnemyTargetPriority()
        {
            priorityTargets.Add(CardDB.cardName.angrychicken, 10);
            priorityTargets.Add(CardDB.cardName.lightwarden, 10);
            priorityTargets.Add(CardDB.cardName.secretkeeper, 10);
            priorityTargets.Add(CardDB.cardName.youngdragonhawk, 10);
            priorityTargets.Add(CardDB.cardName.bloodmagethalnos, 10);
            priorityTargets.Add(CardDB.cardName.direwolfalpha, 10);
            priorityTargets.Add(CardDB.cardName.doomsayer, 10);
            priorityTargets.Add(CardDB.cardName.knifejuggler, 10);
            priorityTargets.Add(CardDB.cardName.koboldgeomancer, 10);
            priorityTargets.Add(CardDB.cardName.manaaddict, 10);
            priorityTargets.Add(CardDB.cardName.masterswordsmith, 10);
            priorityTargets.Add(CardDB.cardName.natpagle, 10);
            priorityTargets.Add(CardDB.cardName.murloctidehunter, 10);
            priorityTargets.Add(CardDB.cardName.pintsizedsummoner, 10);
            priorityTargets.Add(CardDB.cardName.wildpyromancer, 10);
            priorityTargets.Add(CardDB.cardName.alarmobot, 10);
            priorityTargets.Add(CardDB.cardName.acolyteofpain, 10);
            priorityTargets.Add(CardDB.cardName.demolisher, 10);
            priorityTargets.Add(CardDB.cardName.flesheatingghoul, 10);
            priorityTargets.Add(CardDB.cardName.impmaster, 10);
            priorityTargets.Add(CardDB.cardName.questingadventurer, 10);
            priorityTargets.Add(CardDB.cardName.raidleader, 10);
            priorityTargets.Add(CardDB.cardName.thrallmarfarseer, 10);
            priorityTargets.Add(CardDB.cardName.cultmaster, 10);
            priorityTargets.Add(CardDB.cardName.leeroyjenkins, 10);
            priorityTargets.Add(CardDB.cardName.violetteacher, 10);
            priorityTargets.Add(CardDB.cardName.gadgetzanauctioneer, 10);
            priorityTargets.Add(CardDB.cardName.hogger, 10);
            priorityTargets.Add(CardDB.cardName.illidanstormrage, 10);
            priorityTargets.Add(CardDB.cardName.barongeddon, 10);
            priorityTargets.Add(CardDB.cardName.stormwindchampion, 10);
            priorityTargets.Add(CardDB.cardName.gurubashiberserker, 10);

            //warrior cards
            priorityTargets.Add(CardDB.cardName.frothingberserker, 10);
            priorityTargets.Add(CardDB.cardName.warsongcommander, 10);

            //warlock cards
            priorityTargets.Add(CardDB.cardName.summoningportal, 10);

            //shaman cards
            priorityTargets.Add(CardDB.cardName.dustdevil, 10);
            priorityTargets.Add(CardDB.cardName.wrathofairtotem, 1);
            priorityTargets.Add(CardDB.cardName.flametonguetotem, 10);
            priorityTargets.Add(CardDB.cardName.manatidetotem, 10);
            priorityTargets.Add(CardDB.cardName.unboundelemental, 10);

            //rogue cards

            //priest cards
            priorityTargets.Add(CardDB.cardName.northshirecleric, 10);
            priorityTargets.Add(CardDB.cardName.lightwell, 10);
            priorityTargets.Add(CardDB.cardName.auchenaisoulpriest, 10);
            priorityTargets.Add(CardDB.cardName.prophetvelen, 10);

            //paladin cards

            //mage cards
            priorityTargets.Add(CardDB.cardName.manawyrm, 10);
            priorityTargets.Add(CardDB.cardName.sorcerersapprentice, 10);
            priorityTargets.Add(CardDB.cardName.etherealarcanist, 10);
            priorityTargets.Add(CardDB.cardName.archmageantonidas, 10);

            //hunter cards
            priorityTargets.Add(CardDB.cardName.timberwolf, 10);
            priorityTargets.Add(CardDB.cardName.scavenginghyena, 10);
            priorityTargets.Add(CardDB.cardName.starvingbuzzard, 10);
            priorityTargets.Add(CardDB.cardName.leokk, 10);
            priorityTargets.Add(CardDB.cardName.tundrarhino, 10);

            //naxx cards
            priorityTargets.Add(CardDB.cardName.baronrivendare, 10);
            priorityTargets.Add(CardDB.cardName.kelthuzad, 10);
            priorityTargets.Add(CardDB.cardName.nerubarweblord, 10);
            priorityTargets.Add(CardDB.cardName.shadeofnaxxramas, 10);
            priorityTargets.Add(CardDB.cardName.undertaker, 10);

        }

        private void setupLethalHelpMinions()
        {
            lethalHelpers.Add(CardDB.cardName.auchenaisoulpriest, 0);
            //spellpower minions
            lethalHelpers.Add(CardDB.cardName.archmage, 0);
            lethalHelpers.Add(CardDB.cardName.dalaranmage, 0);
            lethalHelpers.Add(CardDB.cardName.koboldgeomancer, 0);
            lethalHelpers.Add(CardDB.cardName.ogremagi, 0);
            lethalHelpers.Add(CardDB.cardName.ancientmage, 0);
            lethalHelpers.Add(CardDB.cardName.azuredrake, 0);
            lethalHelpers.Add(CardDB.cardName.bloodmagethalnos, 0);
            lethalHelpers.Add(CardDB.cardName.malygos, 0);
            lethalHelpers.Add(CardDB.cardName.velenschosen, 0);
            lethalHelpers.Add(CardDB.cardName.sootspewer, 0);
            lethalHelpers.Add(CardDB.cardName.minimage, 0);
            //

        }

        private void setupSilenceTargets()
        {
            this.silenceTargets.Add(CardDB.cardName.abomination, 0);
            this.silenceTargets.Add(CardDB.cardName.acolyteofpain, 0);
            this.silenceTargets.Add(CardDB.cardName.archmageantonidas, 0);
            this.silenceTargets.Add(CardDB.cardName.armorsmith, 0);
            this.silenceTargets.Add(CardDB.cardName.auchenaisoulpriest, 0);
            this.silenceTargets.Add(CardDB.cardName.barongeddon, 0);
            //this.silenceTargets.Add(CardDB.cardName.bloodimp, 0);
            this.silenceTargets.Add(CardDB.cardName.cairnebloodhoof, 0);
            this.silenceTargets.Add(CardDB.cardName.cultmaster, 0);
            this.silenceTargets.Add(CardDB.cardName.direwolfalpha, 0);
            this.silenceTargets.Add(CardDB.cardName.doomsayer, 0);
            this.silenceTargets.Add(CardDB.cardName.emperorcobra, 0);
            this.silenceTargets.Add(CardDB.cardName.etherealarcanist, 0);
            this.silenceTargets.Add(CardDB.cardName.flametonguetotem, 0);
            this.silenceTargets.Add(CardDB.cardName.gadgetzanauctioneer, 10);
            this.silenceTargets.Add(CardDB.cardName.grommashhellscream, 0);

            this.silenceTargets.Add(CardDB.cardName.gruul, 0);
            this.silenceTargets.Add(CardDB.cardName.gurubashiberserker, 0);
            this.silenceTargets.Add(CardDB.cardName.hogger, 0);

            this.silenceTargets.Add(CardDB.cardName.illidanstormrage, 0);
            this.silenceTargets.Add(CardDB.cardName.impmaster, 0);

            this.silenceTargets.Add(CardDB.cardName.knifejuggler, 0);
            this.silenceTargets.Add(CardDB.cardName.lightspawn, 0);
            this.silenceTargets.Add(CardDB.cardName.lightwarden, 0);
            this.silenceTargets.Add(CardDB.cardName.lightwell, 0);
            this.silenceTargets.Add(CardDB.cardName.lorewalkercho, 0);

            this.silenceTargets.Add(CardDB.cardName.malygos, 0);

            this.silenceTargets.Add(CardDB.cardName.manatidetotem, 0);
            this.silenceTargets.Add(CardDB.cardName.manawraith, 0);
            this.silenceTargets.Add(CardDB.cardName.manawyrm, 0);
            this.silenceTargets.Add(CardDB.cardName.masterswordsmith, 0);

            this.silenceTargets.Add(CardDB.cardName.murloctidecaller, 0);
            this.silenceTargets.Add(CardDB.cardName.murlocwarleader, 0);
            this.silenceTargets.Add(CardDB.cardName.natpagle, 0);
            this.silenceTargets.Add(CardDB.cardName.northshirecleric, 0);

            this.silenceTargets.Add(CardDB.cardName.oldmurkeye, 0);
            this.silenceTargets.Add(CardDB.cardName.prophetvelen, 0);
            this.silenceTargets.Add(CardDB.cardName.questingadventurer, 0);
            this.silenceTargets.Add(CardDB.cardName.raidleader, 0);

            this.silenceTargets.Add(CardDB.cardName.savannahhighmane, 0);
            this.silenceTargets.Add(CardDB.cardName.scavenginghyena, 0);
            this.silenceTargets.Add(CardDB.cardName.sorcerersapprentice, 0);
            this.silenceTargets.Add(CardDB.cardName.southseacaptain, 0);
            this.silenceTargets.Add(CardDB.cardName.spitefulsmith, 0);
            this.silenceTargets.Add(CardDB.cardName.starvingbuzzard, 0);
            this.silenceTargets.Add(CardDB.cardName.stormwindchampion, 0);
            this.silenceTargets.Add(CardDB.cardName.summoningportal, 0);
            this.silenceTargets.Add(CardDB.cardName.sylvanaswindrunner, 0);
            this.silenceTargets.Add(CardDB.cardName.timberwolf, 0);
            this.silenceTargets.Add(CardDB.cardName.tirionfordring, 0);
            this.silenceTargets.Add(CardDB.cardName.tundrarhino, 0);
            //this.specialMinions.Add(CardDB.cardName.unboundelemental, 0);
            //this.specialMinions.Add(CardDB.cardName.venturecomercenary, 0);
            this.silenceTargets.Add(CardDB.cardName.violetteacher, 0);
            this.silenceTargets.Add(CardDB.cardName.warsongcommander, 0);
            //this.specialMinions.Add(CardDB.cardName.waterelemental, 0);

            // naxx cards
            this.silenceTargets.Add(CardDB.cardName.baronrivendare, 0);
            this.silenceTargets.Add(CardDB.cardName.undertaker, 0);
            this.silenceTargets.Add(CardDB.cardName.darkcultist, 0);
            this.silenceTargets.Add(CardDB.cardName.feugen, 0);
            this.silenceTargets.Add(CardDB.cardName.stalagg, 0);
            this.silenceTargets.Add(CardDB.cardName.hauntedcreeper, 0);
            this.silenceTargets.Add(CardDB.cardName.kelthuzad, 10);
            this.silenceTargets.Add(CardDB.cardName.madscientist, 0);
            this.silenceTargets.Add(CardDB.cardName.maexxna, 0);
            this.silenceTargets.Add(CardDB.cardName.nerubarweblord, 0);
            this.silenceTargets.Add(CardDB.cardName.shadeofnaxxramas, 0);
            //this.specialMinions.Add(CardDB.cardName.voidcaller, 0);
            this.silenceTargets.Add(CardDB.cardName.webspinner, 0);


            this.silenceTargets.Add(CardDB.cardName.malganis, 0);
            this.silenceTargets.Add(CardDB.cardName.malorne, 0);
            this.silenceTargets.Add(CardDB.cardName.gahzrilla, 0);
            this.silenceTargets.Add(CardDB.cardName.bolvarfordragon, 0);
            this.silenceTargets.Add(CardDB.cardName.mogortheogre, 0);
            this.silenceTargets.Add(CardDB.cardName.stonesplintertrogg, 0);
            this.silenceTargets.Add(CardDB.cardName.burlyrockjawtrogg, 0);
            this.silenceTargets.Add(CardDB.cardName.shadowboxer, 0);
            this.silenceTargets.Add(CardDB.cardName.explosivesheep, 0);
            this.silenceTargets.Add(CardDB.cardName.animagolem, 0);
            this.silenceTargets.Add(CardDB.cardName.siegeengine, 0);
            this.silenceTargets.Add(CardDB.cardName.steamwheedlesniper, 0);
            this.silenceTargets.Add(CardDB.cardName.floatingwatcher, 0);
            this.silenceTargets.Add(CardDB.cardName.micromachine, 0);
            this.silenceTargets.Add(CardDB.cardName.hobgoblin, 0);
            this.silenceTargets.Add(CardDB.cardName.pilotedskygolem, 0);
            this.silenceTargets.Add(CardDB.cardName.junkbot, 0);
            this.silenceTargets.Add(CardDB.cardName.v07tr0n, 0);
            this.silenceTargets.Add(CardDB.cardName.foereaper4000, 0);
            this.silenceTargets.Add(CardDB.cardName.sneedsoldshredder, 0);
            this.silenceTargets.Add(CardDB.cardName.mekgineerthermaplugg, 0);
            this.silenceTargets.Add(CardDB.cardName.troggzortheearthinator, 0);
        }

        private void setupRandomCards()
        {
            this.randomEffects.Add(CardDB.cardName.deadlyshot, 1);
            this.randomEffects.Add(CardDB.cardName.multishot, 1);

            this.randomEffects.Add(CardDB.cardName.animalcompanion, 1);
            this.randomEffects.Add(CardDB.cardName.arcanemissiles, 3);
            this.randomEffects.Add(CardDB.cardName.goblinblastmage, 4);
            this.randomEffects.Add(CardDB.cardName.avengingwrath, 8);

            this.randomEffects.Add(CardDB.cardName.flamecannon, 4);

            //this.randomEffects.Add(CardDB.cardName.baneofdoom, 1);
            this.randomEffects.Add(CardDB.cardName.brawl, 1);
            this.randomEffects.Add(CardDB.cardName.captainsparrot, 1);
            this.randomEffects.Add(CardDB.cardName.cleave, 1);
            this.randomEffects.Add(CardDB.cardName.forkedlightning, 1);
            this.randomEffects.Add(CardDB.cardName.gelbinmekkatorque, 1);
            this.randomEffects.Add(CardDB.cardName.iammurloc, 3);
            this.randomEffects.Add(CardDB.cardName.lightningstorm, 1);
            this.randomEffects.Add(CardDB.cardName.madbomber, 3);
            this.randomEffects.Add(CardDB.cardName.mindgames, 1);
            this.randomEffects.Add(CardDB.cardName.mindcontroltech, 1);
            this.randomEffects.Add(CardDB.cardName.mindvision, 1);
            this.randomEffects.Add(CardDB.cardName.powerofthehorde, 1);
            this.randomEffects.Add(CardDB.cardName.sensedemons, 2);
            this.randomEffects.Add(CardDB.cardName.tinkmasteroverspark, 1);
            this.randomEffects.Add(CardDB.cardName.totemiccall, 1);
            this.randomEffects.Add(CardDB.cardName.elitetaurenchieftain, 1);
            this.randomEffects.Add(CardDB.cardName.lifetap, 1);

            this.randomEffects.Add(CardDB.cardName.unstableportal, 1);
            this.randomEffects.Add(CardDB.cardName.crackle, 1);
            this.randomEffects.Add(CardDB.cardName.bouncingblade, 3);
            this.randomEffects.Add(CardDB.cardName.coghammer, 1);
            this.randomEffects.Add(CardDB.cardName.madderbomber, 1);
            this.randomEffects.Add(CardDB.cardName.bomblobber, 1);
            this.randomEffects.Add(CardDB.cardName.enhanceomechano, 1);
        }

    }

    public struct GraveYardItem
    {
        public bool own;
        public int entity;
        public CardDB.cardIDEnum cardid;

        public GraveYardItem(CardDB.cardIDEnum id, int entity, bool own)
        {
            this.own = own;
            this.cardid = id;
            this.entity = entity;
        }
    }

    public class SecretItem
    {
        public bool triggered = false;

        public bool canbeTriggeredWithAttackingHero = true;
        public bool canbeTriggeredWithAttackingMinion = true;
        public bool canbeTriggeredWithPlayingMinion = true;

        public bool canBe_snaketrap = true;
        public bool canBe_snipe = true;
        public bool canBe_explosive = true;
        public bool canBe_freezing = true;
        public bool canBe_missdirection = true;

        public bool canBe_counterspell = true;
        public bool canBe_icebarrier = true;
        public bool canBe_iceblock = true;
        public bool canBe_mirrorentity = true;
        public bool canBe_spellbender = true;
        public bool canBe_vaporize = true;
        public bool canBe_duplicate = true;

        public bool canBe_eyeforaneye = true;
        public bool canBe_noblesacrifice = true;
        public bool canBe_redemption = true;
        public bool canBe_repentance = true;
        public bool canBe_avenge = true;

        public int entityId = 0;

        public SecretItem()
        {
        }

        public SecretItem(SecretItem sec)
        {
            this.triggered = sec.triggered;
            this.canbeTriggeredWithAttackingHero = sec.canbeTriggeredWithAttackingHero;
            this.canbeTriggeredWithAttackingMinion = sec.canbeTriggeredWithAttackingMinion;
            this.canbeTriggeredWithPlayingMinion = sec.canbeTriggeredWithPlayingMinion;

            this.canBe_avenge = sec.canBe_avenge;
            this.canBe_counterspell = sec.canBe_counterspell;
            this.canBe_duplicate = sec.canBe_duplicate;
            this.canBe_explosive = sec.canBe_explosive;
            this.canBe_eyeforaneye = sec.canBe_eyeforaneye;
            this.canBe_freezing = sec.canBe_freezing;
            this.canBe_icebarrier = sec.canBe_icebarrier;
            this.canBe_iceblock = sec.canBe_iceblock;
            this.canBe_mirrorentity = sec.canBe_mirrorentity;
            this.canBe_missdirection = sec.canBe_missdirection;
            this.canBe_noblesacrifice = sec.canBe_noblesacrifice;
            this.canBe_redemption = sec.canBe_redemption;
            this.canBe_repentance = sec.canBe_repentance;
            this.canBe_snaketrap = sec.canBe_snaketrap;
            this.canBe_snipe = sec.canBe_snipe;
            this.canBe_spellbender = sec.canBe_spellbender;
            this.canBe_vaporize = sec.canBe_vaporize;

            this.entityId = sec.entityId;

        }

        public SecretItem(string secdata)
        {
            this.entityId = Convert.ToInt32(secdata.Split('.')[0]);

            string canbe = secdata.Split('.')[1];
            if (canbe.Length < 17)
            {
                Helpfunctions.Instance.ErrorLog("cant read secret " + secdata + " " + canbe.Length);
            }

            this.canBe_snaketrap = (canbe[0] == '1');
            this.canBe_snipe = (canbe[1] == '1');
            this.canBe_explosive = (canbe[2] == '1');
            this.canBe_freezing = (canbe[3] == '1');
            this.canBe_missdirection = (canbe[4] == '1');

            this.canBe_counterspell = (canbe[5] == '1');
            this.canBe_icebarrier = (canbe[6] == '1');
            this.canBe_iceblock = (canbe[7] == '1');
            this.canBe_mirrorentity = (canbe[8] == '1');
            this.canBe_spellbender = (canbe[9] == '1');
            this.canBe_vaporize = (canbe[10] == '1');
            this.canBe_duplicate = (canbe[11] == '1');

            this.canBe_eyeforaneye = (canbe[12] == '1');
            this.canBe_noblesacrifice = (canbe[13] == '1');
            this.canBe_redemption = (canbe[14] == '1');
            this.canBe_repentance = (canbe[15] == '1');
            this.canBe_avenge = (canbe[16] == '1');

            this.updateCanBeTriggered();
        }

        public void updateCanBeTriggered()
        {
            this.canbeTriggeredWithAttackingHero = false;
            this.canbeTriggeredWithAttackingMinion = false;
            this.canbeTriggeredWithPlayingMinion = false;

            if (this.canBe_snipe || this.canBe_mirrorentity || this.canBe_repentance) this.canbeTriggeredWithPlayingMinion = true;

            if (this.canBe_explosive || this.canBe_missdirection || this.canBe_freezing || this.canBe_icebarrier || this.canBe_vaporize || this.canBe_noblesacrifice) this.canbeTriggeredWithAttackingHero = true;

            if (this.canBe_snaketrap || this.canBe_freezing || this.canBe_noblesacrifice) this.canbeTriggeredWithAttackingMinion = true;

        }

        public void usedTrigger_CharIsAttacked(bool DefenderIsHero, bool AttackerIsHero)
        {
            if (DefenderIsHero)
            {
                this.canBe_explosive = false;
                this.canBe_missdirection = false;

                this.canBe_icebarrier = false;
                this.canBe_vaporize = false;

            }
            else
            {
                this.canBe_snaketrap = false;
            }
            if (!AttackerIsHero)
            {
                this.canBe_freezing = false;
            }
            this.canBe_noblesacrifice = false;
            updateCanBeTriggered();
        }

        public void usedTrigger_MinionIsPlayed()
        {
            this.canBe_snipe = false;
            this.canBe_mirrorentity = false;
            this.canBe_repentance = false;
            updateCanBeTriggered();
        }

        public void usedTrigger_SpellIsPlayed(bool minionIsTarget)
        {
            this.canBe_counterspell = false;
            if (minionIsTarget) this.canBe_spellbender = false;
            updateCanBeTriggered();
        }

        public void usedTrigger_MinionDied()
        {
            this.canBe_avenge = false;
            this.canBe_redemption = false;
            this.canBe_duplicate = false;
            updateCanBeTriggered();
        }

        public void usedTrigger_HeroGotDmg(bool deadly = false)
        {
            this.canBe_eyeforaneye = false;
            if (deadly) this.canBe_iceblock = false;
            updateCanBeTriggered();
        }

        public string returnAString()
        {
            string retval = "" + this.entityId + ".";
            retval += "" + ((canBe_snaketrap) ? "1" : "0");
            retval += "" + ((canBe_snipe) ? "1" : "0");
            retval += "" + ((canBe_explosive) ? "1" : "0");
            retval += "" + ((canBe_freezing) ? "1" : "0");
            retval += "" + ((canBe_missdirection) ? "1" : "0");

            retval += "" + ((canBe_counterspell) ? "1" : "0");
            retval += "" + ((canBe_icebarrier) ? "1" : "0");
            retval += "" + ((canBe_iceblock) ? "1" : "0");
            retval += "" + ((canBe_mirrorentity) ? "1" : "0");
            retval += "" + ((canBe_spellbender) ? "1" : "0");
            retval += "" + ((canBe_vaporize) ? "1" : "0");
            retval += "" + ((canBe_duplicate) ? "1" : "0");

            retval += "" + ((canBe_eyeforaneye) ? "1" : "0");
            retval += "" + ((canBe_noblesacrifice) ? "1" : "0");
            retval += "" + ((canBe_redemption) ? "1" : "0");
            retval += "" + ((canBe_repentance) ? "1" : "0");
            retval += "" + ((canBe_avenge) ? "1" : "0");
            return retval + ",";
        }

        public bool isEqual(SecretItem s)
        {
            bool result = this.entityId == s.entityId;
            result = result && this.canBe_avenge == s.canBe_avenge && this.canBe_counterspell == s.canBe_counterspell && this.canBe_duplicate == s.canBe_duplicate && this.canBe_explosive == s.canBe_explosive;
            result = result && this.canBe_eyeforaneye == s.canBe_eyeforaneye && this.canBe_freezing == s.canBe_freezing && this.canBe_icebarrier == s.canBe_icebarrier && this.canBe_iceblock == s.canBe_iceblock;
            result = result && this.canBe_mirrorentity == s.canBe_mirrorentity && this.canBe_missdirection == s.canBe_missdirection && this.canBe_noblesacrifice == s.canBe_noblesacrifice && this.canBe_redemption == s.canBe_redemption;
            result = result && this.canBe_repentance == s.canBe_repentance && this.canBe_snaketrap == s.canBe_snaketrap && this.canBe_snipe == s.canBe_snipe && this.canBe_spellbender == s.canBe_spellbender && this.canBe_vaporize == s.canBe_vaporize;

            return result;
        }

    }

    public class Probabilitymaker
    {
        public Dictionary<CardDB.cardIDEnum, int> ownCardsPlayed = new Dictionary<CardDB.cardIDEnum, int>();
        public Dictionary<CardDB.cardIDEnum, int> enemyCardsPlayed = new Dictionary<CardDB.cardIDEnum, int>();
        List<CardDB.Card> ownDeckGuessed = new List<CardDB.Card>();
        List<CardDB.Card> enemyDeckGuessed = new List<CardDB.Card>();
        List<GraveYardItem> graveyard = new List<GraveYardItem>();
        public List<GraveYardItem> turngraveyard = new List<GraveYardItem>();//MOBS only
        List<GraveYardItem> graveyartTillTurnStart = new List<GraveYardItem>();

        public List<SecretItem> enemySecrets = new List<SecretItem>();

        public bool feugenDead = false;
        public bool stalaggDead = false;

        private static Probabilitymaker instance;
        public static Probabilitymaker Instance
        {
            get
            {
                return instance ?? (instance = new Probabilitymaker());
            }
        }

        private Probabilitymaker()
        {

        }

        public void setOwnCards(List<CardDB.cardIDEnum> list)
        {
            setupDeck(list, ownDeckGuessed, ownCardsPlayed);
        }

        public void setEnemyCards(List<CardDB.cardIDEnum> list)
        {
            setupDeck(list, enemyDeckGuessed, enemyCardsPlayed);
        }

        public void printTurnGraveYard(bool writetobuffer = false)
        {
            /*string g = "";
            if (Probabilitymaker.Instance.feugenDead) g += " fgn";
            if (Probabilitymaker.Instance.stalaggDead) g += " stlgg";
            Helpfunctions.Instance.logg("GraveYard:" + g);
            if (writetobuffer) Helpfunctions.Instance.writeToBuffer("GraveYard:" + g);*/

            string s = "ownDiedMinions: ";
            foreach (GraveYardItem gyi in this.turngraveyard)
            {
                if (gyi.own) s += gyi.cardid + "," + gyi.entity + ";";
            }
            Helpfunctions.Instance.logg(s);
            if (writetobuffer) Helpfunctions.Instance.writeToBuffer(s);

            s = "enemyDiedMinions: ";
            foreach (GraveYardItem gyi in this.turngraveyard)
            {
                if (!gyi.own) s += gyi.cardid + "," + gyi.entity + ";";
            }
            Helpfunctions.Instance.logg(s);
            if (writetobuffer) Helpfunctions.Instance.writeToBuffer(s);
        }

        public void readTurnGraveYard(string own, string enemy)
        {
            this.turngraveyard.Clear();
            string temp = "";
            temp = own.Replace("ownDiedMinions: ", "");

            foreach (string s in temp.Split(';'))
            {
                if (s == "" || s == " ") continue;
                string id = s.Split(',')[0];
                string ent = s.Split(',')[1];
                GraveYardItem gyi = new GraveYardItem(CardDB.Instance.cardIdstringToEnum(id), Convert.ToInt32(ent), true);
            }

            temp = enemy.Replace("enemyDiedMinions: ", "");

            foreach (string s in temp.Split(';'))
            {
                if (s == "" || s == " ") continue;
                string id = s.Split(',')[0];
                string ent = s.Split(',')[1];
                GraveYardItem gyi = new GraveYardItem(CardDB.Instance.cardIdstringToEnum(id), Convert.ToInt32(ent), false);
            }

        }

        public void setGraveYard(List<GraveYardItem> list, bool turnStart)
        {
            graveyard.Clear();
            graveyard.AddRange(list);
            if (turnStart)
            {
                this.graveyartTillTurnStart.Clear();
                this.graveyartTillTurnStart.AddRange(list);
            }

            this.stalaggDead = false;
            this.feugenDead = false;
            this.turngraveyard.Clear();

            foreach (GraveYardItem en in list)
            {
                if (en.cardid == CardDB.cardIDEnum.FP1_015)
                {
                    this.feugenDead = true;
                }

                if (en.cardid == CardDB.cardIDEnum.FP1_014)
                {
                    this.stalaggDead = true;
                }

                bool found = false;

                foreach (GraveYardItem gyi in this.graveyartTillTurnStart)
                {
                    if (en.entity == gyi.entity)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    if (CardDB.Instance.getCardDataFromID(en.cardid).type == CardDB.cardtype.MOB)
                    {
                        this.turngraveyard.Add(en);
                    }
                }
            }


        }

        public void setTurnGraveYard(List<GraveYardItem> list)
        {
            this.turngraveyard.Clear();
            this.turngraveyard.AddRange(list);
        }

        private void setupDeck(List<CardDB.cardIDEnum> cardsPlayed, List<CardDB.Card> deckGuessed, Dictionary<CardDB.cardIDEnum, int> knownCards)
        {
            deckGuessed.Clear();
            knownCards.Clear();
            foreach (CardDB.cardIDEnum crdidnm in cardsPlayed)
            {
                if (crdidnm == CardDB.cardIDEnum.GAME_005) continue; //(im sure, he has no coins in his deck :D)
                if (knownCards.ContainsKey(crdidnm))
                {
                    knownCards[crdidnm]++;
                }
                else
                {
                    if (CardDB.Instance.getCardDataFromID(crdidnm).rarity == 5)
                    {
                        //you cant own rare ones more than once!
                        knownCards.Add(crdidnm, 2);
                        continue;
                    }
                    knownCards.Add(crdidnm, 1);
                }
            }

            foreach (KeyValuePair<CardDB.cardIDEnum, int> kvp in knownCards)
            {
                if (kvp.Value == 1) deckGuessed.Add(CardDB.Instance.getCardDataFromID(kvp.Key));
            }
        }

        public bool hasEnemyThisCardInDeck(CardDB.cardIDEnum cardid)
        {
            if (this.enemyCardsPlayed.ContainsKey(cardid))
            {
                if (this.enemyCardsPlayed[cardid] == 1)
                {

                    return true;
                }
                return false;
            }
            return true;
        }

        public int anzCardsInDeck(CardDB.cardIDEnum cardid)
        {
            int ret = 2;
            CardDB.Card c = CardDB.Instance.getCardDataFromID(cardid);
            if (c.rarity == 5) ret = 1;//you can have only one rare;

            if (this.enemyCardsPlayed.ContainsKey(cardid))
            {
                if (this.enemyCardsPlayed[cardid] == 1)
                {

                    return 1;
                }
                return 0;
            }
            return ret;

        }

        public void printGraveyards(bool writetobuffer = false)
        {
            string og = "og: ";
            foreach (KeyValuePair<CardDB.cardIDEnum, int> e in this.ownCardsPlayed)
            {
                og += (int)e.Key + "," + e.Value + ";";
            }
            string eg = "eg: ";
            foreach (KeyValuePair<CardDB.cardIDEnum, int> e in this.enemyCardsPlayed)
            {
                eg += (int)e.Key + "," + e.Value + ";";
            }
            Helpfunctions.Instance.logg(og);
            Helpfunctions.Instance.logg(eg);
            if (writetobuffer)
            {
                Helpfunctions.Instance.writeToBuffer(og);
                Helpfunctions.Instance.writeToBuffer(eg);
            }
        }

        public void readGraveyards(string owngrave, string enemygrave)
        {
            this.ownCardsPlayed.Clear();
            this.enemyCardsPlayed.Clear();
            string temp = owngrave.Replace("og: ", "");
            this.stalaggDead = false;
            this.feugenDead = false;
            foreach (string s in temp.Split(';'))
            {
                if (s == "" || s == " ") continue;
                string id = s.Split(',')[0];
                string anz = s.Split(',')[1];
                CardDB.cardIDEnum cdbe = (CardDB.cardIDEnum)Convert.ToInt32(id);
                this.ownCardsPlayed.Add(cdbe, Convert.ToInt32(anz));
                if (cdbe == CardDB.cardIDEnum.FP1_015)
                {
                    this.feugenDead = true;
                }
                if (cdbe == CardDB.cardIDEnum.FP1_014) this.stalaggDead = true;
            }
            temp = enemygrave.Replace("eg: ", "");
            foreach (string s in temp.Split(';'))
            {
                if (s == "" || s == " ") continue;
                string id = s.Split(',')[0];
                string anz = s.Split(',')[1];
                CardDB.cardIDEnum cdbe = (CardDB.cardIDEnum)Convert.ToInt32(id);
                this.enemyCardsPlayed.Add(cdbe, Convert.ToInt32(anz));
                if (cdbe == CardDB.cardIDEnum.FP1_015) this.feugenDead = true;
                if (cdbe == CardDB.cardIDEnum.FP1_014) this.stalaggDead = true;
            }

        }

        public int getProbOfEnemyHavingCardInHand(CardDB.cardIDEnum cardid, int handsize, int decksize)
        {
            //calculates probability \in [0,...,100]


            int cardsremaining = this.anzCardsInDeck(cardid);
            if (cardsremaining == 0) return 0;
            double retval = 0.0;
            //http://de.wikipedia.org/wiki/Hypergeometrische_Verteilung (we calculte 1-p(x=0))

            if (cardsremaining == 1)
            {
                retval = 1.0 - ((double)(decksize)) / ((double)(decksize + handsize));
            }
            else
            {
                retval = 1.0 - ((double)(decksize * (decksize - 1))) / ((double)((decksize + handsize) * (decksize + handsize - 1)));
            }

            retval = Math.Min(retval, 1.0);

            return (int)(100.0 * retval);
        }

        public bool hasCardinGraveyard(CardDB.cardIDEnum cardid)
        {
            foreach (GraveYardItem gyi in this.graveyard)
            {
                if (gyi.cardid == cardid) return true;
            }
            return false;
        }

        public void getEnemySecretGuesses(List<int> enemySecretIds, HeroEnum enemyHeroName)
        {
            List<SecretItem> newlist = new List<SecretItem>();

            foreach (int i in enemySecretIds)
            {
                if (i >= 1000) continue;
                Helpfunctions.Instance.logg("detect secret with id" + i);
                SecretItem sec = getNewSecretGuessedItem(i, enemyHeroName);

                newlist.Add(new SecretItem(sec));
            }

            this.enemySecrets.Clear();
            this.enemySecrets.AddRange(newlist);
        }

        public SecretItem getNewSecretGuessedItem(int entityid, HeroEnum enemyHeroName)
        {
            foreach (SecretItem si in this.enemySecrets)
            {
                if (si.entityId == entityid && entityid < 1000) return si;
            }

            SecretItem sec = new SecretItem { entityId = entityid };
            if (enemyHeroName == HeroEnum.hunter)
            {

                sec.canBe_counterspell = false;
                sec.canBe_icebarrier = false;
                sec.canBe_iceblock = false;
                sec.canBe_mirrorentity = false;
                sec.canBe_spellbender = false;
                sec.canBe_vaporize = false;
                sec.canBe_duplicate = false;

                sec.canBe_eyeforaneye = false;
                sec.canBe_noblesacrifice = false;
                sec.canBe_redemption = false;
                sec.canBe_repentance = false;
                sec.canBe_avenge = false;

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_554) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_554] >= 2)
                {
                    sec.canBe_snaketrap = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_609) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_609] >= 2)
                {
                    sec.canBe_snipe = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_610) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_610] >= 2)
                {
                    sec.canBe_explosive = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_611) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_611] >= 2)
                {
                    sec.canBe_freezing = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_533) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_533] >= 2)
                {
                    sec.canBe_missdirection = false;
                }
            }

            if (enemyHeroName == HeroEnum.mage)
            {
                sec.canBe_snaketrap = false;
                sec.canBe_snipe = false;
                sec.canBe_explosive = false;
                sec.canBe_freezing = false;
                sec.canBe_missdirection = false;

                sec.canBe_eyeforaneye = false;
                sec.canBe_noblesacrifice = false;
                sec.canBe_redemption = false;
                sec.canBe_repentance = false;
                sec.canBe_avenge = false;

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_287) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_287] >= 2)
                {
                    sec.canBe_counterspell = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_289) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_289] >= 2)
                {
                    sec.canBe_icebarrier = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_295) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_295] >= 2)
                {
                    sec.canBe_iceblock = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_294) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_294] >= 2)
                {
                    sec.canBe_mirrorentity = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.tt_010) && enemyCardsPlayed[CardDB.cardIDEnum.tt_010] >= 2)
                {
                    sec.canBe_spellbender = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_594) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_594] >= 2)
                {
                    sec.canBe_vaporize = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.FP1_018) && enemyCardsPlayed[CardDB.cardIDEnum.FP1_018] >= 2)
                {
                    sec.canBe_duplicate = false;
                }
            }

            if (enemyHeroName == HeroEnum.pala)
            {

                sec.canBe_snaketrap = false;
                sec.canBe_snipe = false;
                sec.canBe_explosive = false;
                sec.canBe_freezing = false;
                sec.canBe_missdirection = false;

                sec.canBe_counterspell = false;
                sec.canBe_icebarrier = false;
                sec.canBe_iceblock = false;
                sec.canBe_mirrorentity = false;
                sec.canBe_spellbender = false;
                sec.canBe_vaporize = false;
                sec.canBe_duplicate = false;

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_132) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_132] >= 2)
                {
                    sec.canBe_eyeforaneye = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_130) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_130] >= 2)
                {
                    sec.canBe_noblesacrifice = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_136) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_136] >= 2)
                {
                    sec.canBe_redemption = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.EX1_379) && enemyCardsPlayed[CardDB.cardIDEnum.EX1_379] >= 2)
                {
                    sec.canBe_repentance = false;
                }

                if (enemyCardsPlayed.ContainsKey(CardDB.cardIDEnum.FP1_020) && enemyCardsPlayed[CardDB.cardIDEnum.FP1_020] >= 2)
                {
                    sec.canBe_avenge = false;
                }

            }

            return sec;
        }

        public string getEnemySecretData()
        {
            string retval = "";
            foreach (SecretItem si in this.enemySecrets)
            {

                retval += si.returnAString();
            }

            return retval;
        }

        public string getEnemySecretData(List<SecretItem> list)
        {
            string retval = "";
            foreach (SecretItem si in list)
            {

                retval += si.returnAString();
            }

            return retval;
        }


        public void setEnemySecretData(List<SecretItem> enemySecretl)
        {
            this.enemySecrets.Clear();
            foreach (SecretItem si in enemySecretl)
            {
                this.enemySecrets.Add(new SecretItem(si));
            }
        }

        public void updateSecretList(List<SecretItem> enemySecretl)
        {
            List<SecretItem> temp = new List<SecretItem>();
            foreach (SecretItem si in this.enemySecrets)
            {
                bool add = false;
                SecretItem seit = null;
                foreach (SecretItem sit in enemySecretl) // enemySecrets have to be updated to latest entitys
                {
                    if (si.entityId == sit.entityId)
                    {
                        seit = sit;
                        add = true;
                    }
                }

                temp.Add(add ? new SecretItem(seit) : new SecretItem(si));
            }

            this.enemySecrets.Clear();
            this.enemySecrets.AddRange(temp);

        }

        public void updateSecretList(Playfield p, Playfield old)
        {
            if (p.enemySecretCount == 0) return;

            bool usedspell = false;
            int lastEffectedIsMinion = 0; //2 = minion, 1 = hero
            bool playedMob = false;
            bool enemyMinionDied = false;
            bool attackedWithMob = false;
            bool attackedWithHero = false;
            int attackTargetIsMinion = 0;
            bool enemyHeroGotDmg = false;

            Handmanager.Handcard hcard = null;
            if (p.cardsPlayedThisTurn > old.cardsPlayedThisTurn)
            {
                for (int i = 0; i < old.owncards.Count - 1; i++)
                {
                    if (p.owncards.Count - 1 >= i)
                    {
                        if (old.owncards[i].entity != p.owncards[i].entity)
                        {
                            hcard = old.owncards[i];
                            break;
                        }
                    }
                    else
                    {
                        hcard = old.owncards[i];
                        break;
                    }
                }

                if (hcard != null && hcard.card.type == CardDB.cardtype.SPELL)
                {
                    if (hcard.card.type == CardDB.cardtype.SPELL) usedspell = true;
                    int entityOfLastAffected = Silverfish.getCardTarget(hcard.entity);
                    if (entityOfLastAffected >= 1) lastEffectedIsMinion = 2;
                    if (entityOfLastAffected == p.enemyHero.entitiyID) lastEffectedIsMinion = 1;
                }

                if (hcard != null && hcard.card.type == CardDB.cardtype.MOB)
                {
                    int entityOfLastAffected = Silverfish.getLastAffected(hcard.entity);
                    if (entityOfLastAffected >= 1) lastEffectedIsMinion = 2;
                    if (entityOfLastAffected == p.enemyHero.entitiyID && (p.enemyHero.Hp < old.enemyHero.Hp || p.enemyHero.immune)) lastEffectedIsMinion = 1;

                    entityOfLastAffected = Silverfish.getCardTarget(hcard.entity);
                    if (entityOfLastAffected >= 1)
                    {
                        lastEffectedIsMinion = 2;
                        if (entityOfLastAffected == p.enemyHero.entitiyID) lastEffectedIsMinion = 1;
                    }
                }
            }

            if (p.mobsplayedThisTurn > old.mobsplayedThisTurn)
            {
                playedMob = true;
            }
            if (p.diedMinions != null && old.diedMinions != null)
            {
                int pcount = 0;
                int ocount = 0;
                foreach (GraveYardItem gyi in p.diedMinions)
                {
                    if (!gyi.own) pcount++;
                }
                foreach (GraveYardItem gyi in old.diedMinions)
                {
                    if (!gyi.own) ocount++;
                }
                if (pcount > ocount) enemyMinionDied = true;
            }


            //attacked with mob?

            int newAttackers = 0;
            int oldAttackers = 0;
            foreach (Minion m in p.ownMinions)
            {
                newAttackers += m.numAttacksThisTurn;
            }
            foreach (Minion m in old.ownMinions)
            {
                oldAttackers += m.numAttacksThisTurn;
            }

            if (newAttackers > oldAttackers) attackedWithMob = true;

            if (p.ownHero.numAttacksThisTurn > old.ownHero.numAttacksThisTurn) attackedWithHero = true;

            if (p.enemyHero.Hp < old.enemyHero.Hp) enemyHeroGotDmg = true;

            if (attackedWithHero || attackedWithMob)
            {
                //check hero first, so we can exclude deathrattles!
                if (p.enemyHero.Hp < old.enemyHero.Hp) attackTargetIsMinion = 1;

                int newDefenders = 0; int oldDefenders = 0;

                foreach (Minion m in p.ownMinions)
                {
                    newDefenders += m.Hp;
                }
                foreach (Minion m in old.ownMinions)
                {
                    oldDefenders += m.Hp;
                }

                if (newDefenders < oldDefenders) attackTargetIsMinion = 2;
            }


            foreach (SecretItem si in this.enemySecrets)
            {

                if (attackedWithHero || attackedWithMob) si.usedTrigger_CharIsAttacked(attackTargetIsMinion == 1, attackedWithHero);

                if (enemyHeroGotDmg) si.usedTrigger_HeroGotDmg();

                if (enemyMinionDied) si.usedTrigger_MinionDied();

                if (playedMob) si.usedTrigger_MinionIsPlayed();

                if (usedspell) si.usedTrigger_SpellIsPlayed(lastEffectedIsMinion == 2);

            }
        }

    }

    public class ComboBreaker
    {

        enum combotype
        {
            combo,
            target,
            weaponuse
        }

        private Dictionary<CardDB.cardIDEnum, int> playByValue = new Dictionary<CardDB.cardIDEnum, int>();

        private List<combo> combos = new List<combo>();
        private static ComboBreaker instance;

        Handmanager hm = Handmanager.Instance;
        Hrtprozis hp = Hrtprozis.Instance;

        public int attackFaceHP = -1;


        class combo
        {
            public combotype type = combotype.combo;
            public int neededMana = 0;
            public Dictionary<CardDB.cardIDEnum, int> combocards = new Dictionary<CardDB.cardIDEnum, int>();
            public Dictionary<CardDB.cardIDEnum, int> cardspen = new Dictionary<CardDB.cardIDEnum, int>();
            public Dictionary<CardDB.cardIDEnum, int> combocardsTurn0Mobs = new Dictionary<CardDB.cardIDEnum, int>();
            public Dictionary<CardDB.cardIDEnum, int> combocardsTurn0All = new Dictionary<CardDB.cardIDEnum, int>();
            public Dictionary<CardDB.cardIDEnum, int> combocardsTurn1 = new Dictionary<CardDB.cardIDEnum, int>();
            public int penality = 0;
            public int combolength = 0;
            public int combot0len = 0;
            public int combot1len = 0;
            public int combot0lenAll = 0;
            public bool twoTurnCombo = false;
            public int bonusForPlaying = 0;
            public int bonusForPlayingT0 = 0;
            public int bonusForPlayingT1 = 0;
            public CardDB.cardName requiredWeapon = CardDB.cardName.unknown;
            public HeroEnum oHero = HeroEnum.None;

            public combo(string s)
            {
                int i = 0;
                this.neededMana = 0;
                requiredWeapon = CardDB.cardName.unknown;
                this.type = combotype.combo;
                this.twoTurnCombo = false;
                bool fixmana = false;
                if (s.Contains("nxttrn")) this.twoTurnCombo = true;
                if (s.Contains("mana:")) fixmana = true;

                /*foreach (string ding in s.Split(':'))
                {
                    if (i == 0)
                    {
                        if (ding == "c") this.type = combotype.combo;
                        if (ding == "t") this.type = combotype.target;
                        if (ding == "w") this.type = combotype.weaponuse;
                    }
                    if (ding == "" || ding == string.Empty) continue;

                    if (i == 1 && type == combotype.combo)
                    {
                        int m = Convert.ToInt32(ding);
                        neededMana = -1;
                        if (m >= 1) neededMana = m;
                    }
                */
                if (type == combotype.combo)
                {
                    this.combolength = 0;
                    this.combot0len = 0;
                    this.combot1len = 0;
                    this.combot0lenAll = 0;
                    int manat0 = 0;
                    int manat1 = -1;
                    bool t1 = false;
                    foreach (string crdl in s.Split(';')) //ding.Split
                    {
                        if (crdl == "" || crdl == string.Empty) continue;
                        if (crdl == "nxttrn")
                        {
                            t1 = true;
                            continue;
                        }
                        if (crdl.StartsWith("mana:"))
                        {
                            this.neededMana = Convert.ToInt32(crdl.Replace("mana:", ""));
                            continue;
                        }
                        if (crdl.StartsWith("hero:"))
                        {
                            this.oHero = Hrtprozis.Instance.heroNametoEnum(crdl.Replace("hero:", ""));
                            continue;
                        }
                        if (crdl.StartsWith("bonus:"))
                        {
                            this.bonusForPlaying = Convert.ToInt32(crdl.Replace("bonus:", ""));
                            continue;
                        }
                        if (crdl.StartsWith("bonusfirst:"))
                        {
                            this.bonusForPlayingT0 = Convert.ToInt32(crdl.Replace("bonusfirst:", ""));
                            continue;
                        }
                        if (crdl.StartsWith("bonussecond:"))
                        {
                            this.bonusForPlayingT1 = Convert.ToInt32(crdl.Replace("bonussecond:", ""));
                            continue;
                        }
                        string crd = crdl.Split(',')[0];
                        if (t1)
                        {
                            manat1 += CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(crd)).cost;
                        }
                        else
                        {
                            manat0 += CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(crd)).cost;
                        }
                        this.combolength++;

                        if (combocards.ContainsKey(CardDB.Instance.cardIdstringToEnum(crd)))
                        {
                            combocards[CardDB.Instance.cardIdstringToEnum(crd)]++;
                        }
                        else
                        {
                            combocards.Add(CardDB.Instance.cardIdstringToEnum(crd), 1);
                            cardspen.Add(CardDB.Instance.cardIdstringToEnum(crd), Convert.ToInt32(crdl.Split(',')[1]));
                        }

                        if (this.twoTurnCombo)
                        {

                            if (t1)
                            {
                                if (this.combocardsTurn1.ContainsKey(CardDB.Instance.cardIdstringToEnum(crd)))
                                {
                                    combocardsTurn1[CardDB.Instance.cardIdstringToEnum(crd)]++;
                                }
                                else
                                {
                                    combocardsTurn1.Add(CardDB.Instance.cardIdstringToEnum(crd), 1);
                                }
                                this.combot1len++;
                            }
                            else
                            {
                                CardDB.Card lolcrd = CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(crd));
                                if (lolcrd.type == CardDB.cardtype.MOB)
                                {
                                    if (this.combocardsTurn0Mobs.ContainsKey(CardDB.Instance.cardIdstringToEnum(crd)))
                                    {
                                        combocardsTurn0Mobs[CardDB.Instance.cardIdstringToEnum(crd)]++;
                                    }
                                    else
                                    {
                                        combocardsTurn0Mobs.Add(CardDB.Instance.cardIdstringToEnum(crd), 1);
                                    }
                                    this.combot0len++;
                                }
                                if (lolcrd.type == CardDB.cardtype.WEAPON)
                                {
                                    this.requiredWeapon = lolcrd.name;
                                }
                                if (this.combocardsTurn0All.ContainsKey(CardDB.Instance.cardIdstringToEnum(crd)))
                                {
                                    combocardsTurn0All[CardDB.Instance.cardIdstringToEnum(crd)]++;
                                }
                                else
                                {
                                    combocardsTurn0All.Add(CardDB.Instance.cardIdstringToEnum(crd), 1);
                                }
                                this.combot0lenAll++;
                            }
                        }


                    }
                    if (!fixmana)
                    {
                        this.neededMana = Math.Max(manat1, manat0);
                    }
                }

                /*if (i == 2 && type == combotype.combo)
                {
                    int m = Convert.ToInt32(ding);
                    penality = 0;
                    if (m >= 1) penality = m;
                }

                i++;
            }*/
                this.bonusForPlaying = Math.Max(bonusForPlaying, 1);
                this.bonusForPlayingT0 = Math.Max(bonusForPlayingT0, 1);
                this.bonusForPlayingT1 = Math.Max(bonusForPlayingT1, 1);
            }

            public int isInCombo(List<Handmanager.Handcard> hand, int omm)
            {
                int cardsincombo = 0;
                Dictionary<CardDB.cardIDEnum, int> combocardscopy = new Dictionary<CardDB.cardIDEnum, int>(this.combocards);
                foreach (Handmanager.Handcard hc in hand)
                {
                    if (combocardscopy.ContainsKey(hc.card.cardIDenum) && combocardscopy[hc.card.cardIDenum] >= 1)
                    {
                        cardsincombo++;
                        combocardscopy[hc.card.cardIDenum]--;
                    }
                }
                if (cardsincombo == this.combolength && omm < this.neededMana) return 1;
                if (cardsincombo == this.combolength) return 2;
                if (cardsincombo >= 1) return 1;
                return 0;
            }

            public int isMultiTurnComboTurn1(List<Handmanager.Handcard> hand, int omm, List<Minion> ownmins, CardDB.cardName weapon)
            {
                if (!twoTurnCombo) return 0;
                int cardsincombo = 0;
                Dictionary<CardDB.cardIDEnum, int> combocardscopy = new Dictionary<CardDB.cardIDEnum, int>(this.combocardsTurn1);
                foreach (Handmanager.Handcard hc in hand)
                {
                    if (combocardscopy.ContainsKey(hc.card.cardIDenum) && combocardscopy[hc.card.cardIDenum] >= 1)
                    {
                        cardsincombo++;
                        combocardscopy[hc.card.cardIDenum]--;
                    }
                }
                if (cardsincombo == this.combot1len && omm < this.neededMana) return 1;

                if (cardsincombo == this.combot1len)
                {
                    //search for required minions on field
                    int turn0requires = 0;
                    foreach (CardDB.cardIDEnum s in combocardsTurn0Mobs.Keys)
                    {
                        foreach (Minion m in ownmins)
                        {
                            if (!m.playedThisTurn && m.handcard.card.cardIDenum == s)
                            {
                                turn0requires++;
                                break;
                            }
                        }
                    }

                    if (requiredWeapon != CardDB.cardName.unknown && requiredWeapon != weapon) return 1;

                    if (turn0requires >= combot0len) return 2;

                    return 1;
                }
                if (cardsincombo >= 1) return 1;
                return 0;
            }

            public int isMultiTurnComboTurn0(List<Handmanager.Handcard> hand, int omm)
            {
                if (!twoTurnCombo) return 0;
                int cardsincombo = 0;
                Dictionary<CardDB.cardIDEnum, int> combocardscopy = new Dictionary<CardDB.cardIDEnum, int>(this.combocardsTurn0All);
                foreach (Handmanager.Handcard hc in hand)
                {
                    if (combocardscopy.ContainsKey(hc.card.cardIDenum) && combocardscopy[hc.card.cardIDenum] >= 1)
                    {
                        cardsincombo++;
                        combocardscopy[hc.card.cardIDenum]--;
                    }
                }
                if (cardsincombo == this.combot0lenAll && omm < this.neededMana) return 1;

                if (cardsincombo == this.combot0lenAll)
                {
                    return 2;
                }
                if (cardsincombo >= 1) return 1;
                return 0;
            }


            public bool isMultiTurn1Card(CardDB.Card card)
            {
                if (this.combocardsTurn1.ContainsKey(card.cardIDenum))
                {
                    return true;
                }
                return false;
            }

            public bool isCardInCombo(CardDB.Card card)
            {
                if (this.combocards.ContainsKey(card.cardIDenum))
                {
                    return true;
                }
                return false;
            }

            public int hasPlayedCombo(List<Handmanager.Handcard> hand)
            {
                int cardsincombo = 0;
                Dictionary<CardDB.cardIDEnum, int> combocardscopy = new Dictionary<CardDB.cardIDEnum, int>(this.combocards);
                foreach (Handmanager.Handcard hc in hand)
                {
                    if (combocardscopy.ContainsKey(hc.card.cardIDenum) && combocardscopy[hc.card.cardIDenum] >= 1)
                    {
                        cardsincombo++;
                        combocardscopy[hc.card.cardIDenum]--;
                    }
                }

                if (cardsincombo == this.combolength) return this.bonusForPlaying;
                return 0;
            }

            public int hasPlayedTurn0Combo(List<Handmanager.Handcard> hand)
            {
                if (this.combocardsTurn0All.Count == 0) return 0;
                int cardsincombo = 0;
                Dictionary<CardDB.cardIDEnum, int> combocardscopy = new Dictionary<CardDB.cardIDEnum, int>(this.combocardsTurn0All);
                foreach (Handmanager.Handcard hc in hand)
                {
                    if (combocardscopy.ContainsKey(hc.card.cardIDenum) && combocardscopy[hc.card.cardIDenum] >= 1)
                    {
                        cardsincombo++;
                        combocardscopy[hc.card.cardIDenum]--;
                    }
                }

                if (cardsincombo == this.combot0lenAll) return this.bonusForPlayingT0;
                return 0;
            }

            public int hasPlayedTurn1Combo(List<Handmanager.Handcard> hand)
            {
                if (this.combocardsTurn1.Count == 0) return 0;
                int cardsincombo = 0;
                Dictionary<CardDB.cardIDEnum, int> combocardscopy = new Dictionary<CardDB.cardIDEnum, int>(this.combocardsTurn1);
                foreach (Handmanager.Handcard hc in hand)
                {
                    if (combocardscopy.ContainsKey(hc.card.cardIDenum) && combocardscopy[hc.card.cardIDenum] >= 1)
                    {
                        cardsincombo++;
                        combocardscopy[hc.card.cardIDenum]--;
                    }
                }

                if (cardsincombo == this.combot1len) return this.bonusForPlayingT1;
                return 0;
            }

        }

        public static ComboBreaker Instance
        {
            get
            {
                return instance ?? (instance = new ComboBreaker());
            }
        }

        private ComboBreaker()
        {
            readCombos();
            if (attackFaceHP != -1)
            {
                hp.setAttackFaceHP(attackFaceHP);
            }
        }

        private void readCombos()
        {
            string[] lines = new string[0] { };
            combos.Clear();
            try
            {
                string path = Settings.Instance.path;
                lines = System.IO.File.ReadAllLines(path + "_combo.txt");
            }
            catch
            {
                Helpfunctions.Instance.logg("cant find _combo.txt");
                Helpfunctions.Instance.ErrorLog("cant find _combo.txt (if you dont created your own combos, ignore this message)");
                return;
            }
            Helpfunctions.Instance.logg("read _combo.txt...");
            Helpfunctions.Instance.ErrorLog("read _combo.txt...");
            foreach (string line in lines)
            {

                if (line.Contains("weapon:"))
                {
                    try
                    {
                        this.attackFaceHP = Convert.ToInt32(line.Replace("weapon:", ""));
                    }
                    catch
                    {
                        Helpfunctions.Instance.logg("combomaker cant read: " + line);
                        Helpfunctions.Instance.ErrorLog("combomaker cant read: " + line);
                    }
                }
                else
                {
                    if (line.Contains("cardvalue:"))
                    {
                        try
                        {
                            string cardvalue = line.Replace("cardvalue:", "");
                            CardDB.cardIDEnum ce = CardDB.Instance.cardIdstringToEnum(cardvalue.Split(',')[0]);
                            int val = Convert.ToInt32(cardvalue.Split(',')[1]);
                            if (this.playByValue.ContainsKey(ce)) continue;
                            this.playByValue.Add(ce, val);
                            //Helpfunctions.Instance.ErrorLog("adding: " + line);
                        }
                        catch
                        {
                            Helpfunctions.Instance.logg("combomaker cant read: " + line);
                            Helpfunctions.Instance.ErrorLog("combomaker cant read: " + line);
                        }
                    }
                    else
                    {
                        try
                        {
                            combo c = new combo(line);
                            this.combos.Add(c);
                        }
                        catch
                        {
                            Helpfunctions.Instance.logg("combomaker cant read: " + line);
                            Helpfunctions.Instance.ErrorLog("combomaker cant read: " + line);
                        }
                    }
                }

            }

        }

        public int getPenalityForDestroyingCombo(CardDB.Card crd, Playfield p)
        {
            if (this.combos.Count == 0) return 0;
            int pen = int.MaxValue;
            bool found = false;
            int mana = Math.Max(hp.ownMaxMana, hp.currentMana);
            foreach (combo c in this.combos)
            {
                if ((c.oHero == HeroEnum.None || c.oHero == p.ownHeroName) && c.isCardInCombo(crd))
                {
                    int iia = c.isInCombo(hm.handCards, hp.ownMaxMana);//check if we have all cards for a combo, and if the choosen card is one
                    int iib = c.isMultiTurnComboTurn1(hm.handCards, mana, p.ownMinions, p.ownWeaponName);

                    int iic = Math.Max(iia, iib);
                    if (iia == 2 && iib != 2 && c.isMultiTurn1Card(crd))// it is a card of the combo, is a turn 1 card, but turn 1 is not possible -> we have to play turn 0 cards first
                    {
                        iic = 1;
                    }
                    if (iic == 1) found = true;
                    if (iic == 1 && pen > c.cardspen[crd.cardIDenum]) pen = c.cardspen[crd.cardIDenum];//iic==1 will destroy combo
                    if (iic == 2) pen = 0;//card is ok to play
                }

            }
            if (found) { return pen; }
            return 0;

        }

        public int checkIfComboWasPlayed(List<Action> alist, CardDB.cardName weapon, HeroEnum heroname)
        {
            if (this.combos.Count == 0) return 0;
            //returns a penalty only if the combo could be played, but is not played completely
            List<Handmanager.Handcard> playedcards = new List<Handmanager.Handcard>();
            List<combo> searchingCombo = new List<combo>();
            // only check the cards, that are in a combo that can be played:
            int mana = Math.Max(hp.ownMaxMana, hp.currentMana);
            foreach (Action a in alist)
            {
                if (a.actionType != actionEnum.playcard) continue;
                CardDB.Card crd = a.card.card;
                //playedcards.Add(a.handcard);
                foreach (combo c in this.combos)
                {
                    if ((c.oHero == HeroEnum.None || c.oHero == heroname) && c.isCardInCombo(crd))
                    {
                        int iia = c.isInCombo(hm.handCards, hp.ownMaxMana);
                        int iib = c.isMultiTurnComboTurn1(hm.handCards, mana, hp.ownMinions, weapon);
                        int iic = Math.Max(iia, iib);
                        if (iia == 2 && iib != 2 && c.isMultiTurn1Card(crd))
                        {
                            iic = 1;
                        }
                        if (iic == 2)
                        {
                            playedcards.Add(a.card); // add only the cards, which dont get a penalty
                        }
                    }

                }
            }

            if (playedcards.Count == 0) return 0;
            bool wholeComboPlayed = false;

            int bonus = 0;
            foreach (combo c in this.combos)
            {
                int iia = c.hasPlayedCombo(playedcards);
                int iib = c.hasPlayedTurn0Combo(playedcards);
                int iic = c.hasPlayedTurn1Combo(playedcards);
                int iie = iia + iib + iic;
                if (iie >= 1)
                {
                    wholeComboPlayed = true;
                    bonus -= iie;
                }
            }

            if (wholeComboPlayed) return bonus;
            return 250;

        }

        public int getPlayValue(CardDB.cardIDEnum ce)
        {
            if (this.playByValue.Count == 0) return 0;
            if (this.playByValue.ContainsKey(ce))
            {
                return this.playByValue[ce];
            }
            return 0;

        }

    }

    public class Mulligan
    {
        public class CardIDEntity
        {
            public string id = "";
            public int entitiy = 0;
            public CardIDEntity(string id, int entt)
            {
                this.id = id;
                this.entitiy = entt;
            }
        }

        class mulliitem
        {
            public string cardid = "";
            public string enemyclass = "";
            public string ownclass = "";
            public int howmuch = 2;
            public string[] requiresCard = null;
            public int manarule = -1;
            public string rulestring = "";
            public mulliitem(string id, string own, string enemy, int number, string[] req = null, int mrule = -1)
            {
                this.cardid = id;
                this.ownclass = own;
                this.enemyclass = enemy;
                this.howmuch = number;
                this.requiresCard = req;
                this.manarule = mrule;
            }

            public mulliitem(string all, string id, string own, string enemy, int number, string[] req = null, int mrule = -1)
            {
                this.cardid = id;
                this.ownclass = own;
                this.enemyclass = enemy;
                this.howmuch = number;
                this.requiresCard = req;
                this.manarule = mrule;
                this.rulestring = all;
            }

        }

        class concedeItem
        {
            public HeroEnum urhero = HeroEnum.None;
            public List<HeroEnum> enemhero = new List<HeroEnum>();
        }

        List<mulliitem> holdlist = new List<mulliitem>();
        List<mulliitem> deletelist = new List<mulliitem>();
        List<concedeItem> concedelist = new List<concedeItem>();
        public bool loserLoserLoser = false;

        private static Mulligan instance;

        public static Mulligan Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new Mulligan();
                }
                return instance;
            }
        }

        private Mulligan()
        {
            readCombos();
        }

        private void readCombos()
        {
            string[] lines = new string[0] { };
            this.holdlist.Clear();
            this.deletelist.Clear();
            try
            {
                string path = Settings.Instance.path;
                lines = System.IO.File.ReadAllLines(path + "_mulligan.txt");
            }
            catch
            {
                Helpfunctions.Instance.logg("cant find _mulligan.txt");
                Helpfunctions.Instance.ErrorLog("cant find _mulligan.txt (if you dont created your own mulliganfile, ignore this message)");
                return;
            }
            Helpfunctions.Instance.logg("read _mulligan.txt...");
            Helpfunctions.Instance.ErrorLog("read _mulligan.txt...");
            foreach (string line in lines)
            {
                if (line.StartsWith("loser"))
                {
                    this.loserLoserLoser = true;
                    continue;
                }

                if (line.StartsWith("concede:"))
                {
                    try
                    {
                        string ownh = line.Split(':')[1];
                        concedeItem ci = new concedeItem();
                        ci.urhero = Hrtprozis.Instance.heroNametoEnum(ownh);
                        string enemlist = line.Split(':')[2];
                        foreach (string s in enemlist.Split(','))
                        {
                            ci.enemhero.Add(Hrtprozis.Instance.heroNametoEnum(s));
                        }
                        concedelist.Add(ci);
                    }
                    catch
                    {
                        Helpfunctions.Instance.logg("mullimaker cant read: " + line);
                        Helpfunctions.Instance.ErrorLog("mullimaker cant read: " + line);
                    }
                    continue;
                }

                if (line.StartsWith("hold;"))
                {
                    try
                    {
                        string ownclass = line.Split(';')[1];
                        string enemyclass = line.Split(';')[2];
                        string cardlist = line.Split(';')[3];
                        foreach (string crd in cardlist.Split(','))
                        {
                            if (crd.Contains(":"))
                            {
                                if ((crd.Split(':')).Length == 3)
                                {
                                    this.holdlist.Add(new mulliitem(line, crd.Split(':')[0], ownclass, enemyclass, Convert.ToInt32(crd.Split(':')[1]), crd.Split(':')[2].Split('/')));
                                }
                                else
                                {
                                    this.holdlist.Add(new mulliitem(line, crd.Split(':')[0], ownclass, enemyclass, Convert.ToInt32(crd.Split(':')[1])));
                                }

                            }
                            else
                            {
                                this.holdlist.Add(new mulliitem(line, crd, ownclass, enemyclass, 2));
                            }
                        }

                        if (line.Split(';').Length == 5)
                        {
                            int manarule = Convert.ToInt32(line.Split(';')[4]);
                            this.holdlist.Add(new mulliitem(line, "#MANARULE", ownclass, enemyclass, 2, null, manarule));
                        }

                    }
                    catch
                    {
                        Helpfunctions.Instance.logg("mullimaker cant read: " + line);
                        Helpfunctions.Instance.ErrorLog("mullimaker cant read: " + line);
                    }
                }
                else
                {
                    if (line.StartsWith("discard;"))
                    {
                        try
                        {
                            string ownclass = line.Split(';')[1];
                            string enemyclass = line.Split(';')[2];
                            string cardlist = line.Split(';')[3];
                            foreach (string crd in cardlist.Split(','))
                            {
                                if (crd == null || crd == "") continue;
                                this.deletelist.Add(new mulliitem(line, crd, ownclass, enemyclass, 2));
                            }

                            if (line.Split(';').Length == 5)
                            {
                                int manarule = Convert.ToInt32(line.Split(';')[4]);
                                this.deletelist.Add(new mulliitem(line, "#MANARULE", ownclass, enemyclass, 2, null, manarule));
                            }

                        }
                        catch
                        {
                            Helpfunctions.Instance.logg("mullimaker cant read: " + line);
                            Helpfunctions.Instance.ErrorLog("mullimaker cant read: " + line);
                        }
                    }
                    else
                    {

                    }
                }

            }

        }

        public bool hasmulliganrules(string ownclass, string enemclass)
        {
            if (this.holdlist.Count == 0 && this.deletelist.Count == 0) return false;
            bool hasARule = false;
            foreach (mulliitem mi in this.holdlist)
            {
                if ((mi.enemyclass == "all" || mi.enemyclass == enemclass) && (mi.ownclass == "all" || mi.ownclass == ownclass)) hasARule = true;
            }
            foreach (mulliitem mi in this.deletelist)
            {
                if ((mi.enemyclass == "all" || mi.enemyclass == enemclass) && (mi.ownclass == "all" || mi.ownclass == ownclass)) hasARule = true;
            }
            return hasARule;
        }

        public bool hasHoldListRule(string ownclass, string enemclass)
        {
            bool hasARule = false;
            foreach (mulliitem mi in this.holdlist)
            {
                if ((mi.enemyclass == "all" || mi.enemyclass == enemclass) && (mi.ownclass == "all" || mi.ownclass == ownclass)) hasARule = true;
            }
            return hasARule;
        }

        public List<int> whatShouldIMulligan(List<CardIDEntity> cards, string ownclass, string enemclass)
        {
            List<int> discarditems = new List<int>();

            foreach (mulliitem mi in this.deletelist)
            {
                foreach (CardIDEntity c in cards)
                {
                    if (mi.cardid == "#MANARULE" && (mi.enemyclass == "all" || mi.enemyclass == enemclass) && (mi.ownclass == "all" || mi.ownclass == ownclass))
                    {
                        if (CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(c.id)).cost >= mi.manarule)
                        {
                            if (discarditems.Contains(c.entitiy)) continue;
                            Helpfunctions.Instance.ErrorLog("discard " + c.id + " because of this rule " + mi.rulestring);
                            discarditems.Add(c.entitiy);
                        }
                        continue;
                    }

                    if (c.id == mi.cardid && (mi.enemyclass == "all" || mi.enemyclass == enemclass) && (mi.ownclass == "all" || mi.ownclass == ownclass))
                    {
                        if (discarditems.Contains(c.entitiy)) continue;
                        Helpfunctions.Instance.ErrorLog("discard " + c.id + " because of this rule " + mi.rulestring);
                        discarditems.Add(c.entitiy);
                    }
                }
            }

            if (holdlist.Count == 0 || !hasHoldListRule(ownclass, enemclass)) return discarditems;

            Dictionary<string, int> holddic = new Dictionary<string, int>();
            foreach (CardIDEntity c in cards)
            {
                bool delete = true;
                foreach (mulliitem mi in this.holdlist)
                {

                    if (mi.cardid == "#MANARULE" && (mi.enemyclass == "all" || mi.enemyclass == enemclass) && (mi.ownclass == "all" || mi.ownclass == ownclass))
                    {
                        if (CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(c.id)).cost <= mi.manarule)
                        {
                            delete = false;
                        }
                        continue;
                    }

                    if (c.id == mi.cardid && (mi.enemyclass == "all" || mi.enemyclass == enemclass) && (mi.ownclass == "all" || mi.ownclass == ownclass))
                    {

                        if (mi.requiresCard == null)
                        {

                            if (holddic.ContainsKey(c.id)) // we are holding one of the cards
                            {
                                if (mi.howmuch == 2)
                                {
                                    delete = false;
                                }
                            }
                            else
                            {
                                delete = false;
                            }
                        }
                        else
                        {
                            bool hasRequirements = false;
                            foreach (CardIDEntity reqs in cards)
                            {
                                foreach (string s in mi.requiresCard)
                                {
                                    if (s == reqs.id)
                                    {
                                        hasRequirements = true;
                                        break;
                                    }
                                }
                            }
                            if (hasRequirements)
                            {
                                if (holddic.ContainsKey(c.id)) // we are holding one of the cards
                                {
                                    if (mi.howmuch == 2)
                                    {
                                        delete = false;
                                    }
                                }
                                else
                                {
                                    delete = false;
                                }
                            }

                        }
                    }
                }

                if (delete)
                {
                    if (discarditems.Contains(c.entitiy)) continue;
                    discarditems.Add(c.entitiy);
                }
                else
                {
                    discarditems.RemoveAll(x => x == c.entitiy);

                    if (holddic.ContainsKey(c.id))
                    {
                        holddic[c.id]++;
                    }
                    else
                    {
                        holddic.Add(c.id, 1);
                    }
                }

            }

            return discarditems;

        }

        public void setAutoConcede(bool mode)
        {
            this.loserLoserLoser = mode;
        }

        public bool shouldConcede(HeroEnum ownhero, HeroEnum enemHero)
        {

            foreach (concedeItem ci in concedelist)
            {
                if (ci.urhero == ownhero && ci.enemhero.Contains(enemHero)) return true;
            }

            return false;
        }

    }

    public struct targett
    {
        public int target;
        public int targetEntity;

        public targett(int targ, int ent)
        {
            this.target = targ;
            this.targetEntity = ent;
        }
    }


    public class CardDB
    {
        // Data is stored in hearthstone-folder -> data->win cardxml0
        //(data-> cardxml0 seems outdated (blutelfkleriker has 3hp there >_>)
        public enum cardtype
        {
            NONE,
            MOB,
            SPELL,
            WEAPON,
            HEROPWR,
            ENCHANTMENT,

        }

        public enum cardrace
        {
            INVALID,
            BLOODELF,
            DRAENEI,
            DWARF,
            GNOME,
            GOBLIN,
            HUMAN,
            NIGHTELF,
            ORC,
            TAUREN,
            TROLL,
            UNDEAD,
            WORGEN,
            GOBLIN2,
            MURLOC,
            DEMON,
            SCOURGE,
            MECHANICAL,
            ELEMENTAL,
            OGRE,
            PET,
            TOTEM,
            NERUBIAN,
            PIRATE,
            DRAGON
        }


        public enum cardIDEnum
        {
            None,
            CS1h_001,
            CS1_042,
            CS1_112,
            CS1_113,
            CS1_113e,
            CS1_130,
            CS2_003,
            CS2_004,
            CS2_004e,
            CS2_005,
            CS2_005o,
            CS2_007,
            CS2_008,
            CS2_009,
            CS2_009e,
            CS2_011,
            CS2_011o,
            CS2_012,
            CS2_013,
            CS2_013t,
            CS2_017,
            CS2_017o,
            CS2_022,
            CS2_022e,
            CS2_023,
            CS2_024,
            CS2_025,
            CS2_026,
            CS2_027,
            CS2_029,
            CS2_032,
            CS2_033,
            CS2_034,
            CS2_037,
            CS2_039,
            CS2_041,
            CS2_041e,
            CS2_042,
            CS2_045,
            CS2_045e,
            CS2_046,
            CS2_046e,
            CS2_049,
            CS2_050,
            CS2_051,
            CS2_052,
            CS2_056,
            CS2_057,
            CS2_061,
            CS2_062,
            CS2_063,
            CS2_063e,
            CS2_064,
            CS2_065,
            CS2_072,
            CS2_074,
            CS2_074e,
            CS2_075,
            CS2_076,
            CS2_077,
            CS2_080,
            CS2_082,
            CS2_083b,
            CS2_083e,
            CS2_084,
            CS2_084e,
            CS2_087,
            CS2_087e,
            CS2_088,
            CS2_089,
            CS2_091,
            CS2_092,
            CS2_092e,
            CS2_093,
            CS2_094,
            CS2_097,
            CS2_101,
            CS2_101t,
            CS2_102,
            CS2_103,
            CS2_103e2,
            CS2_105,
            CS2_105e,
            CS2_106,
            CS2_108,
            CS2_112,
            CS2_114,
            CS2_118,
            CS2_119,
            CS2_120,
            CS2_121,
            CS2_122,
            CS2_122e,
            CS2_124,
            CS2_125,
            CS2_127,
            CS2_131,
            CS2_141,
            CS2_142,
            CS2_147,
            CS2_150,
            CS2_155,
            CS2_162,
            CS2_168,
            CS2_171,
            CS2_172,
            CS2_173,
            CS2_179,
            CS2_182,
            CS2_186,
            CS2_187,
            CS2_189,
            CS2_196,
            CS2_197,
            CS2_200,
            CS2_201,
            CS2_213,
            CS2_222,
            CS2_222o,
            CS2_226,
            CS2_226e,
            CS2_232,
            CS2_234,
            CS2_235,
            CS2_236,
            CS2_236e,
            CS2_237,
            CS2_boar,
            CS2_mirror,
            CS2_tk1,
            DS1h_292,
            DS1_055,
            DS1_070,
            DS1_070o,
            DS1_175,
            DS1_175o,
            DS1_178,
            DS1_178e,
            DS1_183,
            DS1_184,
            DS1_185,
            DS1_233,
            EX1_011,
            EX1_015,
            EX1_019,
            EX1_019e,
            EX1_025,
            EX1_025t,
            EX1_066,
            EX1_084,
            EX1_084e,
            EX1_129,
            EX1_169,
            EX1_173,
            EX1_244,
            EX1_244e,
            EX1_246,
            EX1_246e,
            EX1_277,
            EX1_278,
            EX1_302,
            EX1_306,
            EX1_308,
            EX1_360,
            EX1_360e,
            EX1_371,
            EX1_399,
            EX1_399e,
            EX1_400,
            EX1_506,
            EX1_506a,
            EX1_508,
            EX1_508o,
            EX1_539,
            EX1_565,
            EX1_565o,
            EX1_581,
            EX1_582,
            EX1_587,
            EX1_593,
            EX1_606,
            EX1_622,
            GAME_001,
            GAME_002,
            GAME_003,
            GAME_003e,
            GAME_004,
            GAME_005,
            GAME_005e,
            GAME_006,
            HERO_01,
            HERO_02,
            HERO_03,
            HERO_04,
            HERO_05,
            HERO_06,
            HERO_07,
            HERO_08,
            HERO_09,
            hexfrog,
            NEW1_003,
            NEW1_004,
            NEW1_009,
            NEW1_011,
            NEW1_031,
            NEW1_032,
            NEW1_033,
            NEW1_033o,
            NEW1_034,
            skele11,
            CS1_069,
            CS1_129,
            CS1_129e,
            CS2_028,
            CS2_031,
            CS2_038,
            CS2_038e,
            CS2_053,
            CS2_053e,
            CS2_059,
            CS2_059o,
            CS2_073,
            CS2_073e,
            CS2_073e2,
            CS2_104,
            CS2_104e,
            CS2_117,
            CS2_146,
            CS2_146o,
            CS2_151,
            CS2_152,
            CS2_161,
            CS2_169,
            CS2_181,
            CS2_181e,
            CS2_188,
            CS2_188o,
            CS2_203,
            CS2_221,
            CS2_221e,
            CS2_227,
            CS2_231,
            CS2_233,
            DREAM_01,
            DREAM_02,
            DREAM_03,
            DREAM_04,
            DREAM_05,
            DREAM_05e,
            DS1_188,
            ds1_whelptoken,
            EX1_001,
            EX1_001e,
            EX1_002,
            EX1_004,
            EX1_004e,
            EX1_005,
            EX1_006,
            EX1_007,
            EX1_008,
            EX1_009,
            EX1_010,
            EX1_012,
            EX1_014,
            EX1_014t,
            EX1_014te,
            EX1_016,
            EX1_017,
            EX1_020,
            EX1_021,
            EX1_023,
            EX1_028,
            EX1_029,
            EX1_032,
            EX1_033,
            EX1_043,
            EX1_043e,
            EX1_044,
            EX1_044e,
            EX1_045,
            EX1_046,
            EX1_046e,
            EX1_048,
            EX1_049,
            EX1_050,
            EX1_055,
            EX1_055o,
            EX1_057,
            EX1_058,
            EX1_059,
            EX1_059e,
            EX1_067,
            EX1_076,
            EX1_080,
            EX1_080o,
            EX1_082,
            EX1_083,
            EX1_085,
            EX1_089,
            EX1_091,
            EX1_093,
            EX1_093e,
            EX1_095,
            EX1_096,
            EX1_097,
            EX1_100,
            EX1_102,
            EX1_103,
            EX1_103e,
            EX1_105,
            EX1_110,
            EX1_110t,
            EX1_116,
            EX1_116t,
            EX1_124,
            EX1_126,
            EX1_128,
            EX1_128e,
            EX1_130,
            EX1_130a,
            EX1_131,
            EX1_131t,
            EX1_132,
            EX1_133,
            EX1_134,
            EX1_136,
            EX1_137,
            EX1_144,
            EX1_145,
            EX1_145o,
            EX1_154,
            EX1_154a,
            EX1_154b,
            EX1_155,
            EX1_155a,
            EX1_155ae,
            EX1_155b,
            EX1_155be,
            EX1_158,
            EX1_158e,
            EX1_158t,
            EX1_160,
            EX1_160a,
            EX1_160b,
            EX1_160be,
            EX1_160t,
            EX1_161,
            EX1_161o,
            EX1_162,
            EX1_162o,
            EX1_164,
            EX1_164a,
            EX1_164b,
            EX1_165,
            EX1_165a,
            EX1_165b,
            EX1_165t1,
            EX1_165t2,
            EX1_166,
            EX1_166a,
            EX1_166b,
            EX1_170,
            EX1_178,
            EX1_178a,
            EX1_178ae,
            EX1_178b,
            EX1_178be,
            EX1_238,
            EX1_241,
            EX1_243,
            EX1_245,
            EX1_247,
            EX1_248,
            EX1_249,
            EX1_250,
            EX1_251,
            EX1_258,
            EX1_258e,
            EX1_259,
            EX1_274,
            EX1_274e,
            EX1_275,
            EX1_279,
            EX1_283,
            EX1_284,
            EX1_287,
            EX1_289,
            EX1_294,
            EX1_295,
            EX1_295o,
            EX1_298,
            EX1_301,
            EX1_303,
            EX1_304,
            EX1_304e,
            EX1_309,
            EX1_310,
            EX1_312,
            EX1_313,
            EX1_315,
            EX1_316,
            EX1_316e,
            EX1_317,
            EX1_317t,
            EX1_319,
            EX1_320,
            EX1_323,
            EX1_323h,
            EX1_323w,
            EX1_332,
            EX1_334,
            EX1_334e,
            EX1_335,
            EX1_339,
            EX1_341,
            EX1_345,
            EX1_345t,
            EX1_349,
            EX1_350,
            EX1_354,
            EX1_355,
            EX1_355e,
            EX1_362,
            EX1_363,
            EX1_363e,
            EX1_363e2,
            EX1_365,
            EX1_366,
            EX1_366e,
            EX1_379,
            EX1_379e,
            EX1_382,
            EX1_382e,
            EX1_383,
            EX1_383t,
            EX1_384,
            EX1_390,
            EX1_391,
            EX1_392,
            EX1_393,
            EX1_396,
            EX1_398,
            EX1_398t,
            EX1_402,
            EX1_405,
            EX1_407,
            EX1_408,
            EX1_409,
            EX1_409e,
            EX1_409t,
            EX1_410,
            EX1_411,
            EX1_411e,
            EX1_411e2,
            EX1_412,
            EX1_414,
            EX1_507,
            EX1_507e,
            EX1_509,
            EX1_509e,
            EX1_522,
            EX1_531,
            EX1_531e,
            EX1_533,
            EX1_534,
            EX1_534t,
            EX1_536,
            EX1_536e,
            EX1_537,
            EX1_538,
            EX1_538t,
            EX1_543,
            EX1_544,
            EX1_549,
            EX1_549o,
            EX1_554,
            EX1_554t,
            EX1_556,
            EX1_557,
            EX1_558,
            EX1_559,
            EX1_560,
            EX1_561,
            EX1_561e,
            EX1_562,
            EX1_563,
            EX1_564,
            EX1_567,
            EX1_570,
            EX1_570e,
            EX1_571,
            EX1_572,
            EX1_573,
            EX1_573a,
            EX1_573ae,
            EX1_573b,
            EX1_573t,
            EX1_575,
            EX1_577,
            EX1_578,
            EX1_583,
            EX1_584,
            EX1_584e,
            EX1_586,
            EX1_590,
            EX1_590e,
            EX1_591,
            EX1_594,
            EX1_595,
            EX1_596,
            EX1_596e,
            EX1_597,
            EX1_598,
            EX1_603,
            EX1_603e,
            EX1_604,
            EX1_604o,
            EX1_607,
            EX1_607e,
            EX1_608,
            EX1_609,
            EX1_610,
            EX1_611,
            EX1_611e,
            EX1_612,
            EX1_612o,
            EX1_613,
            EX1_613e,
            EX1_614,
            EX1_614t,
            EX1_616,
            EX1_617,
            EX1_619,
            EX1_619e,
            EX1_620,
            EX1_621,
            EX1_623,
            EX1_623e,
            EX1_624,
            EX1_625,
            EX1_625t,
            EX1_625t2,
            EX1_626,
            EX1_finkle,
            EX1_tk11,
            EX1_tk28,
            EX1_tk29,
            EX1_tk31,
            EX1_tk33,
            EX1_tk34,
            EX1_tk9,
            NEW1_005,
            NEW1_007,
            NEW1_007a,
            NEW1_007b,
            NEW1_008,
            NEW1_008a,
            NEW1_008b,
            NEW1_010,
            NEW1_012,
            NEW1_012o,
            NEW1_014,
            NEW1_017,
            NEW1_017e,
            NEW1_018,
            NEW1_018e,
            NEW1_019,
            NEW1_020,
            NEW1_021,
            NEW1_022,
            NEW1_023,
            NEW1_024,
            NEW1_024o,
            NEW1_025,
            NEW1_025e,
            NEW1_026,
            NEW1_026t,
            NEW1_027,
            NEW1_027e,
            NEW1_029,
            NEW1_029t,
            NEW1_030,
            NEW1_036,
            NEW1_036e,
            NEW1_036e2,
            NEW1_037,
            NEW1_037e,
            NEW1_038,
            NEW1_038o,
            NEW1_040,
            NEW1_040t,
            NEW1_041,
            skele21,
            tt_004,
            tt_004o,
            tt_010,
            tt_010a,
            CRED_01,
            CRED_02,
            CRED_03,
            CRED_04,
            CRED_05,
            CRED_06,
            CRED_07,
            CRED_08,
            CRED_09,
            CRED_10,
            CRED_11,
            CRED_12,
            CRED_13,
            CRED_14,
            CRED_15,
            CRED_16,
            CRED_17,
            EX1_062,
            NEW1_016,
            TU4a_001,
            TU4a_002,
            TU4a_003,
            TU4a_004,
            TU4a_005,
            TU4a_006,
            TU4b_001,
            TU4c_001,
            TU4c_002,
            TU4c_003,
            TU4c_004,
            TU4c_005,
            TU4c_006,
            TU4c_006e,
            TU4c_007,
            TU4c_008,
            TU4c_008e,
            TU4d_001,
            TU4d_002,
            TU4d_003,
            TU4e_001,
            TU4e_002,
            TU4e_002t,
            TU4e_003,
            TU4e_004,
            TU4e_005,
            TU4e_007,
            TU4f_001,
            TU4f_002,
            TU4f_003,
            TU4f_004,
            TU4f_004o,
            TU4f_005,
            TU4f_006,
            TU4f_006o,
            TU4f_007,
            XXX_001,
            XXX_002,
            XXX_003,
            XXX_004,
            XXX_005,
            XXX_006,
            XXX_007,
            XXX_008,
            XXX_009,
            XXX_009e,
            XXX_010,
            XXX_011,
            XXX_012,
            XXX_013,
            XXX_014,
            XXX_015,
            XXX_016,
            XXX_017,
            XXX_018,
            XXX_019,
            XXX_020,
            XXX_021,
            XXX_022,
            XXX_022e,
            XXX_023,
            XXX_024,
            XXX_025,
            XXX_026,
            XXX_027,
            XXX_028,
            XXX_029,
            XXX_030,
            XXX_039,
            XXX_040,
            XXX_041,
            XXX_042,
            XXX_043,
            XXX_044,
            XXX_045,
            XXX_046,
            XXX_047,
            XXX_048,
            XXX_049,
            XXX_050,
            XXX_051,
            XXX_052,
            XXX_053,
            XXX_054,
            XXX_054e,
            XXX_055,
            XXX_055e,
            XXX_056,
            XXX_057,
            XXX_095,
            XXX_096,
            XXX_097,
            XXX_098,
            XXX_099,
            EX1_112,
            Mekka1,
            Mekka2,
            Mekka3,
            Mekka3e,
            Mekka4,
            Mekka4e,
            Mekka4t,
            PRO_001,
            PRO_001a,
            PRO_001at,
            PRO_001b,
            PRO_001c,
            FP1_001,
            FP1_002,
            FP1_002t,
            FP1_003,
            FP1_004,
            FP1_005,
            FP1_005e,
            FP1_006,
            FP1_007,
            FP1_007t,
            FP1_008,
            FP1_009,
            FP1_010,
            FP1_011,
            FP1_012,
            FP1_012t,
            FP1_013,
            FP1_014,
            FP1_014t,
            FP1_015,
            FP1_016,
            FP1_017,
            FP1_018,
            FP1_019,
            FP1_019t,
            FP1_020,
            FP1_020e,
            FP1_021,
            FP1_022,
            FP1_023,
            FP1_023e,
            FP1_024,
            FP1_025,
            FP1_026,
            FP1_027,
            FP1_028,
            FP1_028e,
            FP1_029,
            FP1_030,
            FP1_030e,
            FP1_031,
            NAX10_01,
            NAX10_01H,
            NAX10_02,
            NAX10_02H,
            NAX10_03,
            NAX10_03H,
            NAX11_01,
            NAX11_01H,
            NAX11_02,
            NAX11_02H,
            NAX11_03,
            NAX11_04,
            NAX11_04e,
            NAX12_01,
            NAX12_01H,
            NAX12_02,
            NAX12_02e,
            NAX12_02H,
            NAX12_03,
            NAX12_03e,
            NAX12_03H,
            NAX12_04,
            NAX12_04e,
            NAX13_01,
            NAX13_01H,
            NAX13_02,
            NAX13_02e,
            NAX13_03,
            NAX13_03e,
            NAX13_04H,
            NAX13_05H,
            NAX14_01,
            NAX14_01H,
            NAX14_02,
            NAX14_03,
            NAX14_04,
            NAX15_01,
            NAX15_01e,
            NAX15_01H,
            NAX15_01He,
            NAX15_02,
            NAX15_02H,
            NAX15_03n,
            NAX15_03t,
            NAX15_04,
            NAX15_04a,
            NAX15_04H,
            NAX15_05,
            NAX1h_01,
            NAX1h_03,
            NAX1h_04,
            NAX1_01,
            NAX1_03,
            NAX1_04,
            NAX1_05,
            NAX2_01,
            NAX2_01H,
            NAX2_03,
            NAX2_03H,
            NAX2_05,
            NAX2_05H,
            NAX3_01,
            NAX3_01H,
            NAX3_02,
            NAX3_02H,
            NAX3_03,
            NAX4_01,
            NAX4_01H,
            NAX4_03,
            NAX4_03H,
            NAX4_04,
            NAX4_04H,
            NAX4_05,
            NAX5_01,
            NAX5_01H,
            NAX5_02,
            NAX5_02H,
            NAX5_03,
            NAX6_01,
            NAX6_01H,
            NAX6_02,
            NAX6_02H,
            NAX6_03,
            NAX6_03t,
            NAX6_03te,
            NAX6_04,
            NAX7_01,
            NAX7_01H,
            NAX7_02,
            NAX7_03,
            NAX7_03H,
            NAX7_04,
            NAX7_04H,
            NAX7_05,
            NAX8_01,
            NAX8_01H,
            NAX8_02,
            NAX8_02H,
            NAX8_03,
            NAX8_03t,
            NAX8_04,
            NAX8_04t,
            NAX8_05,
            NAX8_05t,
            NAX9_01,
            NAX9_01H,
            NAX9_02,
            NAX9_02H,
            NAX9_03,
            NAX9_03H,
            NAX9_04,
            NAX9_04H,
            NAX9_05,
            NAX9_05H,
            NAX9_06,
            NAX9_07,
            NAX9_07e,
            NAXM_001,
            NAXM_002,
            GVG_001,
            GVG_002,
            GVG_003,
            GVG_004,
            GVG_005,
            GVG_006,
            GVG_007,
            GVG_008,
            GVG_009,
            GVG_010,
            GVG_010b,
            GVG_011,
            GVG_011a,
            GVG_012,
            GVG_013,
            GVG_014,
            GVG_014a,
            GVG_015,
            GVG_016,
            GVG_017,
            GVG_018,
            GVG_019,
            GVG_019e,
            GVG_020,
            GVG_021,
            GVG_021e,
            GVG_022,
            GVG_022a,
            GVG_022b,
            GVG_023,
            GVG_023a,
            GVG_024,
            GVG_025,
            GVG_026,
            GVG_027,
            GVG_027e,
            GVG_028,
            GVG_028t,
            GVG_029,
            GVG_030,
            GVG_030a,
            GVG_030ae,
            GVG_030b,
            GVG_030be,
            GVG_031,
            GVG_032,
            GVG_032a,
            GVG_032b,
            GVG_033,
            GVG_034,
            GVG_035,
            GVG_036,
            GVG_036e,
            GVG_037,
            GVG_038,
            GVG_039,
            GVG_040,
            GVG_041,
            GVG_041a,
            GVG_041b,
            GVG_041c,
            GVG_042,
            GVG_043,
            GVG_043e,
            GVG_044,
            GVG_045,
            GVG_045t,
            GVG_046,
            GVG_046e,
            GVG_047,
            GVG_048,
            GVG_048e,
            GVG_049,
            GVG_049e,
            GVG_050,
            GVG_051,
            GVG_052,
            GVG_053,
            GVG_054,
            GVG_055,
            GVG_055e,
            GVG_056,
            GVG_056t,
            GVG_057,
            GVG_057a,
            GVG_058,
            GVG_059,
            GVG_060,
            GVG_060e,
            GVG_061,
            GVG_062,
            GVG_063,
            GVG_063a,
            GVG_064,
            GVG_065,
            GVG_066,
            GVG_067,
            GVG_067a,
            GVG_068,
            GVG_068a,
            GVG_069,
            GVG_069a,
            GVG_070,
            GVG_071,
            GVG_072,
            GVG_073,
            GVG_074,
            GVG_075,
            GVG_076,
            GVG_076a,
            GVG_077,
            GVG_078,
            GVG_079,
            GVG_080,
            GVG_080t,
            GVG_081,
            GVG_082,
            GVG_083,
            GVG_084,
            GVG_085,
            GVG_086,
            GVG_086e,
            GVG_087,
            GVG_088,
            GVG_089,
            GVG_090,
            GVG_091,
            GVG_092,
            GVG_092t,
            GVG_093,
            GVG_094,
            GVG_095,
            GVG_096,
            GVG_097,
            GVG_098,
            GVG_099,
            GVG_100,
            GVG_100e,
            GVG_101,
            GVG_101e,
            GVG_102,
            GVG_102e,
            GVG_103,
            GVG_104,
            GVG_104a,
            GVG_105,
            GVG_106,
            GVG_106e,
            GVG_107,
            GVG_108,
            GVG_109,
            GVG_110,
            GVG_110t,
            GVG_111,
            GVG_111t,
            GVG_112,
            GVG_113,
            GVG_114,
            GVG_115,
            GVG_116,
            GVG_117,
            GVG_118,
            GVG_119,
            GVG_120,
            GVG_121,
            GVG_122,
            GVG_123,
            GVG_123e,
            PART_001,
            PART_001e,
            PART_002,
            PART_003,
            PART_004,
            PART_004e,
            PART_005,
            PART_006,
            PART_006a,
            PART_007,
            PART_007e,
            PlaceholderCard,
        }

        public cardIDEnum cardIdstringToEnum(string s)
        {
            if (s == "CS1h_001") return CardDB.cardIDEnum.CS1h_001;
            if (s == "CS1_042") return CardDB.cardIDEnum.CS1_042;
            if (s == "CS1_112") return CardDB.cardIDEnum.CS1_112;
            if (s == "CS1_113") return CardDB.cardIDEnum.CS1_113;
            if (s == "CS1_113e") return CardDB.cardIDEnum.CS1_113e;
            if (s == "CS1_130") return CardDB.cardIDEnum.CS1_130;
            if (s == "CS2_003") return CardDB.cardIDEnum.CS2_003;
            if (s == "CS2_004") return CardDB.cardIDEnum.CS2_004;
            if (s == "CS2_004e") return CardDB.cardIDEnum.CS2_004e;
            if (s == "CS2_005") return CardDB.cardIDEnum.CS2_005;
            if (s == "CS2_005o") return CardDB.cardIDEnum.CS2_005o;
            if (s == "CS2_007") return CardDB.cardIDEnum.CS2_007;
            if (s == "CS2_008") return CardDB.cardIDEnum.CS2_008;
            if (s == "CS2_009") return CardDB.cardIDEnum.CS2_009;
            if (s == "CS2_009e") return CardDB.cardIDEnum.CS2_009e;
            if (s == "CS2_011") return CardDB.cardIDEnum.CS2_011;
            if (s == "CS2_011o") return CardDB.cardIDEnum.CS2_011o;
            if (s == "CS2_012") return CardDB.cardIDEnum.CS2_012;
            if (s == "CS2_013") return CardDB.cardIDEnum.CS2_013;
            if (s == "CS2_013t") return CardDB.cardIDEnum.CS2_013t;
            if (s == "CS2_017") return CardDB.cardIDEnum.CS2_017;
            if (s == "CS2_017o") return CardDB.cardIDEnum.CS2_017o;
            if (s == "CS2_022") return CardDB.cardIDEnum.CS2_022;
            if (s == "CS2_022e") return CardDB.cardIDEnum.CS2_022e;
            if (s == "CS2_023") return CardDB.cardIDEnum.CS2_023;
            if (s == "CS2_024") return CardDB.cardIDEnum.CS2_024;
            if (s == "CS2_025") return CardDB.cardIDEnum.CS2_025;
            if (s == "CS2_026") return CardDB.cardIDEnum.CS2_026;
            if (s == "CS2_027") return CardDB.cardIDEnum.CS2_027;
            if (s == "CS2_029") return CardDB.cardIDEnum.CS2_029;
            if (s == "CS2_032") return CardDB.cardIDEnum.CS2_032;
            if (s == "CS2_033") return CardDB.cardIDEnum.CS2_033;
            if (s == "CS2_034") return CardDB.cardIDEnum.CS2_034;
            if (s == "CS2_037") return CardDB.cardIDEnum.CS2_037;
            if (s == "CS2_039") return CardDB.cardIDEnum.CS2_039;
            if (s == "CS2_041") return CardDB.cardIDEnum.CS2_041;
            if (s == "CS2_041e") return CardDB.cardIDEnum.CS2_041e;
            if (s == "CS2_042") return CardDB.cardIDEnum.CS2_042;
            if (s == "CS2_045") return CardDB.cardIDEnum.CS2_045;
            if (s == "CS2_045e") return CardDB.cardIDEnum.CS2_045e;
            if (s == "CS2_046") return CardDB.cardIDEnum.CS2_046;
            if (s == "CS2_046e") return CardDB.cardIDEnum.CS2_046e;
            if (s == "CS2_049") return CardDB.cardIDEnum.CS2_049;
            if (s == "CS2_050") return CardDB.cardIDEnum.CS2_050;
            if (s == "CS2_051") return CardDB.cardIDEnum.CS2_051;
            if (s == "CS2_052") return CardDB.cardIDEnum.CS2_052;
            if (s == "CS2_056") return CardDB.cardIDEnum.CS2_056;
            if (s == "CS2_057") return CardDB.cardIDEnum.CS2_057;
            if (s == "CS2_061") return CardDB.cardIDEnum.CS2_061;
            if (s == "CS2_062") return CardDB.cardIDEnum.CS2_062;
            if (s == "CS2_063") return CardDB.cardIDEnum.CS2_063;
            if (s == "CS2_063e") return CardDB.cardIDEnum.CS2_063e;
            if (s == "CS2_064") return CardDB.cardIDEnum.CS2_064;
            if (s == "CS2_065") return CardDB.cardIDEnum.CS2_065;
            if (s == "CS2_072") return CardDB.cardIDEnum.CS2_072;
            if (s == "CS2_074") return CardDB.cardIDEnum.CS2_074;
            if (s == "CS2_074e") return CardDB.cardIDEnum.CS2_074e;
            if (s == "CS2_075") return CardDB.cardIDEnum.CS2_075;
            if (s == "CS2_076") return CardDB.cardIDEnum.CS2_076;
            if (s == "CS2_077") return CardDB.cardIDEnum.CS2_077;
            if (s == "CS2_080") return CardDB.cardIDEnum.CS2_080;
            if (s == "CS2_082") return CardDB.cardIDEnum.CS2_082;
            if (s == "CS2_083b") return CardDB.cardIDEnum.CS2_083b;
            if (s == "CS2_083e") return CardDB.cardIDEnum.CS2_083e;
            if (s == "CS2_084") return CardDB.cardIDEnum.CS2_084;
            if (s == "CS2_084e") return CardDB.cardIDEnum.CS2_084e;
            if (s == "CS2_087") return CardDB.cardIDEnum.CS2_087;
            if (s == "CS2_087e") return CardDB.cardIDEnum.CS2_087e;
            if (s == "CS2_088") return CardDB.cardIDEnum.CS2_088;
            if (s == "CS2_089") return CardDB.cardIDEnum.CS2_089;
            if (s == "CS2_091") return CardDB.cardIDEnum.CS2_091;
            if (s == "CS2_092") return CardDB.cardIDEnum.CS2_092;
            if (s == "CS2_092e") return CardDB.cardIDEnum.CS2_092e;
            if (s == "CS2_093") return CardDB.cardIDEnum.CS2_093;
            if (s == "CS2_094") return CardDB.cardIDEnum.CS2_094;
            if (s == "CS2_097") return CardDB.cardIDEnum.CS2_097;
            if (s == "CS2_101") return CardDB.cardIDEnum.CS2_101;
            if (s == "CS2_101t") return CardDB.cardIDEnum.CS2_101t;
            if (s == "CS2_102") return CardDB.cardIDEnum.CS2_102;
            if (s == "CS2_103") return CardDB.cardIDEnum.CS2_103;
            if (s == "CS2_103e2") return CardDB.cardIDEnum.CS2_103e2;
            if (s == "CS2_105") return CardDB.cardIDEnum.CS2_105;
            if (s == "CS2_105e") return CardDB.cardIDEnum.CS2_105e;
            if (s == "CS2_106") return CardDB.cardIDEnum.CS2_106;
            if (s == "CS2_108") return CardDB.cardIDEnum.CS2_108;
            if (s == "CS2_112") return CardDB.cardIDEnum.CS2_112;
            if (s == "CS2_114") return CardDB.cardIDEnum.CS2_114;
            if (s == "CS2_118") return CardDB.cardIDEnum.CS2_118;
            if (s == "CS2_119") return CardDB.cardIDEnum.CS2_119;
            if (s == "CS2_120") return CardDB.cardIDEnum.CS2_120;
            if (s == "CS2_121") return CardDB.cardIDEnum.CS2_121;
            if (s == "CS2_122") return CardDB.cardIDEnum.CS2_122;
            if (s == "CS2_122e") return CardDB.cardIDEnum.CS2_122e;
            if (s == "CS2_124") return CardDB.cardIDEnum.CS2_124;
            if (s == "CS2_125") return CardDB.cardIDEnum.CS2_125;
            if (s == "CS2_127") return CardDB.cardIDEnum.CS2_127;
            if (s == "CS2_131") return CardDB.cardIDEnum.CS2_131;
            if (s == "CS2_141") return CardDB.cardIDEnum.CS2_141;
            if (s == "CS2_142") return CardDB.cardIDEnum.CS2_142;
            if (s == "CS2_147") return CardDB.cardIDEnum.CS2_147;
            if (s == "CS2_150") return CardDB.cardIDEnum.CS2_150;
            if (s == "CS2_155") return CardDB.cardIDEnum.CS2_155;
            if (s == "CS2_162") return CardDB.cardIDEnum.CS2_162;
            if (s == "CS2_168") return CardDB.cardIDEnum.CS2_168;
            if (s == "CS2_171") return CardDB.cardIDEnum.CS2_171;
            if (s == "CS2_172") return CardDB.cardIDEnum.CS2_172;
            if (s == "CS2_173") return CardDB.cardIDEnum.CS2_173;
            if (s == "CS2_179") return CardDB.cardIDEnum.CS2_179;
            if (s == "CS2_182") return CardDB.cardIDEnum.CS2_182;
            if (s == "CS2_186") return CardDB.cardIDEnum.CS2_186;
            if (s == "CS2_187") return CardDB.cardIDEnum.CS2_187;
            if (s == "CS2_189") return CardDB.cardIDEnum.CS2_189;
            if (s == "CS2_196") return CardDB.cardIDEnum.CS2_196;
            if (s == "CS2_197") return CardDB.cardIDEnum.CS2_197;
            if (s == "CS2_200") return CardDB.cardIDEnum.CS2_200;
            if (s == "CS2_201") return CardDB.cardIDEnum.CS2_201;
            if (s == "CS2_213") return CardDB.cardIDEnum.CS2_213;
            if (s == "CS2_222") return CardDB.cardIDEnum.CS2_222;
            if (s == "CS2_222o") return CardDB.cardIDEnum.CS2_222o;
            if (s == "CS2_226") return CardDB.cardIDEnum.CS2_226;
            if (s == "CS2_226e") return CardDB.cardIDEnum.CS2_226e;
            if (s == "CS2_232") return CardDB.cardIDEnum.CS2_232;
            if (s == "CS2_234") return CardDB.cardIDEnum.CS2_234;
            if (s == "CS2_235") return CardDB.cardIDEnum.CS2_235;
            if (s == "CS2_236") return CardDB.cardIDEnum.CS2_236;
            if (s == "CS2_236e") return CardDB.cardIDEnum.CS2_236e;
            if (s == "CS2_237") return CardDB.cardIDEnum.CS2_237;
            if (s == "CS2_boar") return CardDB.cardIDEnum.CS2_boar;
            if (s == "CS2_mirror") return CardDB.cardIDEnum.CS2_mirror;
            if (s == "CS2_tk1") return CardDB.cardIDEnum.CS2_tk1;
            if (s == "DS1h_292") return CardDB.cardIDEnum.DS1h_292;
            if (s == "DS1_055") return CardDB.cardIDEnum.DS1_055;
            if (s == "DS1_070") return CardDB.cardIDEnum.DS1_070;
            if (s == "DS1_070o") return CardDB.cardIDEnum.DS1_070o;
            if (s == "DS1_175") return CardDB.cardIDEnum.DS1_175;
            if (s == "DS1_175o") return CardDB.cardIDEnum.DS1_175o;
            if (s == "DS1_178") return CardDB.cardIDEnum.DS1_178;
            if (s == "DS1_178e") return CardDB.cardIDEnum.DS1_178e;
            if (s == "DS1_183") return CardDB.cardIDEnum.DS1_183;
            if (s == "DS1_184") return CardDB.cardIDEnum.DS1_184;
            if (s == "DS1_185") return CardDB.cardIDEnum.DS1_185;
            if (s == "DS1_233") return CardDB.cardIDEnum.DS1_233;
            if (s == "EX1_011") return CardDB.cardIDEnum.EX1_011;
            if (s == "EX1_015") return CardDB.cardIDEnum.EX1_015;
            if (s == "EX1_019") return CardDB.cardIDEnum.EX1_019;
            if (s == "EX1_019e") return CardDB.cardIDEnum.EX1_019e;
            if (s == "EX1_025") return CardDB.cardIDEnum.EX1_025;
            if (s == "EX1_025t") return CardDB.cardIDEnum.EX1_025t;
            if (s == "EX1_066") return CardDB.cardIDEnum.EX1_066;
            if (s == "EX1_084") return CardDB.cardIDEnum.EX1_084;
            if (s == "EX1_084e") return CardDB.cardIDEnum.EX1_084e;
            if (s == "EX1_129") return CardDB.cardIDEnum.EX1_129;
            if (s == "EX1_169") return CardDB.cardIDEnum.EX1_169;
            if (s == "EX1_173") return CardDB.cardIDEnum.EX1_173;
            if (s == "EX1_244") return CardDB.cardIDEnum.EX1_244;
            if (s == "EX1_244e") return CardDB.cardIDEnum.EX1_244e;
            if (s == "EX1_246") return CardDB.cardIDEnum.EX1_246;
            if (s == "EX1_246e") return CardDB.cardIDEnum.EX1_246e;
            if (s == "EX1_277") return CardDB.cardIDEnum.EX1_277;
            if (s == "EX1_278") return CardDB.cardIDEnum.EX1_278;
            if (s == "EX1_302") return CardDB.cardIDEnum.EX1_302;
            if (s == "EX1_306") return CardDB.cardIDEnum.EX1_306;
            if (s == "EX1_308") return CardDB.cardIDEnum.EX1_308;
            if (s == "EX1_360") return CardDB.cardIDEnum.EX1_360;
            if (s == "EX1_360e") return CardDB.cardIDEnum.EX1_360e;
            if (s == "EX1_371") return CardDB.cardIDEnum.EX1_371;
            if (s == "EX1_399") return CardDB.cardIDEnum.EX1_399;
            if (s == "EX1_399e") return CardDB.cardIDEnum.EX1_399e;
            if (s == "EX1_400") return CardDB.cardIDEnum.EX1_400;
            if (s == "EX1_506") return CardDB.cardIDEnum.EX1_506;
            if (s == "EX1_506a") return CardDB.cardIDEnum.EX1_506a;
            if (s == "EX1_508") return CardDB.cardIDEnum.EX1_508;
            if (s == "EX1_508o") return CardDB.cardIDEnum.EX1_508o;
            if (s == "EX1_539") return CardDB.cardIDEnum.EX1_539;
            if (s == "EX1_565") return CardDB.cardIDEnum.EX1_565;
            if (s == "EX1_565o") return CardDB.cardIDEnum.EX1_565o;
            if (s == "EX1_581") return CardDB.cardIDEnum.EX1_581;
            if (s == "EX1_582") return CardDB.cardIDEnum.EX1_582;
            if (s == "EX1_587") return CardDB.cardIDEnum.EX1_587;
            if (s == "EX1_593") return CardDB.cardIDEnum.EX1_593;
            if (s == "EX1_606") return CardDB.cardIDEnum.EX1_606;
            if (s == "EX1_622") return CardDB.cardIDEnum.EX1_622;
            if (s == "GAME_001") return CardDB.cardIDEnum.GAME_001;
            if (s == "GAME_002") return CardDB.cardIDEnum.GAME_002;
            if (s == "GAME_003") return CardDB.cardIDEnum.GAME_003;
            if (s == "GAME_003e") return CardDB.cardIDEnum.GAME_003e;
            if (s == "GAME_004") return CardDB.cardIDEnum.GAME_004;
            if (s == "GAME_005") return CardDB.cardIDEnum.GAME_005;
            if (s == "GAME_005e") return CardDB.cardIDEnum.GAME_005e;
            if (s == "GAME_006") return CardDB.cardIDEnum.GAME_006;
            if (s == "HERO_01") return CardDB.cardIDEnum.HERO_01;
            if (s == "HERO_02") return CardDB.cardIDEnum.HERO_02;
            if (s == "HERO_03") return CardDB.cardIDEnum.HERO_03;
            if (s == "HERO_04") return CardDB.cardIDEnum.HERO_04;
            if (s == "HERO_05") return CardDB.cardIDEnum.HERO_05;
            if (s == "HERO_06") return CardDB.cardIDEnum.HERO_06;
            if (s == "HERO_07") return CardDB.cardIDEnum.HERO_07;
            if (s == "HERO_08") return CardDB.cardIDEnum.HERO_08;
            if (s == "HERO_09") return CardDB.cardIDEnum.HERO_09;
            if (s == "hexfrog") return CardDB.cardIDEnum.hexfrog;
            if (s == "NEW1_003") return CardDB.cardIDEnum.NEW1_003;
            if (s == "NEW1_004") return CardDB.cardIDEnum.NEW1_004;
            if (s == "NEW1_009") return CardDB.cardIDEnum.NEW1_009;
            if (s == "NEW1_011") return CardDB.cardIDEnum.NEW1_011;
            if (s == "NEW1_031") return CardDB.cardIDEnum.NEW1_031;
            if (s == "NEW1_032") return CardDB.cardIDEnum.NEW1_032;
            if (s == "NEW1_033") return CardDB.cardIDEnum.NEW1_033;
            if (s == "NEW1_033o") return CardDB.cardIDEnum.NEW1_033o;
            if (s == "NEW1_034") return CardDB.cardIDEnum.NEW1_034;
            if (s == "skele11") return CardDB.cardIDEnum.skele11;
            if (s == "CS1_069") return CardDB.cardIDEnum.CS1_069;
            if (s == "CS1_129") return CardDB.cardIDEnum.CS1_129;
            if (s == "CS1_129e") return CardDB.cardIDEnum.CS1_129e;
            if (s == "CS2_028") return CardDB.cardIDEnum.CS2_028;
            if (s == "CS2_031") return CardDB.cardIDEnum.CS2_031;
            if (s == "CS2_038") return CardDB.cardIDEnum.CS2_038;
            if (s == "CS2_038e") return CardDB.cardIDEnum.CS2_038e;
            if (s == "CS2_053") return CardDB.cardIDEnum.CS2_053;
            if (s == "CS2_053e") return CardDB.cardIDEnum.CS2_053e;
            if (s == "CS2_059") return CardDB.cardIDEnum.CS2_059;
            if (s == "CS2_059o") return CardDB.cardIDEnum.CS2_059o;
            if (s == "CS2_073") return CardDB.cardIDEnum.CS2_073;
            if (s == "CS2_073e") return CardDB.cardIDEnum.CS2_073e;
            if (s == "CS2_073e2") return CardDB.cardIDEnum.CS2_073e2;
            if (s == "CS2_104") return CardDB.cardIDEnum.CS2_104;
            if (s == "CS2_104e") return CardDB.cardIDEnum.CS2_104e;
            if (s == "CS2_117") return CardDB.cardIDEnum.CS2_117;
            if (s == "CS2_146") return CardDB.cardIDEnum.CS2_146;
            if (s == "CS2_146o") return CardDB.cardIDEnum.CS2_146o;
            if (s == "CS2_151") return CardDB.cardIDEnum.CS2_151;
            if (s == "CS2_152") return CardDB.cardIDEnum.CS2_152;
            if (s == "CS2_161") return CardDB.cardIDEnum.CS2_161;
            if (s == "CS2_169") return CardDB.cardIDEnum.CS2_169;
            if (s == "CS2_181") return CardDB.cardIDEnum.CS2_181;
            if (s == "CS2_181e") return CardDB.cardIDEnum.CS2_181e;
            if (s == "CS2_188") return CardDB.cardIDEnum.CS2_188;
            if (s == "CS2_188o") return CardDB.cardIDEnum.CS2_188o;
            if (s == "CS2_203") return CardDB.cardIDEnum.CS2_203;
            if (s == "CS2_221") return CardDB.cardIDEnum.CS2_221;
            if (s == "CS2_221e") return CardDB.cardIDEnum.CS2_221e;
            if (s == "CS2_227") return CardDB.cardIDEnum.CS2_227;
            if (s == "CS2_231") return CardDB.cardIDEnum.CS2_231;
            if (s == "CS2_233") return CardDB.cardIDEnum.CS2_233;
            if (s == "DREAM_01") return CardDB.cardIDEnum.DREAM_01;
            if (s == "DREAM_02") return CardDB.cardIDEnum.DREAM_02;
            if (s == "DREAM_03") return CardDB.cardIDEnum.DREAM_03;
            if (s == "DREAM_04") return CardDB.cardIDEnum.DREAM_04;
            if (s == "DREAM_05") return CardDB.cardIDEnum.DREAM_05;
            if (s == "DREAM_05e") return CardDB.cardIDEnum.DREAM_05e;
            if (s == "DS1_188") return CardDB.cardIDEnum.DS1_188;
            if (s == "ds1_whelptoken") return CardDB.cardIDEnum.ds1_whelptoken;
            if (s == "EX1_001") return CardDB.cardIDEnum.EX1_001;
            if (s == "EX1_001e") return CardDB.cardIDEnum.EX1_001e;
            if (s == "EX1_002") return CardDB.cardIDEnum.EX1_002;
            if (s == "EX1_004") return CardDB.cardIDEnum.EX1_004;
            if (s == "EX1_004e") return CardDB.cardIDEnum.EX1_004e;
            if (s == "EX1_005") return CardDB.cardIDEnum.EX1_005;
            if (s == "EX1_006") return CardDB.cardIDEnum.EX1_006;
            if (s == "EX1_007") return CardDB.cardIDEnum.EX1_007;
            if (s == "EX1_008") return CardDB.cardIDEnum.EX1_008;
            if (s == "EX1_009") return CardDB.cardIDEnum.EX1_009;
            if (s == "EX1_010") return CardDB.cardIDEnum.EX1_010;
            if (s == "EX1_012") return CardDB.cardIDEnum.EX1_012;
            if (s == "EX1_014") return CardDB.cardIDEnum.EX1_014;
            if (s == "EX1_014t") return CardDB.cardIDEnum.EX1_014t;
            if (s == "EX1_014te") return CardDB.cardIDEnum.EX1_014te;
            if (s == "EX1_016") return CardDB.cardIDEnum.EX1_016;
            if (s == "EX1_017") return CardDB.cardIDEnum.EX1_017;
            if (s == "EX1_020") return CardDB.cardIDEnum.EX1_020;
            if (s == "EX1_021") return CardDB.cardIDEnum.EX1_021;
            if (s == "EX1_023") return CardDB.cardIDEnum.EX1_023;
            if (s == "EX1_028") return CardDB.cardIDEnum.EX1_028;
            if (s == "EX1_029") return CardDB.cardIDEnum.EX1_029;
            if (s == "EX1_032") return CardDB.cardIDEnum.EX1_032;
            if (s == "EX1_033") return CardDB.cardIDEnum.EX1_033;
            if (s == "EX1_043") return CardDB.cardIDEnum.EX1_043;
            if (s == "EX1_043e") return CardDB.cardIDEnum.EX1_043e;
            if (s == "EX1_044") return CardDB.cardIDEnum.EX1_044;
            if (s == "EX1_044e") return CardDB.cardIDEnum.EX1_044e;
            if (s == "EX1_045") return CardDB.cardIDEnum.EX1_045;
            if (s == "EX1_046") return CardDB.cardIDEnum.EX1_046;
            if (s == "EX1_046e") return CardDB.cardIDEnum.EX1_046e;
            if (s == "EX1_048") return CardDB.cardIDEnum.EX1_048;
            if (s == "EX1_049") return CardDB.cardIDEnum.EX1_049;
            if (s == "EX1_050") return CardDB.cardIDEnum.EX1_050;
            if (s == "EX1_055") return CardDB.cardIDEnum.EX1_055;
            if (s == "EX1_055o") return CardDB.cardIDEnum.EX1_055o;
            if (s == "EX1_057") return CardDB.cardIDEnum.EX1_057;
            if (s == "EX1_058") return CardDB.cardIDEnum.EX1_058;
            if (s == "EX1_059") return CardDB.cardIDEnum.EX1_059;
            if (s == "EX1_059e") return CardDB.cardIDEnum.EX1_059e;
            if (s == "EX1_067") return CardDB.cardIDEnum.EX1_067;
            if (s == "EX1_076") return CardDB.cardIDEnum.EX1_076;
            if (s == "EX1_080") return CardDB.cardIDEnum.EX1_080;
            if (s == "EX1_080o") return CardDB.cardIDEnum.EX1_080o;
            if (s == "EX1_082") return CardDB.cardIDEnum.EX1_082;
            if (s == "EX1_083") return CardDB.cardIDEnum.EX1_083;
            if (s == "EX1_085") return CardDB.cardIDEnum.EX1_085;
            if (s == "EX1_089") return CardDB.cardIDEnum.EX1_089;
            if (s == "EX1_091") return CardDB.cardIDEnum.EX1_091;
            if (s == "EX1_093") return CardDB.cardIDEnum.EX1_093;
            if (s == "EX1_093e") return CardDB.cardIDEnum.EX1_093e;
            if (s == "EX1_095") return CardDB.cardIDEnum.EX1_095;
            if (s == "EX1_096") return CardDB.cardIDEnum.EX1_096;
            if (s == "EX1_097") return CardDB.cardIDEnum.EX1_097;
            if (s == "EX1_100") return CardDB.cardIDEnum.EX1_100;
            if (s == "EX1_102") return CardDB.cardIDEnum.EX1_102;
            if (s == "EX1_103") return CardDB.cardIDEnum.EX1_103;
            if (s == "EX1_103e") return CardDB.cardIDEnum.EX1_103e;
            if (s == "EX1_105") return CardDB.cardIDEnum.EX1_105;
            if (s == "EX1_110") return CardDB.cardIDEnum.EX1_110;
            if (s == "EX1_110t") return CardDB.cardIDEnum.EX1_110t;
            if (s == "EX1_116") return CardDB.cardIDEnum.EX1_116;
            if (s == "EX1_116t") return CardDB.cardIDEnum.EX1_116t;
            if (s == "EX1_124") return CardDB.cardIDEnum.EX1_124;
            if (s == "EX1_126") return CardDB.cardIDEnum.EX1_126;
            if (s == "EX1_128") return CardDB.cardIDEnum.EX1_128;
            if (s == "EX1_128e") return CardDB.cardIDEnum.EX1_128e;
            if (s == "EX1_130") return CardDB.cardIDEnum.EX1_130;
            if (s == "EX1_130a") return CardDB.cardIDEnum.EX1_130a;
            if (s == "EX1_131") return CardDB.cardIDEnum.EX1_131;
            if (s == "EX1_131t") return CardDB.cardIDEnum.EX1_131t;
            if (s == "EX1_132") return CardDB.cardIDEnum.EX1_132;
            if (s == "EX1_133") return CardDB.cardIDEnum.EX1_133;
            if (s == "EX1_134") return CardDB.cardIDEnum.EX1_134;
            if (s == "EX1_136") return CardDB.cardIDEnum.EX1_136;
            if (s == "EX1_137") return CardDB.cardIDEnum.EX1_137;
            if (s == "EX1_144") return CardDB.cardIDEnum.EX1_144;
            if (s == "EX1_145") return CardDB.cardIDEnum.EX1_145;
            if (s == "EX1_145o") return CardDB.cardIDEnum.EX1_145o;
            if (s == "EX1_154") return CardDB.cardIDEnum.EX1_154;
            if (s == "EX1_154a") return CardDB.cardIDEnum.EX1_154a;
            if (s == "EX1_154b") return CardDB.cardIDEnum.EX1_154b;
            if (s == "EX1_155") return CardDB.cardIDEnum.EX1_155;
            if (s == "EX1_155a") return CardDB.cardIDEnum.EX1_155a;
            if (s == "EX1_155ae") return CardDB.cardIDEnum.EX1_155ae;
            if (s == "EX1_155b") return CardDB.cardIDEnum.EX1_155b;
            if (s == "EX1_155be") return CardDB.cardIDEnum.EX1_155be;
            if (s == "EX1_158") return CardDB.cardIDEnum.EX1_158;
            if (s == "EX1_158e") return CardDB.cardIDEnum.EX1_158e;
            if (s == "EX1_158t") return CardDB.cardIDEnum.EX1_158t;
            if (s == "EX1_160") return CardDB.cardIDEnum.EX1_160;
            if (s == "EX1_160a") return CardDB.cardIDEnum.EX1_160a;
            if (s == "EX1_160b") return CardDB.cardIDEnum.EX1_160b;
            if (s == "EX1_160be") return CardDB.cardIDEnum.EX1_160be;
            if (s == "EX1_160t") return CardDB.cardIDEnum.EX1_160t;
            if (s == "EX1_161") return CardDB.cardIDEnum.EX1_161;
            if (s == "EX1_161o") return CardDB.cardIDEnum.EX1_161o;
            if (s == "EX1_162") return CardDB.cardIDEnum.EX1_162;
            if (s == "EX1_162o") return CardDB.cardIDEnum.EX1_162o;
            if (s == "EX1_164") return CardDB.cardIDEnum.EX1_164;
            if (s == "EX1_164a") return CardDB.cardIDEnum.EX1_164a;
            if (s == "EX1_164b") return CardDB.cardIDEnum.EX1_164b;
            if (s == "EX1_165") return CardDB.cardIDEnum.EX1_165;
            if (s == "EX1_165a") return CardDB.cardIDEnum.EX1_165a;
            if (s == "EX1_165b") return CardDB.cardIDEnum.EX1_165b;
            if (s == "EX1_165t1") return CardDB.cardIDEnum.EX1_165t1;
            if (s == "EX1_165t2") return CardDB.cardIDEnum.EX1_165t2;
            if (s == "EX1_166") return CardDB.cardIDEnum.EX1_166;
            if (s == "EX1_166a") return CardDB.cardIDEnum.EX1_166a;
            if (s == "EX1_166b") return CardDB.cardIDEnum.EX1_166b;
            if (s == "EX1_170") return CardDB.cardIDEnum.EX1_170;
            if (s == "EX1_178") return CardDB.cardIDEnum.EX1_178;
            if (s == "EX1_178a") return CardDB.cardIDEnum.EX1_178a;
            if (s == "EX1_178ae") return CardDB.cardIDEnum.EX1_178ae;
            if (s == "EX1_178b") return CardDB.cardIDEnum.EX1_178b;
            if (s == "EX1_178be") return CardDB.cardIDEnum.EX1_178be;
            if (s == "EX1_238") return CardDB.cardIDEnum.EX1_238;
            if (s == "EX1_241") return CardDB.cardIDEnum.EX1_241;
            if (s == "EX1_243") return CardDB.cardIDEnum.EX1_243;
            if (s == "EX1_245") return CardDB.cardIDEnum.EX1_245;
            if (s == "EX1_247") return CardDB.cardIDEnum.EX1_247;
            if (s == "EX1_248") return CardDB.cardIDEnum.EX1_248;
            if (s == "EX1_249") return CardDB.cardIDEnum.EX1_249;
            if (s == "EX1_250") return CardDB.cardIDEnum.EX1_250;
            if (s == "EX1_251") return CardDB.cardIDEnum.EX1_251;
            if (s == "EX1_258") return CardDB.cardIDEnum.EX1_258;
            if (s == "EX1_258e") return CardDB.cardIDEnum.EX1_258e;
            if (s == "EX1_259") return CardDB.cardIDEnum.EX1_259;
            if (s == "EX1_274") return CardDB.cardIDEnum.EX1_274;
            if (s == "EX1_274e") return CardDB.cardIDEnum.EX1_274e;
            if (s == "EX1_275") return CardDB.cardIDEnum.EX1_275;
            if (s == "EX1_279") return CardDB.cardIDEnum.EX1_279;
            if (s == "EX1_283") return CardDB.cardIDEnum.EX1_283;
            if (s == "EX1_284") return CardDB.cardIDEnum.EX1_284;
            if (s == "EX1_287") return CardDB.cardIDEnum.EX1_287;
            if (s == "EX1_289") return CardDB.cardIDEnum.EX1_289;
            if (s == "EX1_294") return CardDB.cardIDEnum.EX1_294;
            if (s == "EX1_295") return CardDB.cardIDEnum.EX1_295;
            if (s == "EX1_295o") return CardDB.cardIDEnum.EX1_295o;
            if (s == "EX1_298") return CardDB.cardIDEnum.EX1_298;
            if (s == "EX1_301") return CardDB.cardIDEnum.EX1_301;
            if (s == "EX1_303") return CardDB.cardIDEnum.EX1_303;
            if (s == "EX1_304") return CardDB.cardIDEnum.EX1_304;
            if (s == "EX1_304e") return CardDB.cardIDEnum.EX1_304e;
            if (s == "EX1_309") return CardDB.cardIDEnum.EX1_309;
            if (s == "EX1_310") return CardDB.cardIDEnum.EX1_310;
            if (s == "EX1_312") return CardDB.cardIDEnum.EX1_312;
            if (s == "EX1_313") return CardDB.cardIDEnum.EX1_313;
            if (s == "EX1_315") return CardDB.cardIDEnum.EX1_315;
            if (s == "EX1_316") return CardDB.cardIDEnum.EX1_316;
            if (s == "EX1_316e") return CardDB.cardIDEnum.EX1_316e;
            if (s == "EX1_317") return CardDB.cardIDEnum.EX1_317;
            if (s == "EX1_317t") return CardDB.cardIDEnum.EX1_317t;
            if (s == "EX1_319") return CardDB.cardIDEnum.EX1_319;
            if (s == "EX1_320") return CardDB.cardIDEnum.EX1_320;
            if (s == "EX1_323") return CardDB.cardIDEnum.EX1_323;
            if (s == "EX1_323h") return CardDB.cardIDEnum.EX1_323h;
            if (s == "EX1_323w") return CardDB.cardIDEnum.EX1_323w;
            if (s == "EX1_332") return CardDB.cardIDEnum.EX1_332;
            if (s == "EX1_334") return CardDB.cardIDEnum.EX1_334;
            if (s == "EX1_334e") return CardDB.cardIDEnum.EX1_334e;
            if (s == "EX1_335") return CardDB.cardIDEnum.EX1_335;
            if (s == "EX1_339") return CardDB.cardIDEnum.EX1_339;
            if (s == "EX1_341") return CardDB.cardIDEnum.EX1_341;
            if (s == "EX1_345") return CardDB.cardIDEnum.EX1_345;
            if (s == "EX1_345t") return CardDB.cardIDEnum.EX1_345t;
            if (s == "EX1_349") return CardDB.cardIDEnum.EX1_349;
            if (s == "EX1_350") return CardDB.cardIDEnum.EX1_350;
            if (s == "EX1_354") return CardDB.cardIDEnum.EX1_354;
            if (s == "EX1_355") return CardDB.cardIDEnum.EX1_355;
            if (s == "EX1_355e") return CardDB.cardIDEnum.EX1_355e;
            if (s == "EX1_362") return CardDB.cardIDEnum.EX1_362;
            if (s == "EX1_363") return CardDB.cardIDEnum.EX1_363;
            if (s == "EX1_363e") return CardDB.cardIDEnum.EX1_363e;
            if (s == "EX1_363e2") return CardDB.cardIDEnum.EX1_363e2;
            if (s == "EX1_365") return CardDB.cardIDEnum.EX1_365;
            if (s == "EX1_366") return CardDB.cardIDEnum.EX1_366;
            if (s == "EX1_366e") return CardDB.cardIDEnum.EX1_366e;
            if (s == "EX1_379") return CardDB.cardIDEnum.EX1_379;
            if (s == "EX1_379e") return CardDB.cardIDEnum.EX1_379e;
            if (s == "EX1_382") return CardDB.cardIDEnum.EX1_382;
            if (s == "EX1_382e") return CardDB.cardIDEnum.EX1_382e;
            if (s == "EX1_383") return CardDB.cardIDEnum.EX1_383;
            if (s == "EX1_383t") return CardDB.cardIDEnum.EX1_383t;
            if (s == "EX1_384") return CardDB.cardIDEnum.EX1_384;
            if (s == "EX1_390") return CardDB.cardIDEnum.EX1_390;
            if (s == "EX1_391") return CardDB.cardIDEnum.EX1_391;
            if (s == "EX1_392") return CardDB.cardIDEnum.EX1_392;
            if (s == "EX1_393") return CardDB.cardIDEnum.EX1_393;
            if (s == "EX1_396") return CardDB.cardIDEnum.EX1_396;
            if (s == "EX1_398") return CardDB.cardIDEnum.EX1_398;
            if (s == "EX1_398t") return CardDB.cardIDEnum.EX1_398t;
            if (s == "EX1_402") return CardDB.cardIDEnum.EX1_402;
            if (s == "EX1_405") return CardDB.cardIDEnum.EX1_405;
            if (s == "EX1_407") return CardDB.cardIDEnum.EX1_407;
            if (s == "EX1_408") return CardDB.cardIDEnum.EX1_408;
            if (s == "EX1_409") return CardDB.cardIDEnum.EX1_409;
            if (s == "EX1_409e") return CardDB.cardIDEnum.EX1_409e;
            if (s == "EX1_409t") return CardDB.cardIDEnum.EX1_409t;
            if (s == "EX1_410") return CardDB.cardIDEnum.EX1_410;
            if (s == "EX1_411") return CardDB.cardIDEnum.EX1_411;
            if (s == "EX1_411e") return CardDB.cardIDEnum.EX1_411e;
            if (s == "EX1_411e2") return CardDB.cardIDEnum.EX1_411e2;
            if (s == "EX1_412") return CardDB.cardIDEnum.EX1_412;
            if (s == "EX1_414") return CardDB.cardIDEnum.EX1_414;
            if (s == "EX1_507") return CardDB.cardIDEnum.EX1_507;
            if (s == "EX1_507e") return CardDB.cardIDEnum.EX1_507e;
            if (s == "EX1_509") return CardDB.cardIDEnum.EX1_509;
            if (s == "EX1_509e") return CardDB.cardIDEnum.EX1_509e;
            if (s == "EX1_522") return CardDB.cardIDEnum.EX1_522;
            if (s == "EX1_531") return CardDB.cardIDEnum.EX1_531;
            if (s == "EX1_531e") return CardDB.cardIDEnum.EX1_531e;
            if (s == "EX1_533") return CardDB.cardIDEnum.EX1_533;
            if (s == "EX1_534") return CardDB.cardIDEnum.EX1_534;
            if (s == "EX1_534t") return CardDB.cardIDEnum.EX1_534t;
            if (s == "EX1_536") return CardDB.cardIDEnum.EX1_536;
            if (s == "EX1_536e") return CardDB.cardIDEnum.EX1_536e;
            if (s == "EX1_537") return CardDB.cardIDEnum.EX1_537;
            if (s == "EX1_538") return CardDB.cardIDEnum.EX1_538;
            if (s == "EX1_538t") return CardDB.cardIDEnum.EX1_538t;
            if (s == "EX1_543") return CardDB.cardIDEnum.EX1_543;
            if (s == "EX1_544") return CardDB.cardIDEnum.EX1_544;
            if (s == "EX1_549") return CardDB.cardIDEnum.EX1_549;
            if (s == "EX1_549o") return CardDB.cardIDEnum.EX1_549o;
            if (s == "EX1_554") return CardDB.cardIDEnum.EX1_554;
            if (s == "EX1_554t") return CardDB.cardIDEnum.EX1_554t;
            if (s == "EX1_556") return CardDB.cardIDEnum.EX1_556;
            if (s == "EX1_557") return CardDB.cardIDEnum.EX1_557;
            if (s == "EX1_558") return CardDB.cardIDEnum.EX1_558;
            if (s == "EX1_559") return CardDB.cardIDEnum.EX1_559;
            if (s == "EX1_560") return CardDB.cardIDEnum.EX1_560;
            if (s == "EX1_561") return CardDB.cardIDEnum.EX1_561;
            if (s == "EX1_561e") return CardDB.cardIDEnum.EX1_561e;
            if (s == "EX1_562") return CardDB.cardIDEnum.EX1_562;
            if (s == "EX1_563") return CardDB.cardIDEnum.EX1_563;
            if (s == "EX1_564") return CardDB.cardIDEnum.EX1_564;
            if (s == "EX1_567") return CardDB.cardIDEnum.EX1_567;
            if (s == "EX1_570") return CardDB.cardIDEnum.EX1_570;
            if (s == "EX1_570e") return CardDB.cardIDEnum.EX1_570e;
            if (s == "EX1_571") return CardDB.cardIDEnum.EX1_571;
            if (s == "EX1_572") return CardDB.cardIDEnum.EX1_572;
            if (s == "EX1_573") return CardDB.cardIDEnum.EX1_573;
            if (s == "EX1_573a") return CardDB.cardIDEnum.EX1_573a;
            if (s == "EX1_573ae") return CardDB.cardIDEnum.EX1_573ae;
            if (s == "EX1_573b") return CardDB.cardIDEnum.EX1_573b;
            if (s == "EX1_573t") return CardDB.cardIDEnum.EX1_573t;
            if (s == "EX1_575") return CardDB.cardIDEnum.EX1_575;
            if (s == "EX1_577") return CardDB.cardIDEnum.EX1_577;
            if (s == "EX1_578") return CardDB.cardIDEnum.EX1_578;
            if (s == "EX1_583") return CardDB.cardIDEnum.EX1_583;
            if (s == "EX1_584") return CardDB.cardIDEnum.EX1_584;
            if (s == "EX1_584e") return CardDB.cardIDEnum.EX1_584e;
            if (s == "EX1_586") return CardDB.cardIDEnum.EX1_586;
            if (s == "EX1_590") return CardDB.cardIDEnum.EX1_590;
            if (s == "EX1_590e") return CardDB.cardIDEnum.EX1_590e;
            if (s == "EX1_591") return CardDB.cardIDEnum.EX1_591;
            if (s == "EX1_594") return CardDB.cardIDEnum.EX1_594;
            if (s == "EX1_595") return CardDB.cardIDEnum.EX1_595;
            if (s == "EX1_596") return CardDB.cardIDEnum.EX1_596;
            if (s == "EX1_596e") return CardDB.cardIDEnum.EX1_596e;
            if (s == "EX1_597") return CardDB.cardIDEnum.EX1_597;
            if (s == "EX1_598") return CardDB.cardIDEnum.EX1_598;
            if (s == "EX1_603") return CardDB.cardIDEnum.EX1_603;
            if (s == "EX1_603e") return CardDB.cardIDEnum.EX1_603e;
            if (s == "EX1_604") return CardDB.cardIDEnum.EX1_604;
            if (s == "EX1_604o") return CardDB.cardIDEnum.EX1_604o;
            if (s == "EX1_607") return CardDB.cardIDEnum.EX1_607;
            if (s == "EX1_607e") return CardDB.cardIDEnum.EX1_607e;
            if (s == "EX1_608") return CardDB.cardIDEnum.EX1_608;
            if (s == "EX1_609") return CardDB.cardIDEnum.EX1_609;
            if (s == "EX1_610") return CardDB.cardIDEnum.EX1_610;
            if (s == "EX1_611") return CardDB.cardIDEnum.EX1_611;
            if (s == "EX1_611e") return CardDB.cardIDEnum.EX1_611e;
            if (s == "EX1_612") return CardDB.cardIDEnum.EX1_612;
            if (s == "EX1_612o") return CardDB.cardIDEnum.EX1_612o;
            if (s == "EX1_613") return CardDB.cardIDEnum.EX1_613;
            if (s == "EX1_613e") return CardDB.cardIDEnum.EX1_613e;
            if (s == "EX1_614") return CardDB.cardIDEnum.EX1_614;
            if (s == "EX1_614t") return CardDB.cardIDEnum.EX1_614t;
            if (s == "EX1_616") return CardDB.cardIDEnum.EX1_616;
            if (s == "EX1_617") return CardDB.cardIDEnum.EX1_617;
            if (s == "EX1_619") return CardDB.cardIDEnum.EX1_619;
            if (s == "EX1_619e") return CardDB.cardIDEnum.EX1_619e;
            if (s == "EX1_620") return CardDB.cardIDEnum.EX1_620;
            if (s == "EX1_621") return CardDB.cardIDEnum.EX1_621;
            if (s == "EX1_623") return CardDB.cardIDEnum.EX1_623;
            if (s == "EX1_623e") return CardDB.cardIDEnum.EX1_623e;
            if (s == "EX1_624") return CardDB.cardIDEnum.EX1_624;
            if (s == "EX1_625") return CardDB.cardIDEnum.EX1_625;
            if (s == "EX1_625t") return CardDB.cardIDEnum.EX1_625t;
            if (s == "EX1_625t2") return CardDB.cardIDEnum.EX1_625t2;
            if (s == "EX1_626") return CardDB.cardIDEnum.EX1_626;
            if (s == "EX1_finkle") return CardDB.cardIDEnum.EX1_finkle;
            if (s == "EX1_tk11") return CardDB.cardIDEnum.EX1_tk11;
            if (s == "EX1_tk28") return CardDB.cardIDEnum.EX1_tk28;
            if (s == "EX1_tk29") return CardDB.cardIDEnum.EX1_tk29;
            if (s == "EX1_tk31") return CardDB.cardIDEnum.EX1_tk31;
            if (s == "EX1_tk33") return CardDB.cardIDEnum.EX1_tk33;
            if (s == "EX1_tk34") return CardDB.cardIDEnum.EX1_tk34;
            if (s == "EX1_tk9") return CardDB.cardIDEnum.EX1_tk9;
            if (s == "NEW1_005") return CardDB.cardIDEnum.NEW1_005;
            if (s == "NEW1_007") return CardDB.cardIDEnum.NEW1_007;
            if (s == "NEW1_007a") return CardDB.cardIDEnum.NEW1_007a;
            if (s == "NEW1_007b") return CardDB.cardIDEnum.NEW1_007b;
            if (s == "NEW1_008") return CardDB.cardIDEnum.NEW1_008;
            if (s == "NEW1_008a") return CardDB.cardIDEnum.NEW1_008a;
            if (s == "NEW1_008b") return CardDB.cardIDEnum.NEW1_008b;
            if (s == "NEW1_010") return CardDB.cardIDEnum.NEW1_010;
            if (s == "NEW1_012") return CardDB.cardIDEnum.NEW1_012;
            if (s == "NEW1_012o") return CardDB.cardIDEnum.NEW1_012o;
            if (s == "NEW1_014") return CardDB.cardIDEnum.NEW1_014;
            if (s == "NEW1_017") return CardDB.cardIDEnum.NEW1_017;
            if (s == "NEW1_017e") return CardDB.cardIDEnum.NEW1_017e;
            if (s == "NEW1_018") return CardDB.cardIDEnum.NEW1_018;
            if (s == "NEW1_018e") return CardDB.cardIDEnum.NEW1_018e;
            if (s == "NEW1_019") return CardDB.cardIDEnum.NEW1_019;
            if (s == "NEW1_020") return CardDB.cardIDEnum.NEW1_020;
            if (s == "NEW1_021") return CardDB.cardIDEnum.NEW1_021;
            if (s == "NEW1_022") return CardDB.cardIDEnum.NEW1_022;
            if (s == "NEW1_023") return CardDB.cardIDEnum.NEW1_023;
            if (s == "NEW1_024") return CardDB.cardIDEnum.NEW1_024;
            if (s == "NEW1_024o") return CardDB.cardIDEnum.NEW1_024o;
            if (s == "NEW1_025") return CardDB.cardIDEnum.NEW1_025;
            if (s == "NEW1_025e") return CardDB.cardIDEnum.NEW1_025e;
            if (s == "NEW1_026") return CardDB.cardIDEnum.NEW1_026;
            if (s == "NEW1_026t") return CardDB.cardIDEnum.NEW1_026t;
            if (s == "NEW1_027") return CardDB.cardIDEnum.NEW1_027;
            if (s == "NEW1_027e") return CardDB.cardIDEnum.NEW1_027e;
            if (s == "NEW1_029") return CardDB.cardIDEnum.NEW1_029;
            if (s == "NEW1_029t") return CardDB.cardIDEnum.NEW1_029t;
            if (s == "NEW1_030") return CardDB.cardIDEnum.NEW1_030;
            if (s == "NEW1_036") return CardDB.cardIDEnum.NEW1_036;
            if (s == "NEW1_036e") return CardDB.cardIDEnum.NEW1_036e;
            if (s == "NEW1_036e2") return CardDB.cardIDEnum.NEW1_036e2;
            if (s == "NEW1_037") return CardDB.cardIDEnum.NEW1_037;
            if (s == "NEW1_037e") return CardDB.cardIDEnum.NEW1_037e;
            if (s == "NEW1_038") return CardDB.cardIDEnum.NEW1_038;
            if (s == "NEW1_038o") return CardDB.cardIDEnum.NEW1_038o;
            if (s == "NEW1_040") return CardDB.cardIDEnum.NEW1_040;
            if (s == "NEW1_040t") return CardDB.cardIDEnum.NEW1_040t;
            if (s == "NEW1_041") return CardDB.cardIDEnum.NEW1_041;
            if (s == "skele21") return CardDB.cardIDEnum.skele21;
            if (s == "tt_004") return CardDB.cardIDEnum.tt_004;
            if (s == "tt_004o") return CardDB.cardIDEnum.tt_004o;
            if (s == "tt_010") return CardDB.cardIDEnum.tt_010;
            if (s == "tt_010a") return CardDB.cardIDEnum.tt_010a;
            if (s == "CRED_01") return CardDB.cardIDEnum.CRED_01;
            if (s == "CRED_02") return CardDB.cardIDEnum.CRED_02;
            if (s == "CRED_03") return CardDB.cardIDEnum.CRED_03;
            if (s == "CRED_04") return CardDB.cardIDEnum.CRED_04;
            if (s == "CRED_05") return CardDB.cardIDEnum.CRED_05;
            if (s == "CRED_06") return CardDB.cardIDEnum.CRED_06;
            if (s == "CRED_07") return CardDB.cardIDEnum.CRED_07;
            if (s == "CRED_08") return CardDB.cardIDEnum.CRED_08;
            if (s == "CRED_09") return CardDB.cardIDEnum.CRED_09;
            if (s == "CRED_10") return CardDB.cardIDEnum.CRED_10;
            if (s == "CRED_11") return CardDB.cardIDEnum.CRED_11;
            if (s == "CRED_12") return CardDB.cardIDEnum.CRED_12;
            if (s == "CRED_13") return CardDB.cardIDEnum.CRED_13;
            if (s == "CRED_14") return CardDB.cardIDEnum.CRED_14;
            if (s == "CRED_15") return CardDB.cardIDEnum.CRED_15;
            if (s == "CRED_16") return CardDB.cardIDEnum.CRED_16;
            if (s == "CRED_17") return CardDB.cardIDEnum.CRED_17;
            if (s == "EX1_062") return CardDB.cardIDEnum.EX1_062;
            if (s == "NEW1_016") return CardDB.cardIDEnum.NEW1_016;
            if (s == "TU4a_001") return CardDB.cardIDEnum.TU4a_001;
            if (s == "TU4a_002") return CardDB.cardIDEnum.TU4a_002;
            if (s == "TU4a_003") return CardDB.cardIDEnum.TU4a_003;
            if (s == "TU4a_004") return CardDB.cardIDEnum.TU4a_004;
            if (s == "TU4a_005") return CardDB.cardIDEnum.TU4a_005;
            if (s == "TU4a_006") return CardDB.cardIDEnum.TU4a_006;
            if (s == "TU4b_001") return CardDB.cardIDEnum.TU4b_001;
            if (s == "TU4c_001") return CardDB.cardIDEnum.TU4c_001;
            if (s == "TU4c_002") return CardDB.cardIDEnum.TU4c_002;
            if (s == "TU4c_003") return CardDB.cardIDEnum.TU4c_003;
            if (s == "TU4c_004") return CardDB.cardIDEnum.TU4c_004;
            if (s == "TU4c_005") return CardDB.cardIDEnum.TU4c_005;
            if (s == "TU4c_006") return CardDB.cardIDEnum.TU4c_006;
            if (s == "TU4c_006e") return CardDB.cardIDEnum.TU4c_006e;
            if (s == "TU4c_007") return CardDB.cardIDEnum.TU4c_007;
            if (s == "TU4c_008") return CardDB.cardIDEnum.TU4c_008;
            if (s == "TU4c_008e") return CardDB.cardIDEnum.TU4c_008e;
            if (s == "TU4d_001") return CardDB.cardIDEnum.TU4d_001;
            if (s == "TU4d_002") return CardDB.cardIDEnum.TU4d_002;
            if (s == "TU4d_003") return CardDB.cardIDEnum.TU4d_003;
            if (s == "TU4e_001") return CardDB.cardIDEnum.TU4e_001;
            if (s == "TU4e_002") return CardDB.cardIDEnum.TU4e_002;
            if (s == "TU4e_002t") return CardDB.cardIDEnum.TU4e_002t;
            if (s == "TU4e_003") return CardDB.cardIDEnum.TU4e_003;
            if (s == "TU4e_004") return CardDB.cardIDEnum.TU4e_004;
            if (s == "TU4e_005") return CardDB.cardIDEnum.TU4e_005;
            if (s == "TU4e_007") return CardDB.cardIDEnum.TU4e_007;
            if (s == "TU4f_001") return CardDB.cardIDEnum.TU4f_001;
            if (s == "TU4f_002") return CardDB.cardIDEnum.TU4f_002;
            if (s == "TU4f_003") return CardDB.cardIDEnum.TU4f_003;
            if (s == "TU4f_004") return CardDB.cardIDEnum.TU4f_004;
            if (s == "TU4f_004o") return CardDB.cardIDEnum.TU4f_004o;
            if (s == "TU4f_005") return CardDB.cardIDEnum.TU4f_005;
            if (s == "TU4f_006") return CardDB.cardIDEnum.TU4f_006;
            if (s == "TU4f_006o") return CardDB.cardIDEnum.TU4f_006o;
            if (s == "TU4f_007") return CardDB.cardIDEnum.TU4f_007;
            if (s == "XXX_001") return CardDB.cardIDEnum.XXX_001;
            if (s == "XXX_002") return CardDB.cardIDEnum.XXX_002;
            if (s == "XXX_003") return CardDB.cardIDEnum.XXX_003;
            if (s == "XXX_004") return CardDB.cardIDEnum.XXX_004;
            if (s == "XXX_005") return CardDB.cardIDEnum.XXX_005;
            if (s == "XXX_006") return CardDB.cardIDEnum.XXX_006;
            if (s == "XXX_007") return CardDB.cardIDEnum.XXX_007;
            if (s == "XXX_008") return CardDB.cardIDEnum.XXX_008;
            if (s == "XXX_009") return CardDB.cardIDEnum.XXX_009;
            if (s == "XXX_009e") return CardDB.cardIDEnum.XXX_009e;
            if (s == "XXX_010") return CardDB.cardIDEnum.XXX_010;
            if (s == "XXX_011") return CardDB.cardIDEnum.XXX_011;
            if (s == "XXX_012") return CardDB.cardIDEnum.XXX_012;
            if (s == "XXX_013") return CardDB.cardIDEnum.XXX_013;
            if (s == "XXX_014") return CardDB.cardIDEnum.XXX_014;
            if (s == "XXX_015") return CardDB.cardIDEnum.XXX_015;
            if (s == "XXX_016") return CardDB.cardIDEnum.XXX_016;
            if (s == "XXX_017") return CardDB.cardIDEnum.XXX_017;
            if (s == "XXX_018") return CardDB.cardIDEnum.XXX_018;
            if (s == "XXX_019") return CardDB.cardIDEnum.XXX_019;
            if (s == "XXX_020") return CardDB.cardIDEnum.XXX_020;
            if (s == "XXX_021") return CardDB.cardIDEnum.XXX_021;
            if (s == "XXX_022") return CardDB.cardIDEnum.XXX_022;
            if (s == "XXX_022e") return CardDB.cardIDEnum.XXX_022e;
            if (s == "XXX_023") return CardDB.cardIDEnum.XXX_023;
            if (s == "XXX_024") return CardDB.cardIDEnum.XXX_024;
            if (s == "XXX_025") return CardDB.cardIDEnum.XXX_025;
            if (s == "XXX_026") return CardDB.cardIDEnum.XXX_026;
            if (s == "XXX_027") return CardDB.cardIDEnum.XXX_027;
            if (s == "XXX_028") return CardDB.cardIDEnum.XXX_028;
            if (s == "XXX_029") return CardDB.cardIDEnum.XXX_029;
            if (s == "XXX_030") return CardDB.cardIDEnum.XXX_030;
            if (s == "XXX_039") return CardDB.cardIDEnum.XXX_039;
            if (s == "XXX_040") return CardDB.cardIDEnum.XXX_040;
            if (s == "XXX_041") return CardDB.cardIDEnum.XXX_041;
            if (s == "XXX_042") return CardDB.cardIDEnum.XXX_042;
            if (s == "XXX_043") return CardDB.cardIDEnum.XXX_043;
            if (s == "XXX_044") return CardDB.cardIDEnum.XXX_044;
            if (s == "XXX_045") return CardDB.cardIDEnum.XXX_045;
            if (s == "XXX_046") return CardDB.cardIDEnum.XXX_046;
            if (s == "XXX_047") return CardDB.cardIDEnum.XXX_047;
            if (s == "XXX_048") return CardDB.cardIDEnum.XXX_048;
            if (s == "XXX_049") return CardDB.cardIDEnum.XXX_049;
            if (s == "XXX_050") return CardDB.cardIDEnum.XXX_050;
            if (s == "XXX_051") return CardDB.cardIDEnum.XXX_051;
            if (s == "XXX_052") return CardDB.cardIDEnum.XXX_052;
            if (s == "XXX_053") return CardDB.cardIDEnum.XXX_053;
            if (s == "XXX_054") return CardDB.cardIDEnum.XXX_054;
            if (s == "XXX_054e") return CardDB.cardIDEnum.XXX_054e;
            if (s == "XXX_055") return CardDB.cardIDEnum.XXX_055;
            if (s == "XXX_055e") return CardDB.cardIDEnum.XXX_055e;
            if (s == "XXX_056") return CardDB.cardIDEnum.XXX_056;
            if (s == "XXX_057") return CardDB.cardIDEnum.XXX_057;
            if (s == "XXX_095") return CardDB.cardIDEnum.XXX_095;
            if (s == "XXX_096") return CardDB.cardIDEnum.XXX_096;
            if (s == "XXX_097") return CardDB.cardIDEnum.XXX_097;
            if (s == "XXX_098") return CardDB.cardIDEnum.XXX_098;
            if (s == "XXX_099") return CardDB.cardIDEnum.XXX_099;
            if (s == "EX1_112") return CardDB.cardIDEnum.EX1_112;
            if (s == "Mekka1") return CardDB.cardIDEnum.Mekka1;
            if (s == "Mekka2") return CardDB.cardIDEnum.Mekka2;
            if (s == "Mekka3") return CardDB.cardIDEnum.Mekka3;
            if (s == "Mekka3e") return CardDB.cardIDEnum.Mekka3e;
            if (s == "Mekka4") return CardDB.cardIDEnum.Mekka4;
            if (s == "Mekka4e") return CardDB.cardIDEnum.Mekka4e;
            if (s == "Mekka4t") return CardDB.cardIDEnum.Mekka4t;
            if (s == "PRO_001") return CardDB.cardIDEnum.PRO_001;
            if (s == "PRO_001a") return CardDB.cardIDEnum.PRO_001a;
            if (s == "PRO_001at") return CardDB.cardIDEnum.PRO_001at;
            if (s == "PRO_001b") return CardDB.cardIDEnum.PRO_001b;
            if (s == "PRO_001c") return CardDB.cardIDEnum.PRO_001c;
            if (s == "FP1_001") return CardDB.cardIDEnum.FP1_001;
            if (s == "FP1_002") return CardDB.cardIDEnum.FP1_002;
            if (s == "FP1_002t") return CardDB.cardIDEnum.FP1_002t;
            if (s == "FP1_003") return CardDB.cardIDEnum.FP1_003;
            if (s == "FP1_004") return CardDB.cardIDEnum.FP1_004;
            if (s == "FP1_005") return CardDB.cardIDEnum.FP1_005;
            if (s == "FP1_005e") return CardDB.cardIDEnum.FP1_005e;
            if (s == "FP1_006") return CardDB.cardIDEnum.FP1_006;
            if (s == "FP1_007") return CardDB.cardIDEnum.FP1_007;
            if (s == "FP1_007t") return CardDB.cardIDEnum.FP1_007t;
            if (s == "FP1_008") return CardDB.cardIDEnum.FP1_008;
            if (s == "FP1_009") return CardDB.cardIDEnum.FP1_009;
            if (s == "FP1_010") return CardDB.cardIDEnum.FP1_010;
            if (s == "FP1_011") return CardDB.cardIDEnum.FP1_011;
            if (s == "FP1_012") return CardDB.cardIDEnum.FP1_012;
            if (s == "FP1_012t") return CardDB.cardIDEnum.FP1_012t;
            if (s == "FP1_013") return CardDB.cardIDEnum.FP1_013;
            if (s == "FP1_014") return CardDB.cardIDEnum.FP1_014;
            if (s == "FP1_014t") return CardDB.cardIDEnum.FP1_014t;
            if (s == "FP1_015") return CardDB.cardIDEnum.FP1_015;
            if (s == "FP1_016") return CardDB.cardIDEnum.FP1_016;
            if (s == "FP1_017") return CardDB.cardIDEnum.FP1_017;
            if (s == "FP1_018") return CardDB.cardIDEnum.FP1_018;
            if (s == "FP1_019") return CardDB.cardIDEnum.FP1_019;
            if (s == "FP1_019t") return CardDB.cardIDEnum.FP1_019t;
            if (s == "FP1_020") return CardDB.cardIDEnum.FP1_020;
            if (s == "FP1_020e") return CardDB.cardIDEnum.FP1_020e;
            if (s == "FP1_021") return CardDB.cardIDEnum.FP1_021;
            if (s == "FP1_022") return CardDB.cardIDEnum.FP1_022;
            if (s == "FP1_023") return CardDB.cardIDEnum.FP1_023;
            if (s == "FP1_023e") return CardDB.cardIDEnum.FP1_023e;
            if (s == "FP1_024") return CardDB.cardIDEnum.FP1_024;
            if (s == "FP1_025") return CardDB.cardIDEnum.FP1_025;
            if (s == "FP1_026") return CardDB.cardIDEnum.FP1_026;
            if (s == "FP1_027") return CardDB.cardIDEnum.FP1_027;
            if (s == "FP1_028") return CardDB.cardIDEnum.FP1_028;
            if (s == "FP1_028e") return CardDB.cardIDEnum.FP1_028e;
            if (s == "FP1_029") return CardDB.cardIDEnum.FP1_029;
            if (s == "FP1_030") return CardDB.cardIDEnum.FP1_030;
            if (s == "FP1_030e") return CardDB.cardIDEnum.FP1_030e;
            if (s == "FP1_031") return CardDB.cardIDEnum.FP1_031;
            if (s == "NAX10_01") return CardDB.cardIDEnum.NAX10_01;
            if (s == "NAX10_01H") return CardDB.cardIDEnum.NAX10_01H;
            if (s == "NAX10_02") return CardDB.cardIDEnum.NAX10_02;
            if (s == "NAX10_02H") return CardDB.cardIDEnum.NAX10_02H;
            if (s == "NAX10_03") return CardDB.cardIDEnum.NAX10_03;
            if (s == "NAX10_03H") return CardDB.cardIDEnum.NAX10_03H;
            if (s == "NAX11_01") return CardDB.cardIDEnum.NAX11_01;
            if (s == "NAX11_01H") return CardDB.cardIDEnum.NAX11_01H;
            if (s == "NAX11_02") return CardDB.cardIDEnum.NAX11_02;
            if (s == "NAX11_02H") return CardDB.cardIDEnum.NAX11_02H;
            if (s == "NAX11_03") return CardDB.cardIDEnum.NAX11_03;
            if (s == "NAX11_04") return CardDB.cardIDEnum.NAX11_04;
            if (s == "NAX11_04e") return CardDB.cardIDEnum.NAX11_04e;
            if (s == "NAX12_01") return CardDB.cardIDEnum.NAX12_01;
            if (s == "NAX12_01H") return CardDB.cardIDEnum.NAX12_01H;
            if (s == "NAX12_02") return CardDB.cardIDEnum.NAX12_02;
            if (s == "NAX12_02e") return CardDB.cardIDEnum.NAX12_02e;
            if (s == "NAX12_02H") return CardDB.cardIDEnum.NAX12_02H;
            if (s == "NAX12_03") return CardDB.cardIDEnum.NAX12_03;
            if (s == "NAX12_03e") return CardDB.cardIDEnum.NAX12_03e;
            if (s == "NAX12_03H") return CardDB.cardIDEnum.NAX12_03H;
            if (s == "NAX12_04") return CardDB.cardIDEnum.NAX12_04;
            if (s == "NAX12_04e") return CardDB.cardIDEnum.NAX12_04e;
            if (s == "NAX13_01") return CardDB.cardIDEnum.NAX13_01;
            if (s == "NAX13_01H") return CardDB.cardIDEnum.NAX13_01H;
            if (s == "NAX13_02") return CardDB.cardIDEnum.NAX13_02;
            if (s == "NAX13_02e") return CardDB.cardIDEnum.NAX13_02e;
            if (s == "NAX13_03") return CardDB.cardIDEnum.NAX13_03;
            if (s == "NAX13_03e") return CardDB.cardIDEnum.NAX13_03e;
            if (s == "NAX13_04H") return CardDB.cardIDEnum.NAX13_04H;
            if (s == "NAX13_05H") return CardDB.cardIDEnum.NAX13_05H;
            if (s == "NAX14_01") return CardDB.cardIDEnum.NAX14_01;
            if (s == "NAX14_01H") return CardDB.cardIDEnum.NAX14_01H;
            if (s == "NAX14_02") return CardDB.cardIDEnum.NAX14_02;
            if (s == "NAX14_03") return CardDB.cardIDEnum.NAX14_03;
            if (s == "NAX14_04") return CardDB.cardIDEnum.NAX14_04;
            if (s == "NAX15_01") return CardDB.cardIDEnum.NAX15_01;
            if (s == "NAX15_01e") return CardDB.cardIDEnum.NAX15_01e;
            if (s == "NAX15_01H") return CardDB.cardIDEnum.NAX15_01H;
            if (s == "NAX15_01He") return CardDB.cardIDEnum.NAX15_01He;
            if (s == "NAX15_02") return CardDB.cardIDEnum.NAX15_02;
            if (s == "NAX15_02H") return CardDB.cardIDEnum.NAX15_02H;
            if (s == "NAX15_03n") return CardDB.cardIDEnum.NAX15_03n;
            if (s == "NAX15_03t") return CardDB.cardIDEnum.NAX15_03t;
            if (s == "NAX15_04") return CardDB.cardIDEnum.NAX15_04;
            if (s == "NAX15_04a") return CardDB.cardIDEnum.NAX15_04a;
            if (s == "NAX15_04H") return CardDB.cardIDEnum.NAX15_04H;
            if (s == "NAX15_05") return CardDB.cardIDEnum.NAX15_05;
            if (s == "NAX1h_01") return CardDB.cardIDEnum.NAX1h_01;
            if (s == "NAX1h_03") return CardDB.cardIDEnum.NAX1h_03;
            if (s == "NAX1h_04") return CardDB.cardIDEnum.NAX1h_04;
            if (s == "NAX1_01") return CardDB.cardIDEnum.NAX1_01;
            if (s == "NAX1_03") return CardDB.cardIDEnum.NAX1_03;
            if (s == "NAX1_04") return CardDB.cardIDEnum.NAX1_04;
            if (s == "NAX1_05") return CardDB.cardIDEnum.NAX1_05;
            if (s == "NAX2_01") return CardDB.cardIDEnum.NAX2_01;
            if (s == "NAX2_01H") return CardDB.cardIDEnum.NAX2_01H;
            if (s == "NAX2_03") return CardDB.cardIDEnum.NAX2_03;
            if (s == "NAX2_03H") return CardDB.cardIDEnum.NAX2_03H;
            if (s == "NAX2_05") return CardDB.cardIDEnum.NAX2_05;
            if (s == "NAX2_05H") return CardDB.cardIDEnum.NAX2_05H;
            if (s == "NAX3_01") return CardDB.cardIDEnum.NAX3_01;
            if (s == "NAX3_01H") return CardDB.cardIDEnum.NAX3_01H;
            if (s == "NAX3_02") return CardDB.cardIDEnum.NAX3_02;
            if (s == "NAX3_02H") return CardDB.cardIDEnum.NAX3_02H;
            if (s == "NAX3_03") return CardDB.cardIDEnum.NAX3_03;
            if (s == "NAX4_01") return CardDB.cardIDEnum.NAX4_01;
            if (s == "NAX4_01H") return CardDB.cardIDEnum.NAX4_01H;
            if (s == "NAX4_03") return CardDB.cardIDEnum.NAX4_03;
            if (s == "NAX4_03H") return CardDB.cardIDEnum.NAX4_03H;
            if (s == "NAX4_04") return CardDB.cardIDEnum.NAX4_04;
            if (s == "NAX4_04H") return CardDB.cardIDEnum.NAX4_04H;
            if (s == "NAX4_05") return CardDB.cardIDEnum.NAX4_05;
            if (s == "NAX5_01") return CardDB.cardIDEnum.NAX5_01;
            if (s == "NAX5_01H") return CardDB.cardIDEnum.NAX5_01H;
            if (s == "NAX5_02") return CardDB.cardIDEnum.NAX5_02;
            if (s == "NAX5_02H") return CardDB.cardIDEnum.NAX5_02H;
            if (s == "NAX5_03") return CardDB.cardIDEnum.NAX5_03;
            if (s == "NAX6_01") return CardDB.cardIDEnum.NAX6_01;
            if (s == "NAX6_01H") return CardDB.cardIDEnum.NAX6_01H;
            if (s == "NAX6_02") return CardDB.cardIDEnum.NAX6_02;
            if (s == "NAX6_02H") return CardDB.cardIDEnum.NAX6_02H;
            if (s == "NAX6_03") return CardDB.cardIDEnum.NAX6_03;
            if (s == "NAX6_03t") return CardDB.cardIDEnum.NAX6_03t;
            if (s == "NAX6_03te") return CardDB.cardIDEnum.NAX6_03te;
            if (s == "NAX6_04") return CardDB.cardIDEnum.NAX6_04;
            if (s == "NAX7_01") return CardDB.cardIDEnum.NAX7_01;
            if (s == "NAX7_01H") return CardDB.cardIDEnum.NAX7_01H;
            if (s == "NAX7_02") return CardDB.cardIDEnum.NAX7_02;
            if (s == "NAX7_03") return CardDB.cardIDEnum.NAX7_03;
            if (s == "NAX7_03H") return CardDB.cardIDEnum.NAX7_03H;
            if (s == "NAX7_04") return CardDB.cardIDEnum.NAX7_04;
            if (s == "NAX7_04H") return CardDB.cardIDEnum.NAX7_04H;
            if (s == "NAX7_05") return CardDB.cardIDEnum.NAX7_05;
            if (s == "NAX8_01") return CardDB.cardIDEnum.NAX8_01;
            if (s == "NAX8_01H") return CardDB.cardIDEnum.NAX8_01H;
            if (s == "NAX8_02") return CardDB.cardIDEnum.NAX8_02;
            if (s == "NAX8_02H") return CardDB.cardIDEnum.NAX8_02H;
            if (s == "NAX8_03") return CardDB.cardIDEnum.NAX8_03;
            if (s == "NAX8_03t") return CardDB.cardIDEnum.NAX8_03t;
            if (s == "NAX8_04") return CardDB.cardIDEnum.NAX8_04;
            if (s == "NAX8_04t") return CardDB.cardIDEnum.NAX8_04t;
            if (s == "NAX8_05") return CardDB.cardIDEnum.NAX8_05;
            if (s == "NAX8_05t") return CardDB.cardIDEnum.NAX8_05t;
            if (s == "NAX9_01") return CardDB.cardIDEnum.NAX9_01;
            if (s == "NAX9_01H") return CardDB.cardIDEnum.NAX9_01H;
            if (s == "NAX9_02") return CardDB.cardIDEnum.NAX9_02;
            if (s == "NAX9_02H") return CardDB.cardIDEnum.NAX9_02H;
            if (s == "NAX9_03") return CardDB.cardIDEnum.NAX9_03;
            if (s == "NAX9_03H") return CardDB.cardIDEnum.NAX9_03H;
            if (s == "NAX9_04") return CardDB.cardIDEnum.NAX9_04;
            if (s == "NAX9_04H") return CardDB.cardIDEnum.NAX9_04H;
            if (s == "NAX9_05") return CardDB.cardIDEnum.NAX9_05;
            if (s == "NAX9_05H") return CardDB.cardIDEnum.NAX9_05H;
            if (s == "NAX9_06") return CardDB.cardIDEnum.NAX9_06;
            if (s == "NAX9_07") return CardDB.cardIDEnum.NAX9_07;
            if (s == "NAX9_07e") return CardDB.cardIDEnum.NAX9_07e;
            if (s == "NAXM_001") return CardDB.cardIDEnum.NAXM_001;
            if (s == "NAXM_002") return CardDB.cardIDEnum.NAXM_002;
            if (s == "GVG_001") return CardDB.cardIDEnum.GVG_001;
            if (s == "GVG_002") return CardDB.cardIDEnum.GVG_002;
            if (s == "GVG_003") return CardDB.cardIDEnum.GVG_003;
            if (s == "GVG_004") return CardDB.cardIDEnum.GVG_004;
            if (s == "GVG_005") return CardDB.cardIDEnum.GVG_005;
            if (s == "GVG_006") return CardDB.cardIDEnum.GVG_006;
            if (s == "GVG_007") return CardDB.cardIDEnum.GVG_007;
            if (s == "GVG_008") return CardDB.cardIDEnum.GVG_008;
            if (s == "GVG_009") return CardDB.cardIDEnum.GVG_009;
            if (s == "GVG_010") return CardDB.cardIDEnum.GVG_010;
            if (s == "GVG_010b") return CardDB.cardIDEnum.GVG_010b;
            if (s == "GVG_011") return CardDB.cardIDEnum.GVG_011;
            if (s == "GVG_011a") return CardDB.cardIDEnum.GVG_011a;
            if (s == "GVG_012") return CardDB.cardIDEnum.GVG_012;
            if (s == "GVG_013") return CardDB.cardIDEnum.GVG_013;
            if (s == "GVG_014") return CardDB.cardIDEnum.GVG_014;
            if (s == "GVG_014a") return CardDB.cardIDEnum.GVG_014a;
            if (s == "GVG_015") return CardDB.cardIDEnum.GVG_015;
            if (s == "GVG_016") return CardDB.cardIDEnum.GVG_016;
            if (s == "GVG_017") return CardDB.cardIDEnum.GVG_017;
            if (s == "GVG_018") return CardDB.cardIDEnum.GVG_018;
            if (s == "GVG_019") return CardDB.cardIDEnum.GVG_019;
            if (s == "GVG_019e") return CardDB.cardIDEnum.GVG_019e;
            if (s == "GVG_020") return CardDB.cardIDEnum.GVG_020;
            if (s == "GVG_021") return CardDB.cardIDEnum.GVG_021;
            if (s == "GVG_021e") return CardDB.cardIDEnum.GVG_021e;
            if (s == "GVG_022") return CardDB.cardIDEnum.GVG_022;
            if (s == "GVG_022a") return CardDB.cardIDEnum.GVG_022a;
            if (s == "GVG_022b") return CardDB.cardIDEnum.GVG_022b;
            if (s == "GVG_023") return CardDB.cardIDEnum.GVG_023;
            if (s == "GVG_023a") return CardDB.cardIDEnum.GVG_023a;
            if (s == "GVG_024") return CardDB.cardIDEnum.GVG_024;
            if (s == "GVG_025") return CardDB.cardIDEnum.GVG_025;
            if (s == "GVG_026") return CardDB.cardIDEnum.GVG_026;
            if (s == "GVG_027") return CardDB.cardIDEnum.GVG_027;
            if (s == "GVG_027e") return CardDB.cardIDEnum.GVG_027e;
            if (s == "GVG_028") return CardDB.cardIDEnum.GVG_028;
            if (s == "GVG_028t") return CardDB.cardIDEnum.GVG_028t;
            if (s == "GVG_029") return CardDB.cardIDEnum.GVG_029;
            if (s == "GVG_030") return CardDB.cardIDEnum.GVG_030;
            if (s == "GVG_030a") return CardDB.cardIDEnum.GVG_030a;
            if (s == "GVG_030ae") return CardDB.cardIDEnum.GVG_030ae;
            if (s == "GVG_030b") return CardDB.cardIDEnum.GVG_030b;
            if (s == "GVG_030be") return CardDB.cardIDEnum.GVG_030be;
            if (s == "GVG_031") return CardDB.cardIDEnum.GVG_031;
            if (s == "GVG_032") return CardDB.cardIDEnum.GVG_032;
            if (s == "GVG_032a") return CardDB.cardIDEnum.GVG_032a;
            if (s == "GVG_032b") return CardDB.cardIDEnum.GVG_032b;
            if (s == "GVG_033") return CardDB.cardIDEnum.GVG_033;
            if (s == "GVG_034") return CardDB.cardIDEnum.GVG_034;
            if (s == "GVG_035") return CardDB.cardIDEnum.GVG_035;
            if (s == "GVG_036") return CardDB.cardIDEnum.GVG_036;
            if (s == "GVG_036e") return CardDB.cardIDEnum.GVG_036e;
            if (s == "GVG_037") return CardDB.cardIDEnum.GVG_037;
            if (s == "GVG_038") return CardDB.cardIDEnum.GVG_038;
            if (s == "GVG_039") return CardDB.cardIDEnum.GVG_039;
            if (s == "GVG_040") return CardDB.cardIDEnum.GVG_040;
            if (s == "GVG_041") return CardDB.cardIDEnum.GVG_041;
            if (s == "GVG_041a") return CardDB.cardIDEnum.GVG_041a;
            if (s == "GVG_041b") return CardDB.cardIDEnum.GVG_041b;
            if (s == "GVG_041c") return CardDB.cardIDEnum.GVG_041c;
            if (s == "GVG_042") return CardDB.cardIDEnum.GVG_042;
            if (s == "GVG_043") return CardDB.cardIDEnum.GVG_043;
            if (s == "GVG_043e") return CardDB.cardIDEnum.GVG_043e;
            if (s == "GVG_044") return CardDB.cardIDEnum.GVG_044;
            if (s == "GVG_045") return CardDB.cardIDEnum.GVG_045;
            if (s == "GVG_045t") return CardDB.cardIDEnum.GVG_045t;
            if (s == "GVG_046") return CardDB.cardIDEnum.GVG_046;
            if (s == "GVG_046e") return CardDB.cardIDEnum.GVG_046e;
            if (s == "GVG_047") return CardDB.cardIDEnum.GVG_047;
            if (s == "GVG_048") return CardDB.cardIDEnum.GVG_048;
            if (s == "GVG_048e") return CardDB.cardIDEnum.GVG_048e;
            if (s == "GVG_049") return CardDB.cardIDEnum.GVG_049;
            if (s == "GVG_049e") return CardDB.cardIDEnum.GVG_049e;
            if (s == "GVG_050") return CardDB.cardIDEnum.GVG_050;
            if (s == "GVG_051") return CardDB.cardIDEnum.GVG_051;
            if (s == "GVG_052") return CardDB.cardIDEnum.GVG_052;
            if (s == "GVG_053") return CardDB.cardIDEnum.GVG_053;
            if (s == "GVG_054") return CardDB.cardIDEnum.GVG_054;
            if (s == "GVG_055") return CardDB.cardIDEnum.GVG_055;
            if (s == "GVG_055e") return CardDB.cardIDEnum.GVG_055e;
            if (s == "GVG_056") return CardDB.cardIDEnum.GVG_056;
            if (s == "GVG_056t") return CardDB.cardIDEnum.GVG_056t;
            if (s == "GVG_057") return CardDB.cardIDEnum.GVG_057;
            if (s == "GVG_057a") return CardDB.cardIDEnum.GVG_057a;
            if (s == "GVG_058") return CardDB.cardIDEnum.GVG_058;
            if (s == "GVG_059") return CardDB.cardIDEnum.GVG_059;
            if (s == "GVG_060") return CardDB.cardIDEnum.GVG_060;
            if (s == "GVG_060e") return CardDB.cardIDEnum.GVG_060e;
            if (s == "GVG_061") return CardDB.cardIDEnum.GVG_061;
            if (s == "GVG_062") return CardDB.cardIDEnum.GVG_062;
            if (s == "GVG_063") return CardDB.cardIDEnum.GVG_063;
            if (s == "GVG_063a") return CardDB.cardIDEnum.GVG_063a;
            if (s == "GVG_064") return CardDB.cardIDEnum.GVG_064;
            if (s == "GVG_065") return CardDB.cardIDEnum.GVG_065;
            if (s == "GVG_066") return CardDB.cardIDEnum.GVG_066;
            if (s == "GVG_067") return CardDB.cardIDEnum.GVG_067;
            if (s == "GVG_067a") return CardDB.cardIDEnum.GVG_067a;
            if (s == "GVG_068") return CardDB.cardIDEnum.GVG_068;
            if (s == "GVG_068a") return CardDB.cardIDEnum.GVG_068a;
            if (s == "GVG_069") return CardDB.cardIDEnum.GVG_069;
            if (s == "GVG_069a") return CardDB.cardIDEnum.GVG_069a;
            if (s == "GVG_070") return CardDB.cardIDEnum.GVG_070;
            if (s == "GVG_071") return CardDB.cardIDEnum.GVG_071;
            if (s == "GVG_072") return CardDB.cardIDEnum.GVG_072;
            if (s == "GVG_073") return CardDB.cardIDEnum.GVG_073;
            if (s == "GVG_074") return CardDB.cardIDEnum.GVG_074;
            if (s == "GVG_075") return CardDB.cardIDEnum.GVG_075;
            if (s == "GVG_076") return CardDB.cardIDEnum.GVG_076;
            if (s == "GVG_076a") return CardDB.cardIDEnum.GVG_076a;
            if (s == "GVG_077") return CardDB.cardIDEnum.GVG_077;
            if (s == "GVG_078") return CardDB.cardIDEnum.GVG_078;
            if (s == "GVG_079") return CardDB.cardIDEnum.GVG_079;
            if (s == "GVG_080") return CardDB.cardIDEnum.GVG_080;
            if (s == "GVG_080t") return CardDB.cardIDEnum.GVG_080t;
            if (s == "GVG_081") return CardDB.cardIDEnum.GVG_081;
            if (s == "GVG_082") return CardDB.cardIDEnum.GVG_082;
            if (s == "GVG_083") return CardDB.cardIDEnum.GVG_083;
            if (s == "GVG_084") return CardDB.cardIDEnum.GVG_084;
            if (s == "GVG_085") return CardDB.cardIDEnum.GVG_085;
            if (s == "GVG_086") return CardDB.cardIDEnum.GVG_086;
            if (s == "GVG_086e") return CardDB.cardIDEnum.GVG_086e;
            if (s == "GVG_087") return CardDB.cardIDEnum.GVG_087;
            if (s == "GVG_088") return CardDB.cardIDEnum.GVG_088;
            if (s == "GVG_089") return CardDB.cardIDEnum.GVG_089;
            if (s == "GVG_090") return CardDB.cardIDEnum.GVG_090;
            if (s == "GVG_091") return CardDB.cardIDEnum.GVG_091;
            if (s == "GVG_092") return CardDB.cardIDEnum.GVG_092;
            if (s == "GVG_092t") return CardDB.cardIDEnum.GVG_092t;
            if (s == "GVG_093") return CardDB.cardIDEnum.GVG_093;
            if (s == "GVG_094") return CardDB.cardIDEnum.GVG_094;
            if (s == "GVG_095") return CardDB.cardIDEnum.GVG_095;
            if (s == "GVG_096") return CardDB.cardIDEnum.GVG_096;
            if (s == "GVG_097") return CardDB.cardIDEnum.GVG_097;
            if (s == "GVG_098") return CardDB.cardIDEnum.GVG_098;
            if (s == "GVG_099") return CardDB.cardIDEnum.GVG_099;
            if (s == "GVG_100") return CardDB.cardIDEnum.GVG_100;
            if (s == "GVG_100e") return CardDB.cardIDEnum.GVG_100e;
            if (s == "GVG_101") return CardDB.cardIDEnum.GVG_101;
            if (s == "GVG_101e") return CardDB.cardIDEnum.GVG_101e;
            if (s == "GVG_102") return CardDB.cardIDEnum.GVG_102;
            if (s == "GVG_102e") return CardDB.cardIDEnum.GVG_102e;
            if (s == "GVG_103") return CardDB.cardIDEnum.GVG_103;
            if (s == "GVG_104") return CardDB.cardIDEnum.GVG_104;
            if (s == "GVG_104a") return CardDB.cardIDEnum.GVG_104a;
            if (s == "GVG_105") return CardDB.cardIDEnum.GVG_105;
            if (s == "GVG_106") return CardDB.cardIDEnum.GVG_106;
            if (s == "GVG_106e") return CardDB.cardIDEnum.GVG_106e;
            if (s == "GVG_107") return CardDB.cardIDEnum.GVG_107;
            if (s == "GVG_108") return CardDB.cardIDEnum.GVG_108;
            if (s == "GVG_109") return CardDB.cardIDEnum.GVG_109;
            if (s == "GVG_110") return CardDB.cardIDEnum.GVG_110;
            if (s == "GVG_110t") return CardDB.cardIDEnum.GVG_110t;
            if (s == "GVG_111") return CardDB.cardIDEnum.GVG_111;
            if (s == "GVG_111t") return CardDB.cardIDEnum.GVG_111t;
            if (s == "GVG_112") return CardDB.cardIDEnum.GVG_112;
            if (s == "GVG_113") return CardDB.cardIDEnum.GVG_113;
            if (s == "GVG_114") return CardDB.cardIDEnum.GVG_114;
            if (s == "GVG_115") return CardDB.cardIDEnum.GVG_115;
            if (s == "GVG_116") return CardDB.cardIDEnum.GVG_116;
            if (s == "GVG_117") return CardDB.cardIDEnum.GVG_117;
            if (s == "GVG_118") return CardDB.cardIDEnum.GVG_118;
            if (s == "GVG_119") return CardDB.cardIDEnum.GVG_119;
            if (s == "GVG_120") return CardDB.cardIDEnum.GVG_120;
            if (s == "GVG_121") return CardDB.cardIDEnum.GVG_121;
            if (s == "GVG_122") return CardDB.cardIDEnum.GVG_122;
            if (s == "GVG_123") return CardDB.cardIDEnum.GVG_123;
            if (s == "GVG_123e") return CardDB.cardIDEnum.GVG_123e;
            if (s == "PART_001") return CardDB.cardIDEnum.PART_001;
            if (s == "PART_001e") return CardDB.cardIDEnum.PART_001e;
            if (s == "PART_002") return CardDB.cardIDEnum.PART_002;
            if (s == "PART_003") return CardDB.cardIDEnum.PART_003;
            if (s == "PART_004") return CardDB.cardIDEnum.PART_004;
            if (s == "PART_004e") return CardDB.cardIDEnum.PART_004e;
            if (s == "PART_005") return CardDB.cardIDEnum.PART_005;
            if (s == "PART_006") return CardDB.cardIDEnum.PART_006;
            if (s == "PART_006a") return CardDB.cardIDEnum.PART_006a;
            if (s == "PART_007") return CardDB.cardIDEnum.PART_007;
            if (s == "PART_007e") return CardDB.cardIDEnum.PART_007e;
            if (s == "PlaceholderCard") return CardDB.cardIDEnum.PlaceholderCard;
            return CardDB.cardIDEnum.None;
        }

        public enum cardName
        {
            unknown,
            lesserheal,
            goldshirefootman,
            holynova,
            mindcontrol,
            holysmite,
            mindvision,
            powerwordshield,
            claw,
            healingtouch,
            moonfire,
            markofthewild,
            savageroar,
            swipe,
            wildgrowth,
            excessmana,
            shapeshift,
            polymorph,
            arcaneintellect,
            frostbolt,
            arcaneexplosion,
            frostnova,
            mirrorimage,
            fireball,
            flamestrike,
            waterelemental,
            fireblast,
            frostshock,
            windfury,
            ancestralhealing,
            fireelemental,
            rockbiterweapon,
            bloodlust,
            totemiccall,
            searingtotem,
            stoneclawtotem,
            wrathofairtotem,
            lifetap,
            shadowbolt,
            drainlife,
            hellfire,
            corruption,
            dreadinfernal,
            voidwalker,
            backstab,
            deadlypoison,
            sinisterstrike,
            assassinate,
            sprint,
            assassinsblade,
            wickedknife,
            daggermastery,
            huntersmark,
            blessingofmight,
            guardianofkings,
            holylight,
            lightsjustice,
            blessingofkings,
            consecration,
            hammerofwrath,
            truesilverchampion,
            reinforce,
            silverhandrecruit,
            armorup,
            charge,
            heroicstrike,
            fierywaraxe,
            execute,
            arcanitereaper,
            cleave,
            magmarager,
            oasissnapjaw,
            rivercrocolisk,
            frostwolfgrunt,
            raidleader,
            wolfrider,
            ironfurgrizzly,
            silverbackpatriarch,
            stormwindknight,
            ironforgerifleman,
            koboldgeomancer,
            gnomishinventor,
            stormpikecommando,
            archmage,
            lordofthearena,
            murlocraider,
            stonetuskboar,
            bloodfenraptor,
            bluegillwarrior,
            senjinshieldmasta,
            chillwindyeti,
            wargolem,
            bootybaybodyguard,
            elvenarcher,
            razorfenhunter,
            ogremagi,
            boulderfistogre,
            corehound,
            recklessrocketeer,
            stormwindchampion,
            frostwolfwarlord,
            ironbarkprotector,
            shadowwordpain,
            northshirecleric,
            divinespirit,
            starvingbuzzard,
            boar,
            sheep,
            steadyshot,
            darkscalehealer,
            houndmaster,
            timberwolf,
            tundrarhino,
            multishot,
            tracking,
            arcaneshot,
            mindblast,
            voodoodoctor,
            noviceengineer,
            shatteredsuncleric,
            dragonlingmechanic,
            mechanicaldragonling,
            acidicswampooze,
            warsongcommander,
            fanofknives,
            innervate,
            starfire,
            totemicmight,
            hex,
            arcanemissiles,
            shiv,
            mortalcoil,
            succubus,
            soulfire,
            humility,
            handofprotection,
            gurubashiberserker,
            whirlwind,
            murloctidehunter,
            murlocscout,
            grimscaleoracle,
            killcommand,
            flametonguetotem,
            sap,
            dalaranmage,
            windspeaker,
            nightblade,
            shieldblock,
            shadowworddeath,
            avatarofthecoin,
            thecoin,
            noooooooooooo,
            garroshhellscream,
            thrall,
            valeerasanguinar,
            utherlightbringer,
            rexxar,
            malfurionstormrage,
            guldan,
            jainaproudmoore,
            anduinwrynn,
            frog,
            sacrificialpact,
            vanish,
            healingtotem,
            korkronelite,
            animalcompanion,
            misha,
            leokk,
            huffer,
            skeleton,
            fencreeper,
            innerfire,
            blizzard,
            icelance,
            ancestralspirit,
            farsight,
            bloodimp,
            coldblood,
            rampage,
            earthenringfarseer,
            southseadeckhand,
            silverhandknight,
            squire,
            ravenholdtassassin,
            youngdragonhawk,
            injuredblademaster,
            abusivesergeant,
            ironbeakowl,
            spitefulsmith,
            venturecomercenary,
            wisp,
            bladeflurry,
            laughingsister,
            yseraawakens,
            emeralddrake,
            dream,
            nightmare,
            gladiatorslongbow,
            whelp,
            lightwarden,
            theblackknight,
            youngpriestess,
            biggamehunter,
            alarmobot,
            acolyteofpain,
            argentsquire,
            angrychicken,
            worgeninfiltrator,
            bloodmagethalnos,
            kingmukla,
            bananas,
            sylvanaswindrunner,
            junglepanther,
            scarletcrusader,
            thrallmarfarseer,
            silvermoonguardian,
            stranglethorntiger,
            lepergnome,
            sunwalker,
            windfuryharpy,
            twilightdrake,
            questingadventurer,
            ancientwatcher,
            darkirondwarf,
            spellbreaker,
            youthfulbrewmaster,
            coldlightoracle,
            manaaddict,
            ancientbrewmaster,
            sunfuryprotector,
            crazedalchemist,
            argentcommander,
            pintsizedsummoner,
            secretkeeper,
            madbomber,
            tinkmasteroverspark,
            mindcontroltech,
            arcanegolem,
            cabalshadowpriest,
            defenderofargus,
            gadgetzanauctioneer,
            loothoarder,
            abomination,
            lorewalkercho,
            demolisher,
            coldlightseer,
            mountaingiant,
            cairnebloodhoof,
            bainebloodhoof,
            leeroyjenkins,
            eviscerate,
            betrayal,
            conceal,
            noblesacrifice,
            defender,
            defiasringleader,
            defiasbandit,
            eyeforaneye,
            perditionsblade,
            si7agent,
            redemption,
            headcrack,
            shadowstep,
            preparation,
            wrath,
            markofnature,
            souloftheforest,
            treant,
            powerofthewild,
            summonapanther,
            leaderofthepack,
            panther,
            naturalize,
            direwolfalpha,
            nourish,
            druidoftheclaw,
            catform,
            bearform,
            keeperofthegrove,
            dispel,
            emperorcobra,
            ancientofwar,
            rooted,
            uproot,
            lightningbolt,
            lavaburst,
            dustdevil,
            earthshock,
            stormforgedaxe,
            feralspirit,
            barongeddon,
            earthelemental,
            forkedlightning,
            unboundelemental,
            lightningstorm,
            etherealarcanist,
            coneofcold,
            pyroblast,
            frostelemental,
            azuredrake,
            counterspell,
            icebarrier,
            mirrorentity,
            iceblock,
            ragnarosthefirelord,
            felguard,
            shadowflame,
            voidterror,
            siphonsoul,
            doomguard,
            twistingnether,
            pitlord,
            summoningportal,
            poweroverwhelming,
            sensedemons,
            worthlessimp,
            flameimp,
            baneofdoom,
            lordjaraxxus,
            bloodfury,
            silence,
            shadowmadness,
            lightspawn,
            thoughtsteal,
            lightwell,
            mindgames,
            shadowofnothing,
            divinefavor,
            prophetvelen,
            layonhands,
            blessedchampion,
            argentprotector,
            blessingofwisdom,
            holywrath,
            swordofjustice,
            repentance,
            aldorpeacekeeper,
            tirionfordring,
            ashbringer,
            avengingwrath,
            taurenwarrior,
            slam,
            battlerage,
            amaniberserker,
            mogushanwarden,
            arathiweaponsmith,
            battleaxe,
            armorsmith,
            shieldbearer,
            brawl,
            mortalstrike,
            upgrade,
            heavyaxe,
            shieldslam,
            gorehowl,
            ragingworgen,
            grommashhellscream,
            murlocwarleader,
            murloctidecaller,
            patientassassin,
            scavenginghyena,
            misdirection,
            savannahhighmane,
            hyena,
            eaglehornbow,
            explosiveshot,
            unleashthehounds,
            hound,
            kingkrush,
            flare,
            bestialwrath,
            snaketrap,
            snake,
            harvestgolem,
            natpagle,
            harrisonjones,
            archmageantonidas,
            nozdormu,
            alexstrasza,
            onyxia,
            malygos,
            facelessmanipulator,
            doomhammer,
            bite,
            forceofnature,
            ysera,
            cenarius,
            demigodsfavor,
            shandoslesson,
            manatidetotem,
            thebeast,
            savagery,
            priestessofelune,
            ancientmage,
            seagiant,
            bloodknight,
            auchenaisoulpriest,
            vaporize,
            cultmaster,
            demonfire,
            impmaster,
            imp,
            crueltaskmaster,
            frothingberserker,
            innerrage,
            sorcerersapprentice,
            snipe,
            explosivetrap,
            freezingtrap,
            kirintormage,
            edwinvancleef,
            illidanstormrage,
            flameofazzinoth,
            manawraith,
            deadlyshot,
            equality,
            moltengiant,
            circleofhealing,
            templeenforcer,
            holyfire,
            shadowform,
            mindspike,
            mindshatter,
            massdispel,
            finkleeinhorn,
            spiritwolf,
            squirrel,
            devilsaur,
            inferno,
            infernal,
            kidnapper,
            starfall,
            ancientoflore,
            ancientteachings,
            ancientsecrets,
            alakirthewindlord,
            manawyrm,
            masterofdisguise,
            hungrycrab,
            bloodsailraider,
            knifejuggler,
            wildpyromancer,
            doomsayer,
            dreadcorsair,
            faeriedragon,
            captaingreenskin,
            bloodsailcorsair,
            violetteacher,
            violetapprentice,
            southseacaptain,
            millhousemanastorm,
            deathwing,
            commandingshout,
            masterswordsmith,
            gruul,
            hogger,
            gnoll,
            stampedingkodo,
            damagedgolem,
            flesheatingghoul,
            spellbender,
            jasonchayes,
            ericdodds,
            bobfitch,
            stevengabriel,
            kyleharrison,
            dereksakamoto,
            zwick,
            benbrode,
            benthompson,
            michaelschweitzer,
            jaybaxter,
            rachelledavis,
            brianschwab,
            yongwoo,
            andybrock,
            hamiltonchu,
            robpardo,
            oldmurkeye,
            captainsparrot,
            riverpawgnoll,
            hoggersmash,
            massivegnoll,
            barreltoss,
            barrel,
            stomp,
            hiddengnome,
            muklasbigbrother,
            willofmukla,
            hemetnesingwary,
            crazedhunter,
            shotgunblast,
            flamesofazzinoth,
            nagamyrmidon,
            warglaiveofazzinoth,
            flameburst,
            dualwarglaives,
            pandarenscout,
            shadopanmonk,
            legacyoftheemperor,
            brewmaster,
            transcendence,
            crazymonkey,
            damage1,
            damage5,
            restore1,
            restore5,
            destroy,
            breakweapon,
            enableforattack,
            freeze,
            enchant,
            silencedebug,
            summonarandomsecret,
            bounce,
            discard,
            mill10,
            crash,
            snakeball,
            draw3cards,
            destroyallminions,
            molasses,
            damageallbut1,
            restoreallhealth,
            freecards,
            destroyallheroes,
            damagereflector,
            donothing,
            enableemotes,
            servercrash,
            revealhand,
            opponentconcede,
            opponentdisconnect,
            becomehogger,
            destroyheropower,
            handtodeck,
            mill30,
            handswapperminion,
            stealcard,
            forceaitouseheropower,
            destroydeck,
            durability,
            destroyallmana,
            destroyamanacrystal,
            makeimmune,
            grantmegawindfury,
            armor,
            weaponbuff,
            stats,
            silencedestroy,
            destroysecrets,
            aibuddyallcharge,
            aibuddydamageownhero5,
            aibuddydestroyminions,
            aibuddynodeckhand,
            aihelperbuddy,
            gelbinmekkatorque,
            homingchicken,
            repairbot,
            emboldener3000,
            poultryizer,
            chicken,
            elitetaurenchieftain,
            iammurloc,
            murloc,
            roguesdoit,
            powerofthehorde,
            zombiechow,
            hauntedcreeper,
            spectralspider,
            echoingooze,
            madscientist,
            shadeofnaxxramas,
            deathcharger,
            nerubianegg,
            nerubian,
            spectralknight,
            deathlord,
            maexxna,
            webspinner,
            sludgebelcher,
            slime,
            kelthuzad,
            stalagg,
            thaddius,
            feugen,
            wailingsoul,
            nerubarweblord,
            duplicate,
            poisonseeds,
            avenge,
            deathsbite,
            voidcaller,
            darkcultist,
            unstableghoul,
            reincarnate,
            anubarambusher,
            stoneskingargoyle,
            undertaker,
            dancingswords,
            loatheb,
            baronrivendare,
            patchwerk,
            hook,
            hatefulstrike,
            grobbulus,
            poisoncloud,
            falloutslime,
            mutatinginjection,
            gluth,
            decimate,
            jaws,
            enrage,
            polarityshift,
            supercharge,
            sapphiron,
            frostbreath,
            frozenchampion,
            purecold,
            frostblast,
            guardianoficecrown,
            chains,
            mrbigglesworth,
            anubrekhan,
            skitter,
            locustswarm,
            grandwidowfaerlina,
            rainoffire,
            worshipper,
            webwrap,
            necroticpoison,
            noththeplaguebringer,
            raisedead,
            plague,
            heigantheunclean,
            eruption,
            mindpocalypse,
            necroticaura,
            deathbloom,
            spore,
            sporeburst,
            instructorrazuvious,
            understudy,
            unbalancingstrike,
            massiveruneblade,
            mindcontrolcrystal,
            gothiktheharvester,
            harvest,
            unrelentingtrainee,
            spectraltrainee,
            unrelentingwarrior,
            spectralwarrior,
            unrelentingrider,
            spectralrider,
            ladyblaumeux,
            thanekorthazz,
            sirzeliek,
            runeblade,
            unholyshadow,
            markofthehorsemen,
            necroknight,
            skeletalsmith,
            flamecannon,
            snowchugger,
            unstableportal,
            goblinblastmage,
            echoofmedivh,
            mechwarper,
            flameleviathan,
            lightbomb,
            shadowbomber,
            velenschosen,
            shrinkmeister,
            lightofthenaaru,
            cogmaster,
            voljin,
            darkbomb,
            felreaver,
            callpet,
            mistressofpain,
            demonheart,
            felcannon,
            malganis,
            tinkerssharpswordoil,
            goblinautobarber,
            cogmasterswrench,
            oneeyedcheat,
            feigndeath,
            ironsensei,
            tradeprincegallywix,
            gallywixscoin,
            ancestorscall,
            anodizedrobocub,
            attackmode,
            tankmode,
            recycle,
            grovetender,
            giftofmana,
            giftofcards,
            treeoflife,
            mechbearcat,
            malorne,
            powermace,
            whirlingzapomatic,
            crackle,
            vitalitytotem,
            siltfinspiritwalker,
            darkwispers,
            neptulon,
            glaivezooka,
            spidertank,
            implosion,
            kingofbeasts,
            sabotage,
            metaltoothleaper,
            gahzrilla,
            bouncingblade,
            warbot,
            crush,
            shieldmaiden,
            ogrewarmaul,
            screwjankclunker,
            ironjuggernaut,
            burrowingmine,
            sealoflight,
            shieldedminibot,
            coghammer,
            quartermaster,
            musterforbattle,
            cobaltguardian,
            bolvarfordragon,
            puddlestomper,
            ogrebrute,
            dunemaulshaman,
            stonesplintertrogg,
            burlyrockjawtrogg,
            antiquehealbot,
            saltydog,
            losttallstrider,
            shadowboxer,
            cobrashot,
            kezanmystic,
            shipscannon,
            explosivesheep,
            animagolem,
            mechanicalyeti,
            forcetankmax,
            druidofthefang,
            gilblinstalker,
            clockworkgnome,
            upgradedrepairbot,
            flyingmachine,
            annoyotron,
            siegeengine,
            steamwheedlesniper,
            ogreninja,
            illuminator,
            madderbomber,
            arcanenullifierx21,
            gnomishexperimenter,
            targetdummy,
            jeeves,
            goblinsapper,
            pilotedshredder,
            lilexorcist,
            gnomereganinfantry,
            bomblobber,
            floatingwatcher,
            scarletpurifier,
            tinkertowntechnician,
            micromachine,
            hobgoblin,
            pilotedskygolem,
            junkbot,
            enhanceomechano,
            recombobulator,
            minimage,
            drboom,
            boombot,
            mimironshead,
            v07tr0n,
            mogortheogre,
            foereaper4000,
            sneedsoldshredder,
            toshley,
            mekgineerthermaplugg,
            gazlowe,
            troggzortheearthinator,
            blingtron3000,
            clockworkgiant,
            weespellstopper,
            sootspewer,
            armorplating,
            timerewinder,
            rustyhorn,
            finickycloakfield,
            emergencycoolant,
            reversingswitch,
            whirlingblades,
            placeholdercard,
        }

        public cardName cardNamestringToEnum(string s)
        {
            if (s == "unknown") return CardDB.cardName.unknown;
            if (s == "lesserheal") return CardDB.cardName.lesserheal;
            if (s == "goldshirefootman") return CardDB.cardName.goldshirefootman;
            if (s == "holynova") return CardDB.cardName.holynova;
            if (s == "mindcontrol") return CardDB.cardName.mindcontrol;
            if (s == "holysmite") return CardDB.cardName.holysmite;
            if (s == "mindvision") return CardDB.cardName.mindvision;
            if (s == "powerwordshield") return CardDB.cardName.powerwordshield;
            if (s == "claw") return CardDB.cardName.claw;
            if (s == "healingtouch") return CardDB.cardName.healingtouch;
            if (s == "moonfire") return CardDB.cardName.moonfire;
            if (s == "markofthewild") return CardDB.cardName.markofthewild;
            if (s == "savageroar") return CardDB.cardName.savageroar;
            if (s == "swipe") return CardDB.cardName.swipe;
            if (s == "wildgrowth") return CardDB.cardName.wildgrowth;
            if (s == "excessmana") return CardDB.cardName.excessmana;
            if (s == "shapeshift") return CardDB.cardName.shapeshift;
            if (s == "polymorph") return CardDB.cardName.polymorph;
            if (s == "arcaneintellect") return CardDB.cardName.arcaneintellect;
            if (s == "frostbolt") return CardDB.cardName.frostbolt;
            if (s == "arcaneexplosion") return CardDB.cardName.arcaneexplosion;
            if (s == "frostnova") return CardDB.cardName.frostnova;
            if (s == "mirrorimage") return CardDB.cardName.mirrorimage;
            if (s == "fireball") return CardDB.cardName.fireball;
            if (s == "flamestrike") return CardDB.cardName.flamestrike;
            if (s == "waterelemental") return CardDB.cardName.waterelemental;
            if (s == "fireblast") return CardDB.cardName.fireblast;
            if (s == "frostshock") return CardDB.cardName.frostshock;
            if (s == "windfury") return CardDB.cardName.windfury;
            if (s == "ancestralhealing") return CardDB.cardName.ancestralhealing;
            if (s == "fireelemental") return CardDB.cardName.fireelemental;
            if (s == "rockbiterweapon") return CardDB.cardName.rockbiterweapon;
            if (s == "bloodlust") return CardDB.cardName.bloodlust;
            if (s == "totemiccall") return CardDB.cardName.totemiccall;
            if (s == "searingtotem") return CardDB.cardName.searingtotem;
            if (s == "stoneclawtotem") return CardDB.cardName.stoneclawtotem;
            if (s == "wrathofairtotem") return CardDB.cardName.wrathofairtotem;
            if (s == "lifetap") return CardDB.cardName.lifetap;
            if (s == "shadowbolt") return CardDB.cardName.shadowbolt;
            if (s == "drainlife") return CardDB.cardName.drainlife;
            if (s == "hellfire") return CardDB.cardName.hellfire;
            if (s == "corruption") return CardDB.cardName.corruption;
            if (s == "dreadinfernal") return CardDB.cardName.dreadinfernal;
            if (s == "voidwalker") return CardDB.cardName.voidwalker;
            if (s == "backstab") return CardDB.cardName.backstab;
            if (s == "deadlypoison") return CardDB.cardName.deadlypoison;
            if (s == "sinisterstrike") return CardDB.cardName.sinisterstrike;
            if (s == "assassinate") return CardDB.cardName.assassinate;
            if (s == "sprint") return CardDB.cardName.sprint;
            if (s == "assassinsblade") return CardDB.cardName.assassinsblade;
            if (s == "wickedknife") return CardDB.cardName.wickedknife;
            if (s == "daggermastery") return CardDB.cardName.daggermastery;
            if (s == "huntersmark") return CardDB.cardName.huntersmark;
            if (s == "blessingofmight") return CardDB.cardName.blessingofmight;
            if (s == "guardianofkings") return CardDB.cardName.guardianofkings;
            if (s == "holylight") return CardDB.cardName.holylight;
            if (s == "lightsjustice") return CardDB.cardName.lightsjustice;
            if (s == "blessingofkings") return CardDB.cardName.blessingofkings;
            if (s == "consecration") return CardDB.cardName.consecration;
            if (s == "hammerofwrath") return CardDB.cardName.hammerofwrath;
            if (s == "truesilverchampion") return CardDB.cardName.truesilverchampion;
            if (s == "reinforce") return CardDB.cardName.reinforce;
            if (s == "silverhandrecruit") return CardDB.cardName.silverhandrecruit;
            if (s == "armorup") return CardDB.cardName.armorup;
            if (s == "charge") return CardDB.cardName.charge;
            if (s == "heroicstrike") return CardDB.cardName.heroicstrike;
            if (s == "fierywaraxe") return CardDB.cardName.fierywaraxe;
            if (s == "execute") return CardDB.cardName.execute;
            if (s == "arcanitereaper") return CardDB.cardName.arcanitereaper;
            if (s == "cleave") return CardDB.cardName.cleave;
            if (s == "magmarager") return CardDB.cardName.magmarager;
            if (s == "oasissnapjaw") return CardDB.cardName.oasissnapjaw;
            if (s == "rivercrocolisk") return CardDB.cardName.rivercrocolisk;
            if (s == "frostwolfgrunt") return CardDB.cardName.frostwolfgrunt;
            if (s == "raidleader") return CardDB.cardName.raidleader;
            if (s == "wolfrider") return CardDB.cardName.wolfrider;
            if (s == "ironfurgrizzly") return CardDB.cardName.ironfurgrizzly;
            if (s == "silverbackpatriarch") return CardDB.cardName.silverbackpatriarch;
            if (s == "stormwindknight") return CardDB.cardName.stormwindknight;
            if (s == "ironforgerifleman") return CardDB.cardName.ironforgerifleman;
            if (s == "koboldgeomancer") return CardDB.cardName.koboldgeomancer;
            if (s == "gnomishinventor") return CardDB.cardName.gnomishinventor;
            if (s == "stormpikecommando") return CardDB.cardName.stormpikecommando;
            if (s == "archmage") return CardDB.cardName.archmage;
            if (s == "lordofthearena") return CardDB.cardName.lordofthearena;
            if (s == "murlocraider") return CardDB.cardName.murlocraider;
            if (s == "stonetuskboar") return CardDB.cardName.stonetuskboar;
            if (s == "bloodfenraptor") return CardDB.cardName.bloodfenraptor;
            if (s == "bluegillwarrior") return CardDB.cardName.bluegillwarrior;
            if (s == "senjinshieldmasta") return CardDB.cardName.senjinshieldmasta;
            if (s == "chillwindyeti") return CardDB.cardName.chillwindyeti;
            if (s == "wargolem") return CardDB.cardName.wargolem;
            if (s == "bootybaybodyguard") return CardDB.cardName.bootybaybodyguard;
            if (s == "elvenarcher") return CardDB.cardName.elvenarcher;
            if (s == "razorfenhunter") return CardDB.cardName.razorfenhunter;
            if (s == "ogremagi") return CardDB.cardName.ogremagi;
            if (s == "boulderfistogre") return CardDB.cardName.boulderfistogre;
            if (s == "corehound") return CardDB.cardName.corehound;
            if (s == "recklessrocketeer") return CardDB.cardName.recklessrocketeer;
            if (s == "stormwindchampion") return CardDB.cardName.stormwindchampion;
            if (s == "frostwolfwarlord") return CardDB.cardName.frostwolfwarlord;
            if (s == "ironbarkprotector") return CardDB.cardName.ironbarkprotector;
            if (s == "shadowwordpain") return CardDB.cardName.shadowwordpain;
            if (s == "northshirecleric") return CardDB.cardName.northshirecleric;
            if (s == "divinespirit") return CardDB.cardName.divinespirit;
            if (s == "starvingbuzzard") return CardDB.cardName.starvingbuzzard;
            if (s == "boar") return CardDB.cardName.boar;
            if (s == "sheep") return CardDB.cardName.sheep;
            if (s == "steadyshot") return CardDB.cardName.steadyshot;
            if (s == "darkscalehealer") return CardDB.cardName.darkscalehealer;
            if (s == "houndmaster") return CardDB.cardName.houndmaster;
            if (s == "timberwolf") return CardDB.cardName.timberwolf;
            if (s == "tundrarhino") return CardDB.cardName.tundrarhino;
            if (s == "multishot") return CardDB.cardName.multishot;
            if (s == "tracking") return CardDB.cardName.tracking;
            if (s == "arcaneshot") return CardDB.cardName.arcaneshot;
            if (s == "mindblast") return CardDB.cardName.mindblast;
            if (s == "voodoodoctor") return CardDB.cardName.voodoodoctor;
            if (s == "noviceengineer") return CardDB.cardName.noviceengineer;
            if (s == "shatteredsuncleric") return CardDB.cardName.shatteredsuncleric;
            if (s == "dragonlingmechanic") return CardDB.cardName.dragonlingmechanic;
            if (s == "mechanicaldragonling") return CardDB.cardName.mechanicaldragonling;
            if (s == "acidicswampooze") return CardDB.cardName.acidicswampooze;
            if (s == "warsongcommander") return CardDB.cardName.warsongcommander;
            if (s == "fanofknives") return CardDB.cardName.fanofknives;
            if (s == "innervate") return CardDB.cardName.innervate;
            if (s == "starfire") return CardDB.cardName.starfire;
            if (s == "totemicmight") return CardDB.cardName.totemicmight;
            if (s == "hex") return CardDB.cardName.hex;
            if (s == "arcanemissiles") return CardDB.cardName.arcanemissiles;
            if (s == "shiv") return CardDB.cardName.shiv;
            if (s == "mortalcoil") return CardDB.cardName.mortalcoil;
            if (s == "succubus") return CardDB.cardName.succubus;
            if (s == "soulfire") return CardDB.cardName.soulfire;
            if (s == "humility") return CardDB.cardName.humility;
            if (s == "handofprotection") return CardDB.cardName.handofprotection;
            if (s == "gurubashiberserker") return CardDB.cardName.gurubashiberserker;
            if (s == "whirlwind") return CardDB.cardName.whirlwind;
            if (s == "murloctidehunter") return CardDB.cardName.murloctidehunter;
            if (s == "murlocscout") return CardDB.cardName.murlocscout;
            if (s == "grimscaleoracle") return CardDB.cardName.grimscaleoracle;
            if (s == "killcommand") return CardDB.cardName.killcommand;
            if (s == "flametonguetotem") return CardDB.cardName.flametonguetotem;
            if (s == "sap") return CardDB.cardName.sap;
            if (s == "dalaranmage") return CardDB.cardName.dalaranmage;
            if (s == "windspeaker") return CardDB.cardName.windspeaker;
            if (s == "nightblade") return CardDB.cardName.nightblade;
            if (s == "shieldblock") return CardDB.cardName.shieldblock;
            if (s == "shadowworddeath") return CardDB.cardName.shadowworddeath;
            if (s == "avatarofthecoin") return CardDB.cardName.avatarofthecoin;
            if (s == "thecoin") return CardDB.cardName.thecoin;
            if (s == "noooooooooooo") return CardDB.cardName.noooooooooooo;
            if (s == "garroshhellscream") return CardDB.cardName.garroshhellscream;
            if (s == "thrall") return CardDB.cardName.thrall;
            if (s == "valeerasanguinar") return CardDB.cardName.valeerasanguinar;
            if (s == "utherlightbringer") return CardDB.cardName.utherlightbringer;
            if (s == "rexxar") return CardDB.cardName.rexxar;
            if (s == "malfurionstormrage") return CardDB.cardName.malfurionstormrage;
            if (s == "guldan") return CardDB.cardName.guldan;
            if (s == "jainaproudmoore") return CardDB.cardName.jainaproudmoore;
            if (s == "anduinwrynn") return CardDB.cardName.anduinwrynn;
            if (s == "frog") return CardDB.cardName.frog;
            if (s == "sacrificialpact") return CardDB.cardName.sacrificialpact;
            if (s == "vanish") return CardDB.cardName.vanish;
            if (s == "healingtotem") return CardDB.cardName.healingtotem;
            if (s == "korkronelite") return CardDB.cardName.korkronelite;
            if (s == "animalcompanion") return CardDB.cardName.animalcompanion;
            if (s == "misha") return CardDB.cardName.misha;
            if (s == "leokk") return CardDB.cardName.leokk;
            if (s == "huffer") return CardDB.cardName.huffer;
            if (s == "skeleton") return CardDB.cardName.skeleton;
            if (s == "fencreeper") return CardDB.cardName.fencreeper;
            if (s == "innerfire") return CardDB.cardName.innerfire;
            if (s == "blizzard") return CardDB.cardName.blizzard;
            if (s == "icelance") return CardDB.cardName.icelance;
            if (s == "ancestralspirit") return CardDB.cardName.ancestralspirit;
            if (s == "farsight") return CardDB.cardName.farsight;
            if (s == "bloodimp") return CardDB.cardName.bloodimp;
            if (s == "coldblood") return CardDB.cardName.coldblood;
            if (s == "rampage") return CardDB.cardName.rampage;
            if (s == "earthenringfarseer") return CardDB.cardName.earthenringfarseer;
            if (s == "southseadeckhand") return CardDB.cardName.southseadeckhand;
            if (s == "silverhandknight") return CardDB.cardName.silverhandknight;
            if (s == "squire") return CardDB.cardName.squire;
            if (s == "ravenholdtassassin") return CardDB.cardName.ravenholdtassassin;
            if (s == "youngdragonhawk") return CardDB.cardName.youngdragonhawk;
            if (s == "injuredblademaster") return CardDB.cardName.injuredblademaster;
            if (s == "abusivesergeant") return CardDB.cardName.abusivesergeant;
            if (s == "ironbeakowl") return CardDB.cardName.ironbeakowl;
            if (s == "spitefulsmith") return CardDB.cardName.spitefulsmith;
            if (s == "venturecomercenary") return CardDB.cardName.venturecomercenary;
            if (s == "wisp") return CardDB.cardName.wisp;
            if (s == "bladeflurry") return CardDB.cardName.bladeflurry;
            if (s == "laughingsister") return CardDB.cardName.laughingsister;
            if (s == "yseraawakens") return CardDB.cardName.yseraawakens;
            if (s == "emeralddrake") return CardDB.cardName.emeralddrake;
            if (s == "dream") return CardDB.cardName.dream;
            if (s == "nightmare") return CardDB.cardName.nightmare;
            if (s == "gladiatorslongbow") return CardDB.cardName.gladiatorslongbow;
            if (s == "whelp") return CardDB.cardName.whelp;
            if (s == "lightwarden") return CardDB.cardName.lightwarden;
            if (s == "theblackknight") return CardDB.cardName.theblackknight;
            if (s == "youngpriestess") return CardDB.cardName.youngpriestess;
            if (s == "biggamehunter") return CardDB.cardName.biggamehunter;
            if (s == "alarmobot") return CardDB.cardName.alarmobot;
            if (s == "acolyteofpain") return CardDB.cardName.acolyteofpain;
            if (s == "argentsquire") return CardDB.cardName.argentsquire;
            if (s == "angrychicken") return CardDB.cardName.angrychicken;
            if (s == "worgeninfiltrator") return CardDB.cardName.worgeninfiltrator;
            if (s == "bloodmagethalnos") return CardDB.cardName.bloodmagethalnos;
            if (s == "kingmukla") return CardDB.cardName.kingmukla;
            if (s == "bananas") return CardDB.cardName.bananas;
            if (s == "sylvanaswindrunner") return CardDB.cardName.sylvanaswindrunner;
            if (s == "junglepanther") return CardDB.cardName.junglepanther;
            if (s == "scarletcrusader") return CardDB.cardName.scarletcrusader;
            if (s == "thrallmarfarseer") return CardDB.cardName.thrallmarfarseer;
            if (s == "silvermoonguardian") return CardDB.cardName.silvermoonguardian;
            if (s == "stranglethorntiger") return CardDB.cardName.stranglethorntiger;
            if (s == "lepergnome") return CardDB.cardName.lepergnome;
            if (s == "sunwalker") return CardDB.cardName.sunwalker;
            if (s == "windfuryharpy") return CardDB.cardName.windfuryharpy;
            if (s == "twilightdrake") return CardDB.cardName.twilightdrake;
            if (s == "questingadventurer") return CardDB.cardName.questingadventurer;
            if (s == "ancientwatcher") return CardDB.cardName.ancientwatcher;
            if (s == "darkirondwarf") return CardDB.cardName.darkirondwarf;
            if (s == "spellbreaker") return CardDB.cardName.spellbreaker;
            if (s == "youthfulbrewmaster") return CardDB.cardName.youthfulbrewmaster;
            if (s == "coldlightoracle") return CardDB.cardName.coldlightoracle;
            if (s == "manaaddict") return CardDB.cardName.manaaddict;
            if (s == "ancientbrewmaster") return CardDB.cardName.ancientbrewmaster;
            if (s == "sunfuryprotector") return CardDB.cardName.sunfuryprotector;
            if (s == "crazedalchemist") return CardDB.cardName.crazedalchemist;
            if (s == "argentcommander") return CardDB.cardName.argentcommander;
            if (s == "pintsizedsummoner") return CardDB.cardName.pintsizedsummoner;
            if (s == "secretkeeper") return CardDB.cardName.secretkeeper;
            if (s == "madbomber") return CardDB.cardName.madbomber;
            if (s == "tinkmasteroverspark") return CardDB.cardName.tinkmasteroverspark;
            if (s == "mindcontroltech") return CardDB.cardName.mindcontroltech;
            if (s == "arcanegolem") return CardDB.cardName.arcanegolem;
            if (s == "cabalshadowpriest") return CardDB.cardName.cabalshadowpriest;
            if (s == "defenderofargus") return CardDB.cardName.defenderofargus;
            if (s == "gadgetzanauctioneer") return CardDB.cardName.gadgetzanauctioneer;
            if (s == "loothoarder") return CardDB.cardName.loothoarder;
            if (s == "abomination") return CardDB.cardName.abomination;
            if (s == "lorewalkercho") return CardDB.cardName.lorewalkercho;
            if (s == "demolisher") return CardDB.cardName.demolisher;
            if (s == "coldlightseer") return CardDB.cardName.coldlightseer;
            if (s == "mountaingiant") return CardDB.cardName.mountaingiant;
            if (s == "cairnebloodhoof") return CardDB.cardName.cairnebloodhoof;
            if (s == "bainebloodhoof") return CardDB.cardName.bainebloodhoof;
            if (s == "leeroyjenkins") return CardDB.cardName.leeroyjenkins;
            if (s == "eviscerate") return CardDB.cardName.eviscerate;
            if (s == "betrayal") return CardDB.cardName.betrayal;
            if (s == "conceal") return CardDB.cardName.conceal;
            if (s == "noblesacrifice") return CardDB.cardName.noblesacrifice;
            if (s == "defender") return CardDB.cardName.defender;
            if (s == "defiasringleader") return CardDB.cardName.defiasringleader;
            if (s == "defiasbandit") return CardDB.cardName.defiasbandit;
            if (s == "eyeforaneye") return CardDB.cardName.eyeforaneye;
            if (s == "perditionsblade") return CardDB.cardName.perditionsblade;
            if (s == "si7agent") return CardDB.cardName.si7agent;
            if (s == "redemption") return CardDB.cardName.redemption;
            if (s == "headcrack") return CardDB.cardName.headcrack;
            if (s == "shadowstep") return CardDB.cardName.shadowstep;
            if (s == "preparation") return CardDB.cardName.preparation;
            if (s == "wrath") return CardDB.cardName.wrath;
            if (s == "markofnature") return CardDB.cardName.markofnature;
            if (s == "souloftheforest") return CardDB.cardName.souloftheforest;
            if (s == "treant") return CardDB.cardName.treant;
            if (s == "powerofthewild") return CardDB.cardName.powerofthewild;
            if (s == "summonapanther") return CardDB.cardName.summonapanther;
            if (s == "leaderofthepack") return CardDB.cardName.leaderofthepack;
            if (s == "panther") return CardDB.cardName.panther;
            if (s == "naturalize") return CardDB.cardName.naturalize;
            if (s == "direwolfalpha") return CardDB.cardName.direwolfalpha;
            if (s == "nourish") return CardDB.cardName.nourish;
            if (s == "druidoftheclaw") return CardDB.cardName.druidoftheclaw;
            if (s == "catform") return CardDB.cardName.catform;
            if (s == "bearform") return CardDB.cardName.bearform;
            if (s == "keeperofthegrove") return CardDB.cardName.keeperofthegrove;
            if (s == "dispel") return CardDB.cardName.dispel;
            if (s == "emperorcobra") return CardDB.cardName.emperorcobra;
            if (s == "ancientofwar") return CardDB.cardName.ancientofwar;
            if (s == "rooted") return CardDB.cardName.rooted;
            if (s == "uproot") return CardDB.cardName.uproot;
            if (s == "lightningbolt") return CardDB.cardName.lightningbolt;
            if (s == "lavaburst") return CardDB.cardName.lavaburst;
            if (s == "dustdevil") return CardDB.cardName.dustdevil;
            if (s == "earthshock") return CardDB.cardName.earthshock;
            if (s == "stormforgedaxe") return CardDB.cardName.stormforgedaxe;
            if (s == "feralspirit") return CardDB.cardName.feralspirit;
            if (s == "barongeddon") return CardDB.cardName.barongeddon;
            if (s == "earthelemental") return CardDB.cardName.earthelemental;
            if (s == "forkedlightning") return CardDB.cardName.forkedlightning;
            if (s == "unboundelemental") return CardDB.cardName.unboundelemental;
            if (s == "lightningstorm") return CardDB.cardName.lightningstorm;
            if (s == "etherealarcanist") return CardDB.cardName.etherealarcanist;
            if (s == "coneofcold") return CardDB.cardName.coneofcold;
            if (s == "pyroblast") return CardDB.cardName.pyroblast;
            if (s == "frostelemental") return CardDB.cardName.frostelemental;
            if (s == "azuredrake") return CardDB.cardName.azuredrake;
            if (s == "counterspell") return CardDB.cardName.counterspell;
            if (s == "icebarrier") return CardDB.cardName.icebarrier;
            if (s == "mirrorentity") return CardDB.cardName.mirrorentity;
            if (s == "iceblock") return CardDB.cardName.iceblock;
            if (s == "ragnarosthefirelord") return CardDB.cardName.ragnarosthefirelord;
            if (s == "felguard") return CardDB.cardName.felguard;
            if (s == "shadowflame") return CardDB.cardName.shadowflame;
            if (s == "voidterror") return CardDB.cardName.voidterror;
            if (s == "siphonsoul") return CardDB.cardName.siphonsoul;
            if (s == "doomguard") return CardDB.cardName.doomguard;
            if (s == "twistingnether") return CardDB.cardName.twistingnether;
            if (s == "pitlord") return CardDB.cardName.pitlord;
            if (s == "summoningportal") return CardDB.cardName.summoningportal;
            if (s == "poweroverwhelming") return CardDB.cardName.poweroverwhelming;
            if (s == "sensedemons") return CardDB.cardName.sensedemons;
            if (s == "worthlessimp") return CardDB.cardName.worthlessimp;
            if (s == "flameimp") return CardDB.cardName.flameimp;
            if (s == "baneofdoom") return CardDB.cardName.baneofdoom;
            if (s == "lordjaraxxus") return CardDB.cardName.lordjaraxxus;
            if (s == "bloodfury") return CardDB.cardName.bloodfury;
            if (s == "silence") return CardDB.cardName.silence;
            if (s == "shadowmadness") return CardDB.cardName.shadowmadness;
            if (s == "lightspawn") return CardDB.cardName.lightspawn;
            if (s == "thoughtsteal") return CardDB.cardName.thoughtsteal;
            if (s == "lightwell") return CardDB.cardName.lightwell;
            if (s == "mindgames") return CardDB.cardName.mindgames;
            if (s == "shadowofnothing") return CardDB.cardName.shadowofnothing;
            if (s == "divinefavor") return CardDB.cardName.divinefavor;
            if (s == "prophetvelen") return CardDB.cardName.prophetvelen;
            if (s == "layonhands") return CardDB.cardName.layonhands;
            if (s == "blessedchampion") return CardDB.cardName.blessedchampion;
            if (s == "argentprotector") return CardDB.cardName.argentprotector;
            if (s == "blessingofwisdom") return CardDB.cardName.blessingofwisdom;
            if (s == "holywrath") return CardDB.cardName.holywrath;
            if (s == "swordofjustice") return CardDB.cardName.swordofjustice;
            if (s == "repentance") return CardDB.cardName.repentance;
            if (s == "aldorpeacekeeper") return CardDB.cardName.aldorpeacekeeper;
            if (s == "tirionfordring") return CardDB.cardName.tirionfordring;
            if (s == "ashbringer") return CardDB.cardName.ashbringer;
            if (s == "avengingwrath") return CardDB.cardName.avengingwrath;
            if (s == "taurenwarrior") return CardDB.cardName.taurenwarrior;
            if (s == "slam") return CardDB.cardName.slam;
            if (s == "battlerage") return CardDB.cardName.battlerage;
            if (s == "amaniberserker") return CardDB.cardName.amaniberserker;
            if (s == "mogushanwarden") return CardDB.cardName.mogushanwarden;
            if (s == "arathiweaponsmith") return CardDB.cardName.arathiweaponsmith;
            if (s == "battleaxe") return CardDB.cardName.battleaxe;
            if (s == "armorsmith") return CardDB.cardName.armorsmith;
            if (s == "shieldbearer") return CardDB.cardName.shieldbearer;
            if (s == "brawl") return CardDB.cardName.brawl;
            if (s == "mortalstrike") return CardDB.cardName.mortalstrike;
            if (s == "upgrade") return CardDB.cardName.upgrade;
            if (s == "heavyaxe") return CardDB.cardName.heavyaxe;
            if (s == "shieldslam") return CardDB.cardName.shieldslam;
            if (s == "gorehowl") return CardDB.cardName.gorehowl;
            if (s == "ragingworgen") return CardDB.cardName.ragingworgen;
            if (s == "grommashhellscream") return CardDB.cardName.grommashhellscream;
            if (s == "murlocwarleader") return CardDB.cardName.murlocwarleader;
            if (s == "murloctidecaller") return CardDB.cardName.murloctidecaller;
            if (s == "patientassassin") return CardDB.cardName.patientassassin;
            if (s == "scavenginghyena") return CardDB.cardName.scavenginghyena;
            if (s == "misdirection") return CardDB.cardName.misdirection;
            if (s == "savannahhighmane") return CardDB.cardName.savannahhighmane;
            if (s == "hyena") return CardDB.cardName.hyena;
            if (s == "eaglehornbow") return CardDB.cardName.eaglehornbow;
            if (s == "explosiveshot") return CardDB.cardName.explosiveshot;
            if (s == "unleashthehounds") return CardDB.cardName.unleashthehounds;
            if (s == "hound") return CardDB.cardName.hound;
            if (s == "kingkrush") return CardDB.cardName.kingkrush;
            if (s == "flare") return CardDB.cardName.flare;
            if (s == "bestialwrath") return CardDB.cardName.bestialwrath;
            if (s == "snaketrap") return CardDB.cardName.snaketrap;
            if (s == "snake") return CardDB.cardName.snake;
            if (s == "harvestgolem") return CardDB.cardName.harvestgolem;
            if (s == "natpagle") return CardDB.cardName.natpagle;
            if (s == "harrisonjones") return CardDB.cardName.harrisonjones;
            if (s == "archmageantonidas") return CardDB.cardName.archmageantonidas;
            if (s == "nozdormu") return CardDB.cardName.nozdormu;
            if (s == "alexstrasza") return CardDB.cardName.alexstrasza;
            if (s == "onyxia") return CardDB.cardName.onyxia;
            if (s == "malygos") return CardDB.cardName.malygos;
            if (s == "facelessmanipulator") return CardDB.cardName.facelessmanipulator;
            if (s == "doomhammer") return CardDB.cardName.doomhammer;
            if (s == "bite") return CardDB.cardName.bite;
            if (s == "forceofnature") return CardDB.cardName.forceofnature;
            if (s == "ysera") return CardDB.cardName.ysera;
            if (s == "cenarius") return CardDB.cardName.cenarius;
            if (s == "demigodsfavor") return CardDB.cardName.demigodsfavor;
            if (s == "shandoslesson") return CardDB.cardName.shandoslesson;
            if (s == "manatidetotem") return CardDB.cardName.manatidetotem;
            if (s == "thebeast") return CardDB.cardName.thebeast;
            if (s == "savagery") return CardDB.cardName.savagery;
            if (s == "priestessofelune") return CardDB.cardName.priestessofelune;
            if (s == "ancientmage") return CardDB.cardName.ancientmage;
            if (s == "seagiant") return CardDB.cardName.seagiant;
            if (s == "bloodknight") return CardDB.cardName.bloodknight;
            if (s == "auchenaisoulpriest") return CardDB.cardName.auchenaisoulpriest;
            if (s == "vaporize") return CardDB.cardName.vaporize;
            if (s == "cultmaster") return CardDB.cardName.cultmaster;
            if (s == "demonfire") return CardDB.cardName.demonfire;
            if (s == "impmaster") return CardDB.cardName.impmaster;
            if (s == "imp") return CardDB.cardName.imp;
            if (s == "crueltaskmaster") return CardDB.cardName.crueltaskmaster;
            if (s == "frothingberserker") return CardDB.cardName.frothingberserker;
            if (s == "innerrage") return CardDB.cardName.innerrage;
            if (s == "sorcerersapprentice") return CardDB.cardName.sorcerersapprentice;
            if (s == "snipe") return CardDB.cardName.snipe;
            if (s == "explosivetrap") return CardDB.cardName.explosivetrap;
            if (s == "freezingtrap") return CardDB.cardName.freezingtrap;
            if (s == "kirintormage") return CardDB.cardName.kirintormage;
            if (s == "edwinvancleef") return CardDB.cardName.edwinvancleef;
            if (s == "illidanstormrage") return CardDB.cardName.illidanstormrage;
            if (s == "flameofazzinoth") return CardDB.cardName.flameofazzinoth;
            if (s == "manawraith") return CardDB.cardName.manawraith;
            if (s == "deadlyshot") return CardDB.cardName.deadlyshot;
            if (s == "equality") return CardDB.cardName.equality;
            if (s == "moltengiant") return CardDB.cardName.moltengiant;
            if (s == "circleofhealing") return CardDB.cardName.circleofhealing;
            if (s == "templeenforcer") return CardDB.cardName.templeenforcer;
            if (s == "holyfire") return CardDB.cardName.holyfire;
            if (s == "shadowform") return CardDB.cardName.shadowform;
            if (s == "mindspike") return CardDB.cardName.mindspike;
            if (s == "mindshatter") return CardDB.cardName.mindshatter;
            if (s == "massdispel") return CardDB.cardName.massdispel;
            if (s == "finkleeinhorn") return CardDB.cardName.finkleeinhorn;
            if (s == "spiritwolf") return CardDB.cardName.spiritwolf;
            if (s == "squirrel") return CardDB.cardName.squirrel;
            if (s == "devilsaur") return CardDB.cardName.devilsaur;
            if (s == "inferno") return CardDB.cardName.inferno;
            if (s == "infernal") return CardDB.cardName.infernal;
            if (s == "kidnapper") return CardDB.cardName.kidnapper;
            if (s == "starfall") return CardDB.cardName.starfall;
            if (s == "ancientoflore") return CardDB.cardName.ancientoflore;
            if (s == "ancientteachings") return CardDB.cardName.ancientteachings;
            if (s == "ancientsecrets") return CardDB.cardName.ancientsecrets;
            if (s == "alakirthewindlord") return CardDB.cardName.alakirthewindlord;
            if (s == "manawyrm") return CardDB.cardName.manawyrm;
            if (s == "masterofdisguise") return CardDB.cardName.masterofdisguise;
            if (s == "hungrycrab") return CardDB.cardName.hungrycrab;
            if (s == "bloodsailraider") return CardDB.cardName.bloodsailraider;
            if (s == "knifejuggler") return CardDB.cardName.knifejuggler;
            if (s == "wildpyromancer") return CardDB.cardName.wildpyromancer;
            if (s == "doomsayer") return CardDB.cardName.doomsayer;
            if (s == "dreadcorsair") return CardDB.cardName.dreadcorsair;
            if (s == "faeriedragon") return CardDB.cardName.faeriedragon;
            if (s == "captaingreenskin") return CardDB.cardName.captaingreenskin;
            if (s == "bloodsailcorsair") return CardDB.cardName.bloodsailcorsair;
            if (s == "violetteacher") return CardDB.cardName.violetteacher;
            if (s == "violetapprentice") return CardDB.cardName.violetapprentice;
            if (s == "southseacaptain") return CardDB.cardName.southseacaptain;
            if (s == "millhousemanastorm") return CardDB.cardName.millhousemanastorm;
            if (s == "deathwing") return CardDB.cardName.deathwing;
            if (s == "commandingshout") return CardDB.cardName.commandingshout;
            if (s == "masterswordsmith") return CardDB.cardName.masterswordsmith;
            if (s == "gruul") return CardDB.cardName.gruul;
            if (s == "hogger") return CardDB.cardName.hogger;
            if (s == "gnoll") return CardDB.cardName.gnoll;
            if (s == "stampedingkodo") return CardDB.cardName.stampedingkodo;
            if (s == "damagedgolem") return CardDB.cardName.damagedgolem;
            if (s == "flesheatingghoul") return CardDB.cardName.flesheatingghoul;
            if (s == "spellbender") return CardDB.cardName.spellbender;
            if (s == "jasonchayes") return CardDB.cardName.jasonchayes;
            if (s == "ericdodds") return CardDB.cardName.ericdodds;
            if (s == "bobfitch") return CardDB.cardName.bobfitch;
            if (s == "stevengabriel") return CardDB.cardName.stevengabriel;
            if (s == "kyleharrison") return CardDB.cardName.kyleharrison;
            if (s == "dereksakamoto") return CardDB.cardName.dereksakamoto;
            if (s == "zwick") return CardDB.cardName.zwick;
            if (s == "benbrode") return CardDB.cardName.benbrode;
            if (s == "benthompson") return CardDB.cardName.benthompson;
            if (s == "michaelschweitzer") return CardDB.cardName.michaelschweitzer;
            if (s == "jaybaxter") return CardDB.cardName.jaybaxter;
            if (s == "rachelledavis") return CardDB.cardName.rachelledavis;
            if (s == "brianschwab") return CardDB.cardName.brianschwab;
            if (s == "yongwoo") return CardDB.cardName.yongwoo;
            if (s == "andybrock") return CardDB.cardName.andybrock;
            if (s == "hamiltonchu") return CardDB.cardName.hamiltonchu;
            if (s == "robpardo") return CardDB.cardName.robpardo;
            if (s == "oldmurkeye") return CardDB.cardName.oldmurkeye;
            if (s == "captainsparrot") return CardDB.cardName.captainsparrot;
            if (s == "riverpawgnoll") return CardDB.cardName.riverpawgnoll;
            if (s == "hoggersmash") return CardDB.cardName.hoggersmash;
            if (s == "massivegnoll") return CardDB.cardName.massivegnoll;
            if (s == "barreltoss") return CardDB.cardName.barreltoss;
            if (s == "barrel") return CardDB.cardName.barrel;
            if (s == "stomp") return CardDB.cardName.stomp;
            if (s == "hiddengnome") return CardDB.cardName.hiddengnome;
            if (s == "muklasbigbrother") return CardDB.cardName.muklasbigbrother;
            if (s == "willofmukla") return CardDB.cardName.willofmukla;
            if (s == "hemetnesingwary") return CardDB.cardName.hemetnesingwary;
            if (s == "crazedhunter") return CardDB.cardName.crazedhunter;
            if (s == "shotgunblast") return CardDB.cardName.shotgunblast;
            if (s == "flamesofazzinoth") return CardDB.cardName.flamesofazzinoth;
            if (s == "nagamyrmidon") return CardDB.cardName.nagamyrmidon;
            if (s == "warglaiveofazzinoth") return CardDB.cardName.warglaiveofazzinoth;
            if (s == "flameburst") return CardDB.cardName.flameburst;
            if (s == "dualwarglaives") return CardDB.cardName.dualwarglaives;
            if (s == "pandarenscout") return CardDB.cardName.pandarenscout;
            if (s == "shadopanmonk") return CardDB.cardName.shadopanmonk;
            if (s == "legacyoftheemperor") return CardDB.cardName.legacyoftheemperor;
            if (s == "brewmaster") return CardDB.cardName.brewmaster;
            if (s == "transcendence") return CardDB.cardName.transcendence;
            if (s == "crazymonkey") return CardDB.cardName.crazymonkey;
            if (s == "damage1") return CardDB.cardName.damage1;
            if (s == "damage5") return CardDB.cardName.damage5;
            if (s == "restore1") return CardDB.cardName.restore1;
            if (s == "restore5") return CardDB.cardName.restore5;
            if (s == "destroy") return CardDB.cardName.destroy;
            if (s == "breakweapon") return CardDB.cardName.breakweapon;
            if (s == "enableforattack") return CardDB.cardName.enableforattack;
            if (s == "freeze") return CardDB.cardName.freeze;
            if (s == "enchant") return CardDB.cardName.enchant;
            if (s == "silencedebug") return CardDB.cardName.silencedebug;
            if (s == "summonarandomsecret") return CardDB.cardName.summonarandomsecret;
            if (s == "bounce") return CardDB.cardName.bounce;
            if (s == "discard") return CardDB.cardName.discard;
            if (s == "mill10") return CardDB.cardName.mill10;
            if (s == "crash") return CardDB.cardName.crash;
            if (s == "snakeball") return CardDB.cardName.snakeball;
            if (s == "draw3cards") return CardDB.cardName.draw3cards;
            if (s == "destroyallminions") return CardDB.cardName.destroyallminions;
            if (s == "molasses") return CardDB.cardName.molasses;
            if (s == "damageallbut1") return CardDB.cardName.damageallbut1;
            if (s == "restoreallhealth") return CardDB.cardName.restoreallhealth;
            if (s == "freecards") return CardDB.cardName.freecards;
            if (s == "destroyallheroes") return CardDB.cardName.destroyallheroes;
            if (s == "damagereflector") return CardDB.cardName.damagereflector;
            if (s == "donothing") return CardDB.cardName.donothing;
            if (s == "enableemotes") return CardDB.cardName.enableemotes;
            if (s == "servercrash") return CardDB.cardName.servercrash;
            if (s == "revealhand") return CardDB.cardName.revealhand;
            if (s == "opponentconcede") return CardDB.cardName.opponentconcede;
            if (s == "opponentdisconnect") return CardDB.cardName.opponentdisconnect;
            if (s == "becomehogger") return CardDB.cardName.becomehogger;
            if (s == "destroyheropower") return CardDB.cardName.destroyheropower;
            if (s == "handtodeck") return CardDB.cardName.handtodeck;
            if (s == "mill30") return CardDB.cardName.mill30;
            if (s == "handswapperminion") return CardDB.cardName.handswapperminion;
            if (s == "stealcard") return CardDB.cardName.stealcard;
            if (s == "forceaitouseheropower") return CardDB.cardName.forceaitouseheropower;
            if (s == "destroydeck") return CardDB.cardName.destroydeck;
            if (s == "1durability") return CardDB.cardName.durability;
            if (s == "destroyallmana") return CardDB.cardName.destroyallmana;
            if (s == "destroyamanacrystal") return CardDB.cardName.destroyamanacrystal;
            if (s == "makeimmune") return CardDB.cardName.makeimmune;
            if (s == "grantmegawindfury") return CardDB.cardName.grantmegawindfury;
            if (s == "armor") return CardDB.cardName.armor;
            if (s == "weaponbuff") return CardDB.cardName.weaponbuff;
            if (s == "1000stats") return CardDB.cardName.stats;
            if (s == "silencedestroy") return CardDB.cardName.silencedestroy;
            if (s == "destroysecrets") return CardDB.cardName.destroysecrets;
            if (s == "aibuddyallcharge") return CardDB.cardName.aibuddyallcharge;
            if (s == "aibuddydamageownhero5") return CardDB.cardName.aibuddydamageownhero5;
            if (s == "aibuddydestroyminions") return CardDB.cardName.aibuddydestroyminions;
            if (s == "aibuddynodeck/hand") return CardDB.cardName.aibuddynodeckhand;
            if (s == "aihelperbuddy") return CardDB.cardName.aihelperbuddy;
            if (s == "gelbinmekkatorque") return CardDB.cardName.gelbinmekkatorque;
            if (s == "homingchicken") return CardDB.cardName.homingchicken;
            if (s == "repairbot") return CardDB.cardName.repairbot;
            if (s == "emboldener3000") return CardDB.cardName.emboldener3000;
            if (s == "poultryizer") return CardDB.cardName.poultryizer;
            if (s == "chicken") return CardDB.cardName.chicken;
            if (s == "elitetaurenchieftain") return CardDB.cardName.elitetaurenchieftain;
            if (s == "iammurloc") return CardDB.cardName.iammurloc;
            if (s == "murloc") return CardDB.cardName.murloc;
            if (s == "roguesdoit") return CardDB.cardName.roguesdoit;
            if (s == "powerofthehorde") return CardDB.cardName.powerofthehorde;
            if (s == "zombiechow") return CardDB.cardName.zombiechow;
            if (s == "hauntedcreeper") return CardDB.cardName.hauntedcreeper;
            if (s == "spectralspider") return CardDB.cardName.spectralspider;
            if (s == "echoingooze") return CardDB.cardName.echoingooze;
            if (s == "madscientist") return CardDB.cardName.madscientist;
            if (s == "shadeofnaxxramas") return CardDB.cardName.shadeofnaxxramas;
            if (s == "deathcharger") return CardDB.cardName.deathcharger;
            if (s == "nerubianegg") return CardDB.cardName.nerubianegg;
            if (s == "nerubian") return CardDB.cardName.nerubian;
            if (s == "spectralknight") return CardDB.cardName.spectralknight;
            if (s == "deathlord") return CardDB.cardName.deathlord;
            if (s == "maexxna") return CardDB.cardName.maexxna;
            if (s == "webspinner") return CardDB.cardName.webspinner;
            if (s == "sludgebelcher") return CardDB.cardName.sludgebelcher;
            if (s == "slime") return CardDB.cardName.slime;
            if (s == "kelthuzad") return CardDB.cardName.kelthuzad;
            if (s == "stalagg") return CardDB.cardName.stalagg;
            if (s == "thaddius") return CardDB.cardName.thaddius;
            if (s == "feugen") return CardDB.cardName.feugen;
            if (s == "wailingsoul") return CardDB.cardName.wailingsoul;
            if (s == "nerubarweblord") return CardDB.cardName.nerubarweblord;
            if (s == "duplicate") return CardDB.cardName.duplicate;
            if (s == "poisonseeds") return CardDB.cardName.poisonseeds;
            if (s == "avenge") return CardDB.cardName.avenge;
            if (s == "deathsbite") return CardDB.cardName.deathsbite;
            if (s == "voidcaller") return CardDB.cardName.voidcaller;
            if (s == "darkcultist") return CardDB.cardName.darkcultist;
            if (s == "unstableghoul") return CardDB.cardName.unstableghoul;
            if (s == "reincarnate") return CardDB.cardName.reincarnate;
            if (s == "anubarambusher") return CardDB.cardName.anubarambusher;
            if (s == "stoneskingargoyle") return CardDB.cardName.stoneskingargoyle;
            if (s == "undertaker") return CardDB.cardName.undertaker;
            if (s == "dancingswords") return CardDB.cardName.dancingswords;
            if (s == "loatheb") return CardDB.cardName.loatheb;
            if (s == "baronrivendare") return CardDB.cardName.baronrivendare;
            if (s == "patchwerk") return CardDB.cardName.patchwerk;
            if (s == "hook") return CardDB.cardName.hook;
            if (s == "hatefulstrike") return CardDB.cardName.hatefulstrike;
            if (s == "grobbulus") return CardDB.cardName.grobbulus;
            if (s == "poisoncloud") return CardDB.cardName.poisoncloud;
            if (s == "falloutslime") return CardDB.cardName.falloutslime;
            if (s == "mutatinginjection") return CardDB.cardName.mutatinginjection;
            if (s == "gluth") return CardDB.cardName.gluth;
            if (s == "decimate") return CardDB.cardName.decimate;
            if (s == "jaws") return CardDB.cardName.jaws;
            if (s == "enrage") return CardDB.cardName.enrage;
            if (s == "polarityshift") return CardDB.cardName.polarityshift;
            if (s == "supercharge") return CardDB.cardName.supercharge;
            if (s == "sapphiron") return CardDB.cardName.sapphiron;
            if (s == "frostbreath") return CardDB.cardName.frostbreath;
            if (s == "frozenchampion") return CardDB.cardName.frozenchampion;
            if (s == "purecold") return CardDB.cardName.purecold;
            if (s == "frostblast") return CardDB.cardName.frostblast;
            if (s == "guardianoficecrown") return CardDB.cardName.guardianoficecrown;
            if (s == "chains") return CardDB.cardName.chains;
            if (s == "mrbigglesworth") return CardDB.cardName.mrbigglesworth;
            if (s == "anubrekhan") return CardDB.cardName.anubrekhan;
            if (s == "skitter") return CardDB.cardName.skitter;
            if (s == "locustswarm") return CardDB.cardName.locustswarm;
            if (s == "grandwidowfaerlina") return CardDB.cardName.grandwidowfaerlina;
            if (s == "rainoffire") return CardDB.cardName.rainoffire;
            if (s == "worshipper") return CardDB.cardName.worshipper;
            if (s == "webwrap") return CardDB.cardName.webwrap;
            if (s == "necroticpoison") return CardDB.cardName.necroticpoison;
            if (s == "noththeplaguebringer") return CardDB.cardName.noththeplaguebringer;
            if (s == "raisedead") return CardDB.cardName.raisedead;
            if (s == "plague") return CardDB.cardName.plague;
            if (s == "heigantheunclean") return CardDB.cardName.heigantheunclean;
            if (s == "eruption") return CardDB.cardName.eruption;
            if (s == "mindpocalypse") return CardDB.cardName.mindpocalypse;
            if (s == "necroticaura") return CardDB.cardName.necroticaura;
            if (s == "deathbloom") return CardDB.cardName.deathbloom;
            if (s == "spore") return CardDB.cardName.spore;
            if (s == "sporeburst") return CardDB.cardName.sporeburst;
            if (s == "instructorrazuvious") return CardDB.cardName.instructorrazuvious;
            if (s == "understudy") return CardDB.cardName.understudy;
            if (s == "unbalancingstrike") return CardDB.cardName.unbalancingstrike;
            if (s == "massiveruneblade") return CardDB.cardName.massiveruneblade;
            if (s == "mindcontrolcrystal") return CardDB.cardName.mindcontrolcrystal;
            if (s == "gothiktheharvester") return CardDB.cardName.gothiktheharvester;
            if (s == "harvest") return CardDB.cardName.harvest;
            if (s == "unrelentingtrainee") return CardDB.cardName.unrelentingtrainee;
            if (s == "spectraltrainee") return CardDB.cardName.spectraltrainee;
            if (s == "unrelentingwarrior") return CardDB.cardName.unrelentingwarrior;
            if (s == "spectralwarrior") return CardDB.cardName.spectralwarrior;
            if (s == "unrelentingrider") return CardDB.cardName.unrelentingrider;
            if (s == "spectralrider") return CardDB.cardName.spectralrider;
            if (s == "ladyblaumeux") return CardDB.cardName.ladyblaumeux;
            if (s == "thanekorthazz") return CardDB.cardName.thanekorthazz;
            if (s == "sirzeliek") return CardDB.cardName.sirzeliek;
            if (s == "runeblade") return CardDB.cardName.runeblade;
            if (s == "unholyshadow") return CardDB.cardName.unholyshadow;
            if (s == "markofthehorsemen") return CardDB.cardName.markofthehorsemen;
            if (s == "necroknight") return CardDB.cardName.necroknight;
            if (s == "skeletalsmith") return CardDB.cardName.skeletalsmith;
            if (s == "flamecannon") return CardDB.cardName.flamecannon;
            if (s == "snowchugger") return CardDB.cardName.snowchugger;
            if (s == "unstableportal") return CardDB.cardName.unstableportal;
            if (s == "goblinblastmage") return CardDB.cardName.goblinblastmage;
            if (s == "echoofmedivh") return CardDB.cardName.echoofmedivh;
            if (s == "mechwarper") return CardDB.cardName.mechwarper;
            if (s == "flameleviathan") return CardDB.cardName.flameleviathan;
            if (s == "lightbomb") return CardDB.cardName.lightbomb;
            if (s == "shadowbomber") return CardDB.cardName.shadowbomber;
            if (s == "velenschosen") return CardDB.cardName.velenschosen;
            if (s == "shrinkmeister") return CardDB.cardName.shrinkmeister;
            if (s == "lightofthenaaru") return CardDB.cardName.lightofthenaaru;
            if (s == "cogmaster") return CardDB.cardName.cogmaster;
            if (s == "voljin") return CardDB.cardName.voljin;
            if (s == "darkbomb") return CardDB.cardName.darkbomb;
            if (s == "felreaver") return CardDB.cardName.felreaver;
            if (s == "callpet") return CardDB.cardName.callpet;
            if (s == "mistressofpain") return CardDB.cardName.mistressofpain;
            if (s == "demonheart") return CardDB.cardName.demonheart;
            if (s == "felcannon") return CardDB.cardName.felcannon;
            if (s == "malganis") return CardDB.cardName.malganis;
            if (s == "tinkerssharpswordoil") return CardDB.cardName.tinkerssharpswordoil;
            if (s == "goblinautobarber") return CardDB.cardName.goblinautobarber;
            if (s == "cogmasterswrench") return CardDB.cardName.cogmasterswrench;
            if (s == "oneeyedcheat") return CardDB.cardName.oneeyedcheat;
            if (s == "feigndeath") return CardDB.cardName.feigndeath;
            if (s == "ironsensei") return CardDB.cardName.ironsensei;
            if (s == "tradeprincegallywix") return CardDB.cardName.tradeprincegallywix;
            if (s == "gallywixscoin") return CardDB.cardName.gallywixscoin;
            if (s == "ancestorscall") return CardDB.cardName.ancestorscall;
            if (s == "anodizedrobocub") return CardDB.cardName.anodizedrobocub;
            if (s == "attackmode") return CardDB.cardName.attackmode;
            if (s == "tankmode") return CardDB.cardName.tankmode;
            if (s == "recycle") return CardDB.cardName.recycle;
            if (s == "grovetender") return CardDB.cardName.grovetender;
            if (s == "giftofmana") return CardDB.cardName.giftofmana;
            if (s == "giftofcards") return CardDB.cardName.giftofcards;
            if (s == "treeoflife") return CardDB.cardName.treeoflife;
            if (s == "mechbearcat") return CardDB.cardName.mechbearcat;
            if (s == "malorne") return CardDB.cardName.malorne;
            if (s == "powermace") return CardDB.cardName.powermace;
            if (s == "whirlingzapomatic") return CardDB.cardName.whirlingzapomatic;
            if (s == "crackle") return CardDB.cardName.crackle;
            if (s == "vitalitytotem") return CardDB.cardName.vitalitytotem;
            if (s == "siltfinspiritwalker") return CardDB.cardName.siltfinspiritwalker;
            if (s == "darkwispers") return CardDB.cardName.darkwispers;
            if (s == "neptulon") return CardDB.cardName.neptulon;
            if (s == "glaivezooka") return CardDB.cardName.glaivezooka;
            if (s == "spidertank") return CardDB.cardName.spidertank;
            if (s == "implosion") return CardDB.cardName.implosion;
            if (s == "kingofbeasts") return CardDB.cardName.kingofbeasts;
            if (s == "sabotage") return CardDB.cardName.sabotage;
            if (s == "metaltoothleaper") return CardDB.cardName.metaltoothleaper;
            if (s == "gahzrilla") return CardDB.cardName.gahzrilla;
            if (s == "bouncingblade") return CardDB.cardName.bouncingblade;
            if (s == "warbot") return CardDB.cardName.warbot;
            if (s == "crush") return CardDB.cardName.crush;
            if (s == "shieldmaiden") return CardDB.cardName.shieldmaiden;
            if (s == "ogrewarmaul") return CardDB.cardName.ogrewarmaul;
            if (s == "screwjankclunker") return CardDB.cardName.screwjankclunker;
            if (s == "ironjuggernaut") return CardDB.cardName.ironjuggernaut;
            if (s == "burrowingmine") return CardDB.cardName.burrowingmine;
            if (s == "sealoflight") return CardDB.cardName.sealoflight;
            if (s == "shieldedminibot") return CardDB.cardName.shieldedminibot;
            if (s == "coghammer") return CardDB.cardName.coghammer;
            if (s == "quartermaster") return CardDB.cardName.quartermaster;
            if (s == "musterforbattle") return CardDB.cardName.musterforbattle;
            if (s == "cobaltguardian") return CardDB.cardName.cobaltguardian;
            if (s == "bolvarfordragon") return CardDB.cardName.bolvarfordragon;
            if (s == "puddlestomper") return CardDB.cardName.puddlestomper;
            if (s == "ogrebrute") return CardDB.cardName.ogrebrute;
            if (s == "dunemaulshaman") return CardDB.cardName.dunemaulshaman;
            if (s == "stonesplintertrogg") return CardDB.cardName.stonesplintertrogg;
            if (s == "burlyrockjawtrogg") return CardDB.cardName.burlyrockjawtrogg;
            if (s == "antiquehealbot") return CardDB.cardName.antiquehealbot;
            if (s == "saltydog") return CardDB.cardName.saltydog;
            if (s == "losttallstrider") return CardDB.cardName.losttallstrider;
            if (s == "shadowboxer") return CardDB.cardName.shadowboxer;
            if (s == "cobrashot") return CardDB.cardName.cobrashot;
            if (s == "kezanmystic") return CardDB.cardName.kezanmystic;
            if (s == "shipscannon") return CardDB.cardName.shipscannon;
            if (s == "explosivesheep") return CardDB.cardName.explosivesheep;
            if (s == "animagolem") return CardDB.cardName.animagolem;
            if (s == "mechanicalyeti") return CardDB.cardName.mechanicalyeti;
            if (s == "forcetankmax") return CardDB.cardName.forcetankmax;
            if (s == "druidofthefang") return CardDB.cardName.druidofthefang;
            if (s == "gilblinstalker") return CardDB.cardName.gilblinstalker;
            if (s == "clockworkgnome") return CardDB.cardName.clockworkgnome;
            if (s == "upgradedrepairbot") return CardDB.cardName.upgradedrepairbot;
            if (s == "flyingmachine") return CardDB.cardName.flyingmachine;
            if (s == "annoyotron") return CardDB.cardName.annoyotron;
            if (s == "siegeengine") return CardDB.cardName.siegeengine;
            if (s == "steamwheedlesniper") return CardDB.cardName.steamwheedlesniper;
            if (s == "ogreninja") return CardDB.cardName.ogreninja;
            if (s == "illuminator") return CardDB.cardName.illuminator;
            if (s == "madderbomber") return CardDB.cardName.madderbomber;
            if (s == "arcanenullifierx21") return CardDB.cardName.arcanenullifierx21;
            if (s == "gnomishexperimenter") return CardDB.cardName.gnomishexperimenter;
            if (s == "targetdummy") return CardDB.cardName.targetdummy;
            if (s == "jeeves") return CardDB.cardName.jeeves;
            if (s == "goblinsapper") return CardDB.cardName.goblinsapper;
            if (s == "pilotedshredder") return CardDB.cardName.pilotedshredder;
            if (s == "lilexorcist") return CardDB.cardName.lilexorcist;
            if (s == "gnomereganinfantry") return CardDB.cardName.gnomereganinfantry;
            if (s == "bomblobber") return CardDB.cardName.bomblobber;
            if (s == "floatingwatcher") return CardDB.cardName.floatingwatcher;
            if (s == "scarletpurifier") return CardDB.cardName.scarletpurifier;
            if (s == "tinkertowntechnician") return CardDB.cardName.tinkertowntechnician;
            if (s == "micromachine") return CardDB.cardName.micromachine;
            if (s == "hobgoblin") return CardDB.cardName.hobgoblin;
            if (s == "pilotedskygolem") return CardDB.cardName.pilotedskygolem;
            if (s == "junkbot") return CardDB.cardName.junkbot;
            if (s == "enhanceomechano") return CardDB.cardName.enhanceomechano;
            if (s == "recombobulator") return CardDB.cardName.recombobulator;
            if (s == "minimage") return CardDB.cardName.minimage;
            if (s == "drboom") return CardDB.cardName.drboom;
            if (s == "boombot") return CardDB.cardName.boombot;
            if (s == "mimironshead") return CardDB.cardName.mimironshead;
            if (s == "v07tr0n") return CardDB.cardName.v07tr0n;
            if (s == "mogortheogre") return CardDB.cardName.mogortheogre;
            if (s == "foereaper4000") return CardDB.cardName.foereaper4000;
            if (s == "sneedsoldshredder") return CardDB.cardName.sneedsoldshredder;
            if (s == "toshley") return CardDB.cardName.toshley;
            if (s == "mekgineerthermaplugg") return CardDB.cardName.mekgineerthermaplugg;
            if (s == "gazlowe") return CardDB.cardName.gazlowe;
            if (s == "troggzortheearthinator") return CardDB.cardName.troggzortheearthinator;
            if (s == "blingtron3000") return CardDB.cardName.blingtron3000;
            if (s == "clockworkgiant") return CardDB.cardName.clockworkgiant;
            if (s == "weespellstopper") return CardDB.cardName.weespellstopper;
            if (s == "sootspewer") return CardDB.cardName.sootspewer;
            if (s == "armorplating") return CardDB.cardName.armorplating;
            if (s == "timerewinder") return CardDB.cardName.timerewinder;
            if (s == "rustyhorn") return CardDB.cardName.rustyhorn;
            if (s == "finickycloakfield") return CardDB.cardName.finickycloakfield;
            if (s == "emergencycoolant") return CardDB.cardName.emergencycoolant;
            if (s == "reversingswitch") return CardDB.cardName.reversingswitch;
            if (s == "whirlingblades") return CardDB.cardName.whirlingblades;
            if (s == "placeholdercard") return CardDB.cardName.placeholdercard;
            return CardDB.cardName.unknown;
        }

        public enum ErrorType2
        {
            NONE,//=0
            REQ_MINION_TARGET,//=1
            REQ_FRIENDLY_TARGET,//=2
            REQ_ENEMY_TARGET,//=3
            REQ_DAMAGED_TARGET,//=4
            REQ_ENCHANTED_TARGET,
            REQ_FROZEN_TARGET,
            REQ_CHARGE_TARGET,
            REQ_TARGET_MAX_ATTACK,//=8
            REQ_NONSELF_TARGET,//=9
            REQ_TARGET_WITH_RACE,//=10
            REQ_TARGET_TO_PLAY,//=11 
            REQ_NUM_MINION_SLOTS,//=12 
            REQ_WEAPON_EQUIPPED,//=13
            REQ_ENOUGH_MANA,//=14
            REQ_YOUR_TURN,
            REQ_NONSTEALTH_ENEMY_TARGET,
            REQ_HERO_TARGET,//17
            REQ_SECRET_CAP,
            REQ_MINION_CAP_IF_TARGET_AVAILABLE,//19
            REQ_MINION_CAP,
            REQ_TARGET_ATTACKED_THIS_TURN,
            REQ_TARGET_IF_AVAILABLE,//=22
            REQ_MINIMUM_ENEMY_MINIONS,//=23 /like spalen :D
            REQ_TARGET_FOR_COMBO,//=24
            REQ_NOT_EXHAUSTED_ACTIVATE,
            REQ_UNIQUE_SECRET,
            REQ_TARGET_TAUNTER,
            REQ_CAN_BE_ATTACKED,
            REQ_ACTION_PWR_IS_MASTER_PWR,
            REQ_TARGET_MAGNET,
            REQ_ATTACK_GREATER_THAN_0,
            REQ_ATTACKER_NOT_FROZEN,
            REQ_HERO_OR_MINION_TARGET,
            REQ_CAN_BE_TARGETED_BY_SPELLS,
            REQ_SUBCARD_IS_PLAYABLE,
            REQ_TARGET_FOR_NO_COMBO,
            REQ_NOT_MINION_JUST_PLAYED,
            REQ_NOT_EXHAUSTED_HERO_POWER,
            REQ_CAN_BE_TARGETED_BY_OPPONENTS,
            REQ_ATTACKER_CAN_ATTACK,
            REQ_TARGET_MIN_ATTACK,//=41
            REQ_CAN_BE_TARGETED_BY_HERO_POWERS,
            REQ_ENEMY_TARGET_NOT_IMMUNE,
            REQ_ENTIRE_ENTOURAGE_NOT_IN_PLAY,//44 (totemic call)
            REQ_MINIMUM_TOTAL_MINIONS,//45 (scharmuetzel)
            REQ_MUST_TARGET_TAUNTER,//=46
            REQ_UNDAMAGED_TARGET,//=47
            REQ_CAN_BE_TARGETED_BY_BATTLECRIES,
            REQ_STEADY_SHOT,//49
            REQ_MINION_OR_ENEMY_HERO,//50
            REQ_DRAG_TO_PLAY
        }

        public class Card
        {
            //public string CardID = "";
            public cardName name = cardName.unknown;
            public int race = 0;
            public int rarity = 0;
            public int cost = 0;
            public int Class = 0;
            public cardtype type = CardDB.cardtype.NONE;
            //public string description = "";

            public int Attack = 0;
            public int Health = 0;
            public int Durability = 0;//for weapons
            public bool target = false;
            //public string targettext = "";
            public bool tank = false;
            public bool Silence = false;
            public bool choice = false;
            public bool windfury = false;
            public bool poisionous = false;
            public bool deathrattle = false;
            public bool battlecry = false;
            public bool oneTurnEffect = false;
            public bool Enrage = false;
            public bool Aura = false;
            public bool Elite = false;
            public bool Combo = false;
            public bool Recall = false;
            public int recallValue = 0;
            public bool immuneWhileAttacking = false;
            public bool immuneToSpellpowerg = false;
            public bool Stealth = false;
            public bool Freeze = false;
            public bool AdjacentBuff = false;
            public bool Shield = false;
            public bool Charge = false;
            public bool Secret = false;
            public bool Morph = false;
            public bool Spellpower = false;
            public bool GrantCharge = false;
            public bool HealTarget = false;
            //playRequirements, reqID= siehe PlayErrors->ErrorType
            public int needEmptyPlacesForPlaying = 0;
            public int needWithMinAttackValueOf = 0;
            public int needWithMaxAttackValueOf = 0;
            public int needRaceForPlaying = 0;
            public int needMinNumberOfEnemy = 0;
            public int needMinTotalMinions = 0;
            public int needMinionsCapIfAvailable = 0;


            //additional data
            public bool isToken = false;
            public int isCarddraw = 0;
            public bool damagesTarget = false;
            public bool damagesTargetWithSpecial = false;
            public int targetPriority = 0;
            public bool isSpecialMinion = false;

            public int spellpowervalue = 0;
            public cardIDEnum cardIDenum = cardIDEnum.None;
            public List<ErrorType2> playrequires;

            public SimTemplate sim_card;

            public Card()
            {
                playrequires = new List<ErrorType2>();
            }

            public Card(Card c)
            {
                //this.entityID = c.entityID;
                this.rarity = c.rarity;
                this.AdjacentBuff = c.AdjacentBuff;
                this.Attack = c.Attack;
                this.Aura = c.Aura;
                this.battlecry = c.battlecry;
                //this.CardID = c.CardID;
                this.Charge = c.Charge;
                this.choice = c.choice;
                this.Combo = c.Combo;
                this.cost = c.cost;
                this.deathrattle = c.deathrattle;
                //this.description = c.description;
                this.Durability = c.Durability;
                this.Elite = c.Elite;
                this.Enrage = c.Enrage;
                this.Freeze = c.Freeze;
                this.GrantCharge = c.GrantCharge;
                this.HealTarget = c.HealTarget;
                this.Health = c.Health;
                this.immuneToSpellpowerg = c.immuneToSpellpowerg;
                this.immuneWhileAttacking = c.immuneWhileAttacking;
                this.Morph = c.Morph;
                this.name = c.name;
                this.needEmptyPlacesForPlaying = c.needEmptyPlacesForPlaying;
                this.needMinionsCapIfAvailable = c.needMinionsCapIfAvailable;
                this.needMinNumberOfEnemy = c.needMinNumberOfEnemy;
                this.needMinTotalMinions = c.needMinTotalMinions;
                this.needRaceForPlaying = c.needRaceForPlaying;
                this.needWithMaxAttackValueOf = c.needWithMaxAttackValueOf;
                this.needWithMinAttackValueOf = c.needWithMinAttackValueOf;
                this.oneTurnEffect = c.oneTurnEffect;
                this.playrequires = new List<ErrorType2>(c.playrequires);
                this.poisionous = c.poisionous;
                this.race = c.race;
                this.Recall = c.Recall;
                this.recallValue = c.recallValue;
                this.Secret = c.Secret;
                this.Shield = c.Shield;
                this.Silence = c.Silence;
                this.Spellpower = c.Spellpower;
                this.spellpowervalue = c.spellpowervalue;
                this.Stealth = c.Stealth;
                this.tank = c.tank;
                this.target = c.target;
                //this.targettext = c.targettext;
                this.type = c.type;
                this.windfury = c.windfury;
                this.cardIDenum = c.cardIDenum;
                this.sim_card = c.sim_card;
                this.isToken = c.isToken;
            }

            public bool isRequirementInList(CardDB.ErrorType2 et)
            {
                return this.playrequires.Contains(et);
            }

            public List<Minion> getTargetsForCard(Playfield p)
            {
                //todo make it faster!! 
                //todo remove the isRequirementInList with an big list of bools to ask the state of the bool
                bool addOwnHero = false;
                bool addEnemyHero = false;
                bool[] ownMins = new bool[p.ownMinions.Count];
                bool[] enemyMins = new bool[p.enemyMinions.Count];
                for (int i = 0; i < ownMins.Length; i++) ownMins[i] = false;
                for (int i = 0; i < enemyMins.Length; i++) enemyMins[i] = false;

                int k = 0;
                List<Minion> retval = new List<Minion>();

                if (isRequirementInList(CardDB.ErrorType2.REQ_TARGET_FOR_COMBO) && p.cardsPlayedThisTurn == 0) return retval;

                bool moreh = isRequirementInList(CardDB.ErrorType2.REQ_HERO_OR_MINION_TARGET);
                if (isRequirementInList(CardDB.ErrorType2.REQ_TARGET_TO_PLAY) || isRequirementInList(CardDB.ErrorType2.REQ_NONSELF_TARGET) || isRequirementInList(CardDB.ErrorType2.REQ_TARGET_IF_AVAILABLE) || isRequirementInList(CardDB.ErrorType2.REQ_TARGET_FOR_COMBO))
                {
                    addEnemyHero = true;
                    addOwnHero = true;

                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if ((this.type == cardtype.SPELL || this.type == cardtype.HEROPWR) && (m.cantBeTargetedBySpellsOrHeroPowers)) continue;
                        ownMins[k] = true;

                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if (((this.type == cardtype.SPELL || this.type == cardtype.HEROPWR) && (m.cantBeTargetedBySpellsOrHeroPowers)) || m.stealth) continue;
                        enemyMins[k] = true;
                    }

                }

                if (moreh)
                {
                    addEnemyHero = true;//moreh = req_minion_or_enemyHero
                    if (p.weHaveSteamwheedleSniper)
                    {
                        k = -1;
                        foreach (Minion m in p.ownMinions)
                        {
                            k++;
                            if ((this.type == cardtype.SPELL || this.type == cardtype.HEROPWR) && (m.cantBeTargetedBySpellsOrHeroPowers)) continue;
                            ownMins[k] = true;

                        }
                        k = -1;
                        foreach (Minion m in p.enemyMinions)
                        {
                            k++;
                            if (((this.type == cardtype.SPELL || this.type == cardtype.HEROPWR) && (m.cantBeTargetedBySpellsOrHeroPowers)) || m.stealth) continue;
                            enemyMins[k] = true;
                        }
                    }
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_HERO_TARGET))
                {
                    for (int i = 0; i < ownMins.Length; i++) ownMins[i] = false;
                    for (int i = 0; i < enemyMins.Length; i++) enemyMins[i] = false;

                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_MINION_TARGET))
                {
                    addOwnHero = false;
                    addEnemyHero = false;
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_FRIENDLY_TARGET))
                {
                    addEnemyHero = false;
                    for (int i = 0; i < enemyMins.Length; i++) enemyMins[i] = false;
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_ENEMY_TARGET))
                {
                    addOwnHero = false;
                    for (int i = 0; i < ownMins.Length; i++) ownMins[i] = false;
                }



                if (isRequirementInList(CardDB.ErrorType2.REQ_DAMAGED_TARGET))
                {
                    addEnemyHero = false;
                    addOwnHero = false;
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if (!m.wounded)
                        {
                            ownMins[k] = false;
                        }
                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if (!m.wounded)
                        {
                            enemyMins[k] = false;
                        }
                    }
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_UNDAMAGED_TARGET))
                {
                    addEnemyHero = false;
                    addOwnHero = false;
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if (m.wounded)
                        {
                            ownMins[k] = false;
                        }
                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if (m.wounded)
                        {
                            enemyMins[k] = false;
                        }
                    }
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_TARGET_MAX_ATTACK))
                {
                    addEnemyHero = false;
                    addOwnHero = false;
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if (m.Angr > this.needWithMaxAttackValueOf)
                        {
                            ownMins[k] = false;
                        }
                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if (m.Angr > this.needWithMaxAttackValueOf)
                        {
                            enemyMins[k] = false;
                        }
                    }
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_TARGET_MIN_ATTACK))
                {
                    addEnemyHero = false;
                    addOwnHero = false;
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if (m.Angr < this.needWithMinAttackValueOf)
                        {
                            ownMins[k] = false;
                        }
                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if (m.Angr < this.needWithMinAttackValueOf)
                        {
                            enemyMins[k] = false;
                        }
                    }
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_TARGET_WITH_RACE))
                {
                    addEnemyHero = false;
                    addOwnHero = false;
                    addOwnHero = (p.ownHeroName == HeroEnum.lordjaraxxus && (TAG_RACE)this.needRaceForPlaying == TAG_RACE.DEMON);
                    addEnemyHero = (p.enemyHeroName == HeroEnum.lordjaraxxus && (TAG_RACE)this.needRaceForPlaying == TAG_RACE.DEMON);
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if ((m.handcard.card.race != this.needRaceForPlaying))
                        {
                            ownMins[k] = false;
                        }
                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if ((m.handcard.card.race != this.needRaceForPlaying))
                        {
                            enemyMins[k] = false;
                        }
                    }
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_MUST_TARGET_TAUNTER))
                {
                    addEnemyHero = false;
                    addOwnHero = false;
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if (!m.taunt)
                        {
                            ownMins[k] = false;
                        }
                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if (!m.taunt)
                        {
                            enemyMins[k] = false;
                        }
                    }
                }

                if (addEnemyHero) retval.Add(p.enemyHero);
                if (addOwnHero) retval.Add(p.ownHero);

                k = -1;
                foreach (Minion m in p.ownMinions)
                {
                    k++;
                    if (ownMins[k]) retval.Add(m);
                }
                k = -1;
                foreach (Minion m in p.enemyMinions)
                {
                    k++;
                    if (enemyMins[k]) retval.Add(m);
                }

                return retval;

            }

            public List<Minion> getTargetsForCardEnemy(Playfield p)
            {
                //todo make it faster!! 
                //todo remove the isRequirementInList with an big list of bools to ask the state of the bool
                bool addOwnHero = false;
                bool addEnemyHero = false;
                bool[] ownMins = new bool[p.ownMinions.Count];
                bool[] enemyMins = new bool[p.enemyMinions.Count];
                for (int i = 0; i < ownMins.Length; i++) ownMins[i] = false;
                for (int i = 0; i < enemyMins.Length; i++) enemyMins[i] = false;

                int k = 0;
                List<Minion> retval = new List<Minion>();

                if (isRequirementInList(CardDB.ErrorType2.REQ_TARGET_FOR_COMBO) && p.cardsPlayedThisTurn == 0) return retval;

                bool moreh = isRequirementInList(CardDB.ErrorType2.REQ_HERO_OR_MINION_TARGET);
                if (isRequirementInList(CardDB.ErrorType2.REQ_TARGET_TO_PLAY) || isRequirementInList(CardDB.ErrorType2.REQ_NONSELF_TARGET) || isRequirementInList(CardDB.ErrorType2.REQ_TARGET_IF_AVAILABLE) || isRequirementInList(CardDB.ErrorType2.REQ_TARGET_FOR_COMBO))
                {
                    addEnemyHero = true;
                    addOwnHero = true;
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if (((this.type == cardtype.SPELL || this.type == cardtype.HEROPWR) && (m.cantBeTargetedBySpellsOrHeroPowers)) || m.stealth) continue;
                        ownMins[k] = true;

                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if ((this.type == cardtype.SPELL || this.type == cardtype.HEROPWR) && (m.cantBeTargetedBySpellsOrHeroPowers)) continue;
                        enemyMins[k] = true;
                    }

                }

                if (moreh)
                {
                    addOwnHero = true;

                    if (p.enemyHaveSteamwheedleSniper)
                    {
                        k = -1;
                        foreach (Minion m in p.ownMinions)
                        {
                            k++;
                            if (((this.type == cardtype.SPELL || this.type == cardtype.HEROPWR) && (m.cantBeTargetedBySpellsOrHeroPowers)) || m.stealth) continue;
                            ownMins[k] = true;

                        }

                    }
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_HERO_TARGET))
                {
                    for (int i = 0; i < ownMins.Length; i++) ownMins[i] = false;
                    for (int i = 0; i < enemyMins.Length; i++) enemyMins[i] = false;

                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_MINION_TARGET))
                {
                    addOwnHero = false;
                    addEnemyHero = false;
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_FRIENDLY_TARGET))
                {
                    addOwnHero = false;
                    for (int i = 0; i < ownMins.Length; i++) ownMins[i] = false;

                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_ENEMY_TARGET))
                {
                    addEnemyHero = false;
                    for (int i = 0; i < enemyMins.Length; i++) enemyMins[i] = false;
                }



                if (isRequirementInList(CardDB.ErrorType2.REQ_DAMAGED_TARGET))
                {
                    addEnemyHero = false;
                    addOwnHero = false;
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if (!m.wounded)
                        {
                            ownMins[k] = false;
                        }
                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if (!m.wounded)
                        {
                            enemyMins[k] = false;
                        }
                    }
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_UNDAMAGED_TARGET))
                {
                    addEnemyHero = false;
                    addOwnHero = false;
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if (m.wounded)
                        {
                            ownMins[k] = false;
                        }
                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if (m.wounded)
                        {
                            enemyMins[k] = false;
                        }
                    }
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_TARGET_MAX_ATTACK))
                {
                    addEnemyHero = false;
                    addOwnHero = false;
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if (m.Angr > this.needWithMaxAttackValueOf)
                        {
                            ownMins[k] = false;
                        }
                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if (m.Angr > this.needWithMaxAttackValueOf)
                        {
                            enemyMins[k] = false;
                        }
                    }
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_TARGET_MIN_ATTACK))
                {
                    addEnemyHero = false;
                    addOwnHero = false;
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if (m.Angr < this.needWithMinAttackValueOf)
                        {
                            ownMins[k] = false;
                        }
                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if (m.Angr < this.needWithMinAttackValueOf)
                        {
                            enemyMins[k] = false;
                        }
                    }
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_TARGET_WITH_RACE))
                {
                    addEnemyHero = false;
                    addOwnHero = false;
                    addOwnHero = (p.ownHeroName == HeroEnum.lordjaraxxus && (TAG_RACE)this.needRaceForPlaying == TAG_RACE.DEMON);
                    addEnemyHero = (p.enemyHeroName == HeroEnum.lordjaraxxus && (TAG_RACE)this.needRaceForPlaying == TAG_RACE.DEMON);
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if ((m.handcard.card.race != this.needRaceForPlaying))
                        {
                            ownMins[k] = false;
                        }
                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if ((m.handcard.card.race != this.needRaceForPlaying))
                        {
                            enemyMins[k] = false;
                        }
                    }
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_MUST_TARGET_TAUNTER))
                {
                    addEnemyHero = false;
                    addOwnHero = false;
                    k = -1;
                    foreach (Minion m in p.ownMinions)
                    {
                        k++;
                        if (!m.taunt)
                        {
                            ownMins[k] = false;
                        }
                    }
                    k = -1;
                    foreach (Minion m in p.enemyMinions)
                    {
                        k++;
                        if (!m.taunt)
                        {
                            enemyMins[k] = false;
                        }
                    }
                }

                if (addEnemyHero) retval.Add(p.enemyHero);
                if (addOwnHero) retval.Add(p.ownHero);

                k = -1;
                foreach (Minion m in p.ownMinions)
                {
                    k++;
                    if (ownMins[k]) retval.Add(m);
                }
                k = -1;
                foreach (Minion m in p.enemyMinions)
                {
                    k++;
                    if (enemyMins[k]) retval.Add(m);
                }

                return retval;

            }

            public int calculateManaCost(Playfield p)//calculates the mana from orginal mana, needed for back-to hand effects
            {
                int retval = this.cost;
                int offset = 0;

                if (this.type == cardtype.MOB)
                {
                    offset += p.soeldnerDerVenture * 3;

                    offset += p.managespenst;

                    int temp = -(p.startedWithbeschwoerungsportal) * 2;
                    if (retval + temp <= 0) temp = -retval + 1;
                    offset = offset + temp;

                    if (p.mobsplayedThisTurn == 0)
                    {
                        offset -= p.winzigebeschwoererin;
                    }

                    if (this.battlecry)
                    {
                        offset += p.nerubarweblord * 2;
                    }

                    if ((TAG_RACE)this.race == TAG_RACE.MECHANICAL)
                    { //if the number of zauberlehrlings change
                        offset -= p.anzOwnMechwarper;
                    }

                }

                if (this.type == cardtype.SPELL)
                { //if the number of zauberlehrlings change
                    offset -= (p.anzOwnsorcerersapprentice);
                    if (p.playedPreparation)
                    { //if the number of zauberlehrlings change
                        offset -= 3;
                    }

                }

                switch (this.name)
                {
                    case CardDB.cardName.dreadcorsair:
                        retval = retval + offset - p.ownWeaponAttack;
                        break;
                    case CardDB.cardName.seagiant:
                        retval = retval + offset - p.ownMinions.Count - p.enemyMinions.Count;
                        break;
                    case CardDB.cardName.mountaingiant:
                        retval = retval + offset - p.owncards.Count;
                        break;
                    case CardDB.cardName.clockworkgiant:
                        retval = retval + offset - p.enemyAnzCards;
                        break;
                    case CardDB.cardName.moltengiant:
                        retval = retval + offset - p.ownHero.Hp;
                        break;
                    case CardDB.cardName.crush:
                        // cost 4 less if we have a dmged minion
                        bool dmgedminions = false;
                        foreach (Minion m in p.ownMinions)
                        {
                            if (m.wounded) dmgedminions = true;
                        }
                        if (dmgedminions)
                        {
                            retval = retval + offset - 4;
                        }
                        break;
                    default:
                        retval = retval + offset;
                        break;
                }

                if (this.Secret && p.playedmagierinderkirintor)
                {
                    retval = 0;
                }

                retval = Math.Max(0, retval);

                return retval;
            }

            public int getManaCost(Playfield p, int currentcost)//calculates mana from current mana
            {
                int retval = currentcost;


                int offset = 0; // if offset < 0 costs become lower, if >0 costs are higher at the end

                // CARDS that increase the manacosts of others ##############################
                //Manacosts changes with soeldner der venture co.
                if (p.soeldnerDerVenture != p.startedWithsoeldnerDerVenture && this.type == cardtype.MOB)
                {
                    offset += (p.soeldnerDerVenture - p.startedWithsoeldnerDerVenture) * 3;
                }

                //Manacosts changes with mana-ghost
                if (p.managespenst != p.startedWithManagespenst && this.type == cardtype.MOB)
                {
                    offset += (p.managespenst - p.startedWithManagespenst);
                }

                if (this.battlecry && p.nerubarweblord != p.startedWithnerubarweblord && this.type == cardtype.MOB)
                {
                    offset += (p.nerubarweblord - p.startedWithnerubarweblord) * 2;
                }


                // CARDS that decrease the manacosts of others ##############################

                //Manacosts changes with the summoning-portal >_>
                if (p.startedWithbeschwoerungsportal != p.beschwoerungsportal && this.type == cardtype.MOB)
                { //cant lower the mana to 0
                    int temp = (p.startedWithbeschwoerungsportal - p.beschwoerungsportal) * 2;
                    if (retval + temp <= 0) temp = -retval + 1;
                    offset = offset + temp;
                }

                //Manacosts changes with the pint-sized summoner
                if (p.winzigebeschwoererin >= 1 && p.mobsplayedThisTurn >= 1 && p.startedWithMobsPlayedThisTurn == 0 && this.type == cardtype.MOB)
                { // if we start oure calculations with 0 mobs played, then the cardcost are 1 mana to low in the further calculations (with the little summoner on field)
                    offset += p.winzigebeschwoererin;
                }
                if (p.mobsplayedThisTurn == 0 && p.winzigebeschwoererin <= p.startedWithWinzigebeschwoererin && this.type == cardtype.MOB)
                { // one pint-sized summoner got killed, before we played the first mob -> the manacost are higher of all mobs
                    offset += (p.startedWithWinzigebeschwoererin - p.winzigebeschwoererin);
                }

                //Manacosts changes with the zauberlehrling summoner
                if (p.anzOwnsorcerersapprentice != p.anzOwnsorcerersapprenticeStarted && this.type == cardtype.SPELL)
                { //if the number of zauberlehrlings change
                    offset += (p.anzOwnsorcerersapprenticeStarted - p.anzOwnsorcerersapprentice);
                }

                //manacosts changes with Mechwarper
                if (p.anzOwnMechwarper != p.anzOwnMechwarperStarted && this.type == cardtype.MOB && (TAG_RACE)this.race == TAG_RACE.MECHANICAL)
                { //if the number of zauberlehrlings change
                    offset += (p.anzOwnMechwarperStarted - p.anzOwnMechwarper);
                }


                //manacosts are lowered, after we played preparation
                if (p.playedPreparation && this.type == cardtype.SPELL)
                { //if the number of zauberlehrlings change
                    offset -= 3;
                }


                switch (this.name)
                {
                    case CardDB.cardName.dreadcorsair:
                        retval = retval + offset - p.ownWeaponAttack + p.ownWeaponAttackStarted; // if weapon attack change we change manacost
                        break;
                    case CardDB.cardName.seagiant:
                        retval = retval + offset - p.ownMinions.Count - p.enemyMinions.Count + p.ownMobsCountStarted;
                        break;
                    case CardDB.cardName.mountaingiant:
                        retval = retval + offset - p.owncards.Count + p.ownCardsCountStarted;
                        break;
                    case CardDB.cardName.clockworkgiant:
                        retval = retval + offset - p.enemyAnzCards + p.enemyCardsCountStarted;
                        break;
                    case CardDB.cardName.moltengiant:
                        retval = retval + offset - p.ownHero.Hp + p.ownHeroHpStarted;
                        break;
                    case CardDB.cardName.crush:
                        // cost 4 less if we have a dmged minion
                        bool dmgedminions = false;
                        foreach (Minion m in p.ownMinions)
                        {
                            if (m.wounded) dmgedminions = true;
                        }
                        if (dmgedminions != p.startedWithDamagedMinions)
                        {
                            if (dmgedminions)
                            {
                                retval = retval + offset - 4;
                            }
                            else
                            {
                                retval = retval + offset + 4;
                            }
                        }
                        break;
                    default:
                        retval = retval + offset;
                        break;
                }

                if (this.Secret && p.playedmagierinderkirintor)
                {
                    retval = 0;
                }

                retval = Math.Max(0, retval);

                return retval;
            }

            public bool canplayCard(Playfield p, int manacost)
            {
                //is playrequirement?
                bool haveToDoRequires = isRequirementInList(CardDB.ErrorType2.REQ_TARGET_TO_PLAY);
                bool retval = true;
                // cant play if i have to few mana

                if (p.mana < this.getManaCost(p, manacost)) return false;

                // cant play mob, if i have allready 7 mininos
                if (this.type == CardDB.cardtype.MOB && p.ownMinions.Count >= 7) return false;

                if (isRequirementInList(CardDB.ErrorType2.REQ_MINIMUM_ENEMY_MINIONS))
                {
                    if (p.enemyMinions.Count < this.needMinNumberOfEnemy) return false;
                }
                if (isRequirementInList(CardDB.ErrorType2.REQ_NUM_MINION_SLOTS))
                {
                    if (p.ownMinions.Count > 7 - this.needEmptyPlacesForPlaying) return false;
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_WEAPON_EQUIPPED))
                {
                    if (p.ownWeaponName == CardDB.cardName.unknown) return false;
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_MINIMUM_TOTAL_MINIONS))
                {
                    if (this.needMinTotalMinions > p.ownMinions.Count + p.enemyMinions.Count) return false;
                }

                if (haveToDoRequires)
                {
                    if (this.getTargetsForCard(p).Count == 0) return false;

                    //it requires a target-> return false if 
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_TARGET_IF_AVAILABLE) && isRequirementInList(CardDB.ErrorType2.REQ_MINION_CAP_IF_TARGET_AVAILABLE))
                {
                    if (this.getTargetsForCard(p).Count >= 1 && p.ownMinions.Count > 7 - this.needMinionsCapIfAvailable) return false;
                }

                if (isRequirementInList(CardDB.ErrorType2.REQ_ENTIRE_ENTOURAGE_NOT_IN_PLAY))
                {
                    int difftotem = 0;
                    foreach (Minion m in p.ownMinions)
                    {
                        if (m.name == CardDB.cardName.healingtotem || m.name == CardDB.cardName.wrathofairtotem || m.name == CardDB.cardName.searingtotem || m.name == CardDB.cardName.stoneclawtotem) difftotem++;
                    }
                    if (difftotem == 4) return false;
                }


                if (this.Secret)
                {
                    if (p.ownSecretsIDList.Contains(this.cardIDenum)) return false;
                    if (p.ownSecretsIDList.Count >= 5) return false;
                }


                return true;
            }



        }

        List<string> namelist = new List<string>();
        List<Card> cardlist = new List<Card>();
        Dictionary<cardIDEnum, Card> cardidToCardList = new Dictionary<cardIDEnum, Card>();
        List<string> allCardIDS = new List<string>();
        public Card unknownCard;
        public bool installedWrong = false;

        public Card teacherminion;
        public Card illidanminion;
        public Card lepergnome;
        public Card burlyrockjaw;
        private static CardDB instance;

        public static CardDB Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new CardDB();
                    //instance.enumCreator();// only call this to get latest cardids
                    /*foreach (KeyValuePair<cardIDEnum, Card> kvp in instance.cardidToCardList)
                    {
                        Helpfunctions.Instance.logg(kvp.Value.name + " " + kvp.Value.Attack);
                    }*/
                    // have to do it 2 times (or the kids inside the simcards will not have a simcard :D
                    foreach (Card c in instance.cardlist)
                    {
                        c.sim_card = instance.getSimCard(c.cardIDenum);
                    }
                    instance.setAdditionalData();
                }
                return instance;
            }
        }

        private CardDB()
        {
            string[] lines = new string[0] { };
            try
            {
                string path = Settings.Instance.path;
                lines = System.IO.File.ReadAllLines(path + "_carddb.txt");
                Helpfunctions.Instance.ErrorLog("read carddb.txt");
            }
            catch
            {
                Helpfunctions.Instance.logg("cant find _carddb.txt");
                Helpfunctions.Instance.ErrorLog("ERROR#################################################");
                Helpfunctions.Instance.ErrorLog("ERROR#################################################");
                Helpfunctions.Instance.ErrorLog("ERROR#################################################");
                Helpfunctions.Instance.ErrorLog("ERROR#################################################");
                Helpfunctions.Instance.ErrorLog("cant find _carddb.txt in " + Settings.Instance.path);
                Helpfunctions.Instance.ErrorLog("ERROR#################################################");
                Helpfunctions.Instance.ErrorLog("ERROR#################################################");
                Helpfunctions.Instance.ErrorLog("ERROR#################################################");
                Helpfunctions.Instance.ErrorLog("ERROR#################################################");
                Helpfunctions.Instance.ErrorLog("you installed it wrong");
                Helpfunctions.Instance.ErrorLog("ERROR#################################################");
                Helpfunctions.Instance.ErrorLog("ERROR#################################################");
                Helpfunctions.Instance.ErrorLog("ERROR#################################################");
                Helpfunctions.Instance.ErrorLog("ERROR#################################################");
                this.installedWrong = true;
            }
            cardlist.Clear();
            this.cardidToCardList.Clear();
            Card c = new Card();
            int de = 0;
            //placeholdercard
            Card plchldr = new Card { name = cardName.unknown, cost = 1000 };
            this.namelist.Add("unknown");
            this.cardlist.Add(plchldr);
            this.unknownCard = cardlist[0];
            string name = "";
            foreach (string s in lines)
            {
                if (s.Contains("/Entity"))
                {
                    if (c.type == cardtype.ENCHANTMENT)
                    {
                        //Helpfunctions.Instance.logg(c.CardID);
                        //Helpfunctions.Instance.logg(c.name);
                        //Helpfunctions.Instance.logg(c.description);
                        continue;
                    }
                    if (name != "")
                    {
                        this.namelist.Add(name);
                    }
                    name = "";
                    if (c.name != CardDB.cardName.unknown)
                    {

                        this.cardlist.Add(c);
                        //Helpfunctions.Instance.logg(c.name);

                        if (!this.cardidToCardList.ContainsKey(c.cardIDenum))
                        {
                            this.cardidToCardList.Add(c.cardIDenum, c);
                        }
                    }

                }
                if (s.Contains("<Entity version=\"") && s.Contains(" CardID=\""))
                {
                    c = new Card();
                    de = 0;
                    string temp = s.Split(new string[] { "CardID=\"" }, StringSplitOptions.None)[1];
                    temp = temp.Replace("\">", "");
                    //c.CardID = temp;
                    allCardIDS.Add(temp);
                    c.cardIDenum = this.cardIdstringToEnum(temp);

                    //token:
                    if (temp.EndsWith("t"))
                    {
                        c.isToken = true;
                    }
                    if (temp.Equals("ds1_whelptoken")) c.isToken = true;
                    if (temp.Equals("CS2_mirror")) c.isToken = true;
                    if (temp.Equals("CS2_050")) c.isToken = true;
                    if (temp.Equals("CS2_052")) c.isToken = true;
                    if (temp.Equals("CS2_051")) c.isToken = true;
                    if (temp.Equals("NEW1_009")) c.isToken = true;
                    if (temp.Equals("CS2_152")) c.isToken = true;
                    if (temp.Equals("CS2_boar")) c.isToken = true;
                    if (temp.Equals("EX1_tk11")) c.isToken = true;
                    if (temp.Equals("EX1_506a")) c.isToken = true;
                    if (temp.Equals("skele21")) c.isToken = true;
                    if (temp.Equals("EX1_tk9")) c.isToken = true;
                    if (temp.Equals("EX1_finkle")) c.isToken = true;
                    if (temp.Equals("EX1_598")) c.isToken = true;
                    if (temp.Equals("EX1_tk34")) c.isToken = true;
                    //if (c.isToken) Helpfunctions.Instance.ErrorLog(temp +" is token");

                    continue;
                }
                /*
                if (s.Contains("<Entity version=\"1\" CardID=\""))
                {
                    c = new Card();
                    de = 0;
                    string temp = s.Replace("<Entity version=\"1\" CardID=\"", "");
                    temp = temp.Replace("\">", "");
                    //c.CardID = temp;
                    allCardIDS.Add(temp);
                    c.cardIDenum = this.cardIdstringToEnum(temp);
                    continue;
                }*/

                //health
                if (s.Contains("<Tag enumID=\"45\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.Health = Convert.ToInt32(temp);
                    continue;
                }

                //Class
                if (s.Contains("Tag enumID=\"199\"")) //added fopr sake of figure out which class it belongs too... sorry adds a little more data
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.Class = Convert.ToInt32(temp);
                    continue;
                }

                //attack
                if (s.Contains("<Tag enumID=\"47\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.Attack = Convert.ToInt32(temp);
                    continue;
                }
                //race
                if (s.Contains("<Tag enumID=\"200\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.race = Convert.ToInt32(temp);
                    continue;
                }
                //rarity
                if (s.Contains("<Tag enumID=\"203\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.rarity = Convert.ToInt32(temp);
                    continue;
                }
                //manacost
                if (s.Contains("<Tag enumID=\"48\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.cost = Convert.ToInt32(temp);
                    continue;
                }
                //cardtype
                if (s.Contains("<Tag enumID=\"202\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    if (c.name != CardDB.cardName.unknown)
                    {
                        //Helpfunctions.Instance.logg(temp);
                    }

                    int crdtype = Convert.ToInt32(temp);
                    if (crdtype == 10)
                    {
                        c.type = CardDB.cardtype.HEROPWR;
                    }
                    if (crdtype == 4)
                    {
                        c.type = CardDB.cardtype.MOB;
                    }
                    if (crdtype == 5)
                    {
                        c.type = CardDB.cardtype.SPELL;
                    }
                    if (crdtype == 6)
                    {
                        c.type = CardDB.cardtype.ENCHANTMENT;
                    }
                    if (crdtype == 7)
                    {
                        c.type = CardDB.cardtype.WEAPON;
                    }
                    continue;
                }

                //cardname
                if (s.Contains("<Tag enumID=\"185\""))
                {
                    string temp = s.Split(new string[] { "type=\"String\">" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split(new string[] { "</Tag>" }, StringSplitOptions.RemoveEmptyEntries)[0];
                    temp = temp.Replace("&lt;", "");
                    temp = temp.Replace("b&gt;", "");
                    temp = temp.Replace("/b&gt;", "");
                    temp = temp.ToLower();

                    temp = temp.Replace("'", "");
                    temp = temp.Replace(" ", "");
                    temp = temp.Replace(":", "");
                    temp = temp.Replace(".", "");
                    temp = temp.Replace("!", "");
                    temp = temp.Replace("-", "");

                    //Helpfunctions.Instance.logg(temp);
                    c.name = this.cardNamestringToEnum(temp);
                    name = temp;


                    continue;
                }

                //cardtextinhand
                if (s.Contains("<Tag enumID=\"184\""))
                {
                    string temp = s.Split(new string[] { "type=\"String\">" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split(new string[] { "</Tag>" }, StringSplitOptions.RemoveEmptyEntries)[0];
                    temp = temp.Replace("&lt;", "");
                    temp = temp.Replace("b&gt;", "");
                    temp = temp.Replace("/b&gt;", "");
                    temp = temp.ToLower();

                    if (temp.Contains("choose one"))
                    {
                        c.choice = true;
                        //Helpfunctions.Instance.logg(c.name + " is choice");
                    }
                    continue;
                }
                //targetingarrowtext
                if (s.Contains("<Tag enumID=\"325\""))
                {

                    string temp = s.Split(new string[] { "type=\"String\">" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split(new string[] { "</Tag>" }, StringSplitOptions.RemoveEmptyEntries)[0];
                    temp = temp.Replace("&lt;", "");
                    temp = temp.Replace("b&gt;", "");
                    temp = temp.Replace("/b&gt;", "");
                    temp = temp.ToLower();

                    c.target = true;
                    continue;
                }


                //poisonous
                if (s.Contains("<Tag enumID=\"363\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.poisionous = true;
                    continue;
                }
                //enrage
                if (s.Contains("<Tag enumID=\"212\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Enrage = true;
                    continue;
                }
                //OneTurnEffect
                if (s.Contains("<Tag enumID=\"338\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.oneTurnEffect = true;
                    continue;
                }
                //aura
                if (s.Contains("<Tag enumID=\"362\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Aura = true;
                    continue;
                }

                //taunt
                if (s.Contains("<Tag enumID=\"190\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.tank = true;
                    continue;
                }
                //battlecry
                if (s.Contains("<Tag enumID=\"218\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.battlecry = true;
                    continue;
                }
                //windfury
                if (s.Contains("<Tag enumID=\"189\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.windfury = true;
                    continue;
                }
                //deathrattle
                if (s.Contains("<Tag enumID=\"217\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.deathrattle = true;
                    continue;
                }
                //durability
                if (s.Contains("<Tag enumID=\"187\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.Durability = Convert.ToInt32(temp);
                    continue;
                }
                //elite
                if (s.Contains("<Tag enumID=\"114\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Elite = true;
                    continue;
                }
                //combo
                if (s.Contains("<Tag enumID=\"220\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Combo = true;
                    continue;
                }
                //recall
                if (s.Contains("<Tag enumID=\"215\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Recall = true;
                    c.recallValue = 1;
                    if (c.name == CardDB.cardName.forkedlightning) c.recallValue = 2;
                    if (c.name == CardDB.cardName.dustdevil) c.recallValue = 2;
                    if (c.name == CardDB.cardName.lightningstorm) c.recallValue = 2;
                    if (c.name == CardDB.cardName.lavaburst) c.recallValue = 2;
                    if (c.name == CardDB.cardName.feralspirit) c.recallValue = 2;
                    if (c.name == CardDB.cardName.doomhammer) c.recallValue = 2;
                    if (c.name == CardDB.cardName.earthelemental) c.recallValue = 3;
                    continue;
                }
                //immunetospellpower
                if (s.Contains("<Tag enumID=\"349\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.immuneToSpellpowerg = true;
                    continue;
                }
                //stealh
                if (s.Contains("<Tag enumID=\"191\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Stealth = true;
                    continue;
                }
                //secret
                if (s.Contains("<Tag enumID=\"219\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Secret = true;
                    continue;
                }
                //freeze
                if (s.Contains("<Tag enumID=\"208\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Freeze = true;
                    continue;
                }
                //adjacentbuff
                if (s.Contains("<Tag enumID=\"350\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.AdjacentBuff = true;
                    continue;
                }
                //divineshield
                if (s.Contains("<Tag enumID=\"194\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Shield = true;
                    continue;
                }
                //charge
                if (s.Contains("<Tag enumID=\"197\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Charge = true;
                    continue;
                }
                //silence
                if (s.Contains("<Tag enumID=\"339\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Silence = true;
                    continue;
                }
                //morph
                if (s.Contains("<Tag enumID=\"293\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Morph = true;
                    continue;
                }
                //spellpower
                if (s.Contains("<Tag enumID=\"192\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.Spellpower = true;
                    c.spellpowervalue = 1;
                    if (c.name == CardDB.cardName.ancientmage) c.spellpowervalue = 0;
                    if (c.name == CardDB.cardName.malygos) c.spellpowervalue = 5;
                    continue;
                }
                //grantcharge
                if (s.Contains("<Tag enumID=\"355\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.GrantCharge = true;
                    continue;
                }
                //healtarget
                if (s.Contains("<Tag enumID=\"361\""))
                {
                    string temp = s.Split(new string[] { "value=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    int ti = Convert.ToInt32(temp);
                    if (ti == 1) c.HealTarget = true;
                    continue;
                }
                if (s.Contains("<PlayRequirement"))
                {
                    //if (!s.Contains("param=\"\"")) Console.WriteLine(s);

                    string temp = s.Split(new string[] { "reqID=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    ErrorType2 et2 = (ErrorType2)Convert.ToInt32(temp);
                    c.playrequires.Add(et2);
                }


                if (s.Contains("<PlayRequirement reqID=\"12\" param=\""))
                {
                    string temp = s.Split(new string[] { "param=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.needEmptyPlacesForPlaying = Convert.ToInt32(temp);
                    continue;
                }
                if (s.Contains("PlayRequirement reqID=\"41\" param=\""))
                {
                    string temp = s.Split(new string[] { "param=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.needWithMinAttackValueOf = Convert.ToInt32(temp);
                    continue;
                }
                if (s.Contains("PlayRequirement reqID=\"8\" param=\""))
                {
                    string temp = s.Split(new string[] { "param=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.needWithMaxAttackValueOf = Convert.ToInt32(temp);
                    continue;
                }
                if (s.Contains("PlayRequirement reqID=\"10\" param=\""))
                {
                    string temp = s.Split(new string[] { "param=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.needRaceForPlaying = Convert.ToInt32(temp);
                    continue;
                }
                if (s.Contains("PlayRequirement reqID=\"23\" param=\""))
                {
                    string temp = s.Split(new string[] { "param=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.needMinNumberOfEnemy = Convert.ToInt32(temp);
                    continue;
                }
                if (s.Contains("PlayRequirement reqID=\"45\" param=\""))
                {
                    string temp = s.Split(new string[] { "param=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.needMinTotalMinions = Convert.ToInt32(temp);
                    continue;
                }
                if (s.Contains("PlayRequirement reqID=\"19\" param=\""))
                {
                    string temp = s.Split(new string[] { "param=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    c.needMinionsCapIfAvailable = Convert.ToInt32(temp);
                    continue;
                }



                if (s.Contains("<Tag name="))
                {
                    string temp = s.Split(new string[] { "<Tag name=\"" }, StringSplitOptions.RemoveEmptyEntries)[1];
                    temp = temp.Split('\"')[0];
                    /*
                    if (temp != "DevState" && temp != "FlavorText" && temp != "ArtistName" && temp != "Cost" && temp != "EnchantmentIdleVisual" && temp != "EnchantmentBirthVisual" && temp != "Collectible" && temp != "CardSet" && temp != "AttackVisualType" && temp != "CardName" && temp != "Class" && temp != "CardTextInHand" && temp != "Rarity" && temp != "TriggerVisual" && temp != "Faction" && temp != "HowToGetThisGoldCard" && temp != "HowToGetThisCard" && temp != "CardTextInPlay")
                        Helpfunctions.Instance.logg(s);*/
                }


            }

            this.teacherminion = this.getCardDataFromID(CardDB.cardIDEnum.NEW1_026t);
            this.illidanminion = this.getCardDataFromID(CardDB.cardIDEnum.EX1_614t);
            this.lepergnome = this.getCardDataFromID(CardDB.cardIDEnum.EX1_029);
            this.burlyrockjaw = this.getCardDataFromID(CardDB.cardIDEnum.GVG_068);

        }

        public Card getCardData(CardDB.cardName cardname)
        {

            foreach (Card ca in this.cardlist)
            {
                if (ca.name == cardname)
                {
                    return ca;
                }
            }

            return unknownCard;
        }

        public Card getCardDataFromID(cardIDEnum id)
        {
            return this.cardidToCardList.ContainsKey(id) ? this.cardidToCardList[id] : this.unknownCard;
        }

        public SimTemplate getSimCard(cardIDEnum id)
        {
            switch (id)
            {
                case cardIDEnum.NEW1_007b:
                    return new Sim_NEW1_007b();
                case cardIDEnum.EX1_613:
                    return new Sim_EX1_613();
                case cardIDEnum.EX1_133:
                    return new Sim_EX1_133();
                case cardIDEnum.NEW1_018:
                    return new Sim_NEW1_018();
                case cardIDEnum.EX1_012:
                    return new Sim_EX1_012();
                case cardIDEnum.EX1_178a:
                    return new Sim_EX1_178a();
                case cardIDEnum.CS2_231:
                    return new Sim_CS2_231();
                case cardIDEnum.CS2_179:
                    return new Sim_CS2_179();
                case cardIDEnum.EX1_244:
                    return new Sim_EX1_244();
                case cardIDEnum.EX1_178b:
                    return new Sim_EX1_178b();
                case cardIDEnum.EX1_573b:
                    return new Sim_EX1_573b();
                case cardIDEnum.NEW1_007a:
                    return new Sim_NEW1_007a();
                case cardIDEnum.EX1_345t:
                    return new Sim_EX1_345t();
                case cardIDEnum.FP1_007t:
                    return new Sim_FP1_007t();
                case cardIDEnum.EX1_025:
                    return new Sim_EX1_025();
                case cardIDEnum.EX1_396:
                    return new Sim_EX1_396();
                case cardIDEnum.NEW1_017:
                    return new Sim_NEW1_017();
                case cardIDEnum.NEW1_008a:
                    return new Sim_NEW1_008a();
                case cardIDEnum.EX1_533:
                    return new Sim_EX1_533();
                case cardIDEnum.EX1_522:
                    return new Sim_EX1_522();

                // case CardDB.cardIDEnum.NAX11_04: return new Sim_NAX11_04();
                case cardIDEnum.NEW1_026:
                    return new Sim_NEW1_026();
                case cardIDEnum.EX1_398:
                    return new Sim_EX1_398();

                // case CardDB.cardIDEnum.NAX4_04: return new Sim_NAX4_04();
                case cardIDEnum.EX1_007:
                    return new Sim_EX1_007();
                case cardIDEnum.CS1_112:
                    return new Sim_CS1_112();
                case cardIDEnum.NEW1_036:
                    return new Sim_NEW1_036();
                case cardIDEnum.EX1_258:
                    return new Sim_EX1_258();
                case cardIDEnum.HERO_01:
                    return new Sim_HERO_01();
                case cardIDEnum.CS2_087:
                    return new Sim_CS2_087();
                case cardIDEnum.DREAM_05:
                    return new Sim_DREAM_05();
                case cardIDEnum.CS2_092:
                    return new Sim_CS2_092();
                case cardIDEnum.CS2_022:
                    return new Sim_CS2_022();
                case cardIDEnum.EX1_046:
                    return new Sim_EX1_046();
                case cardIDEnum.PRO_001b:
                    return new Sim_PRO_001b();
                case cardIDEnum.PRO_001a:
                    return new Sim_PRO_001a();
                case cardIDEnum.CS2_103:
                    return new Sim_CS2_103();
                case cardIDEnum.NEW1_041:
                    return new Sim_NEW1_041();
                case cardIDEnum.EX1_360:
                    return new Sim_EX1_360();
                case cardIDEnum.FP1_023:
                    return new Sim_FP1_023();
                case cardIDEnum.NEW1_038:
                    return new Sim_NEW1_038();
                case cardIDEnum.CS2_009:
                    return new Sim_CS2_009();
                case cardIDEnum.EX1_010:
                    return new Sim_EX1_010();
                case cardIDEnum.CS2_024:
                    return new Sim_CS2_024();
                case cardIDEnum.EX1_565:
                    return new Sim_EX1_565();
                case cardIDEnum.CS2_076:
                    return new Sim_CS2_076();
                case cardIDEnum.FP1_004:
                    return new Sim_FP1_004();
                case cardIDEnum.CS2_162:
                    return new Sim_CS2_162();
                case cardIDEnum.EX1_110t:
                    return new Sim_EX1_110t();
                case cardIDEnum.CS2_181:
                    return new Sim_CS2_181();
                case cardIDEnum.EX1_309:
                    return new Sim_EX1_309();
                case cardIDEnum.EX1_354:
                    return new Sim_EX1_354();
                case cardIDEnum.EX1_023:
                    return new Sim_EX1_023();
                case cardIDEnum.NEW1_034:
                    return new Sim_NEW1_034();
                case cardIDEnum.CS2_003:
                    return new Sim_CS2_003();
                case cardIDEnum.HERO_06:
                    return new Sim_HERO_06();
                case cardIDEnum.CS2_201:
                    return new Sim_CS2_201();
                case cardIDEnum.EX1_508:
                    return new Sim_EX1_508();
                case cardIDEnum.EX1_259:
                    return new Sim_EX1_259();
                case cardIDEnum.EX1_341:
                    return new Sim_EX1_341();
                case cardIDEnum.EX1_103:
                    return new Sim_EX1_103();
                case cardIDEnum.FP1_021:
                    return new Sim_FP1_021();
                case cardIDEnum.EX1_411:
                    return new Sim_EX1_411();
                case cardIDEnum.CS2_053:
                    return new Sim_CS2_053();
                case cardIDEnum.CS2_182:
                    return new Sim_CS2_182();
                case cardIDEnum.CS2_008:
                    return new Sim_CS2_008();
                case cardIDEnum.CS2_233:
                    return new Sim_CS2_233();
                case cardIDEnum.EX1_626:
                    return new Sim_EX1_626();
                case cardIDEnum.EX1_059:
                    return new Sim_EX1_059();
                case cardIDEnum.EX1_334:
                    return new Sim_EX1_334();
                case cardIDEnum.EX1_619:
                    return new Sim_EX1_619();
                case cardIDEnum.NEW1_032:
                    return new Sim_NEW1_032();
                case cardIDEnum.EX1_158t:
                    return new Sim_EX1_158t();
                case cardIDEnum.EX1_006:
                    return new Sim_EX1_006();
                case cardIDEnum.NEW1_031:
                    return new Sim_NEW1_031();
                case cardIDEnum.DREAM_04:
                    return new Sim_DREAM_04();
                case cardIDEnum.EX1_004:
                    return new Sim_EX1_004();
                case cardIDEnum.EX1_095:
                    return new Sim_EX1_095();
                case cardIDEnum.NEW1_007:
                    return new Sim_NEW1_007();
                case cardIDEnum.EX1_275:
                    return new Sim_EX1_275();
                case cardIDEnum.EX1_245:
                    return new Sim_EX1_245();
                case cardIDEnum.EX1_383:
                    return new Sim_EX1_383();
                case cardIDEnum.FP1_016:
                    return new Sim_FP1_016();
                case cardIDEnum.CS2_125:
                    return new Sim_CS2_125();
                case cardIDEnum.EX1_137:
                    return new Sim_EX1_137();
                case cardIDEnum.DS1_185:
                    return new Sim_DS1_185();
                case cardIDEnum.FP1_010:
                    return new Sim_FP1_010();
                case cardIDEnum.EX1_598:
                    return new Sim_EX1_598();
                case cardIDEnum.EX1_304:
                    return new Sim_EX1_304();
                case cardIDEnum.EX1_302:
                    return new Sim_EX1_302();
                case cardIDEnum.EX1_614t:
                    return new Sim_EX1_614t();
                case cardIDEnum.CS2_108:
                    return new Sim_CS2_108();
                case cardIDEnum.CS2_046:
                    return new Sim_CS2_046();
                case cardIDEnum.EX1_014t:
                    return new Sim_EX1_014t();
                case cardIDEnum.NEW1_005:
                    return new Sim_NEW1_005();
                case cardIDEnum.EX1_062:
                    return new Sim_EX1_062();
                case cardIDEnum.Mekka1:
                    return new Sim_Mekka1();
                case cardIDEnum.tt_010a:
                    return new Sim_tt_010a();
                case cardIDEnum.CS2_072:
                    return new Sim_CS2_072();
                case cardIDEnum.EX1_tk28:
                    return new Sim_EX1_tk28();
                case cardIDEnum.FP1_014:
                    return new Sim_FP1_014();
                case cardIDEnum.EX1_409t:
                    return new Sim_EX1_409t();
                case cardIDEnum.EX1_507:
                    return new Sim_EX1_507();
                case cardIDEnum.EX1_144:
                    return new Sim_EX1_144();
                case cardIDEnum.CS2_038:
                    return new Sim_CS2_038();
                case cardIDEnum.EX1_093:
                    return new Sim_EX1_093();
                case cardIDEnum.CS2_080:
                    return new Sim_CS2_080();
                case cardIDEnum.EX1_005:
                    return new Sim_EX1_005();
                case cardIDEnum.EX1_382:
                    return new Sim_EX1_382();
                case cardIDEnum.CS2_028:
                    return new Sim_CS2_028();
                case cardIDEnum.EX1_538:
                    return new Sim_EX1_538();
                case cardIDEnum.DREAM_02:
                    return new Sim_DREAM_02();
                case cardIDEnum.EX1_581:
                    return new Sim_EX1_581();
                case cardIDEnum.EX1_131t:
                    return new Sim_EX1_131t();
                case cardIDEnum.CS2_147:
                    return new Sim_CS2_147();
                case cardIDEnum.CS1_113:
                    return new Sim_CS1_113();
                case cardIDEnum.CS2_161:
                    return new Sim_CS2_161();
                case cardIDEnum.CS2_031:
                    return new Sim_CS2_031();
                case cardIDEnum.EX1_166b:
                    return new Sim_EX1_166b();
                case cardIDEnum.EX1_066:
                    return new Sim_EX1_066();
                case cardIDEnum.EX1_355:
                    return new Sim_EX1_355();
                case cardIDEnum.EX1_534:
                    return new Sim_EX1_534();
                case cardIDEnum.EX1_162:
                    return new Sim_EX1_162();
                case cardIDEnum.EX1_363:
                    return new Sim_EX1_363();
                case cardIDEnum.EX1_164a:
                    return new Sim_EX1_164a();
                case cardIDEnum.CS2_188:
                    return new Sim_CS2_188();
                case cardIDEnum.EX1_016:
                    return new Sim_EX1_016();
                case cardIDEnum.EX1_603:
                    return new Sim_EX1_603();
                case cardIDEnum.EX1_238:
                    return new Sim_EX1_238();
                case cardIDEnum.EX1_166:
                    return new Sim_EX1_166();
                case cardIDEnum.DS1h_292:
                    return new Sim_DS1h_292();
                case cardIDEnum.DS1_183:
                    return new Sim_DS1_183();
                case cardIDEnum.EX1_076:
                    return new Sim_EX1_076();
                case cardIDEnum.EX1_048:
                    return new Sim_EX1_048();
                case cardIDEnum.FP1_026:
                    return new Sim_FP1_026();
                case cardIDEnum.CS2_074:
                    return new Sim_CS2_074();
                case cardIDEnum.FP1_027:
                    return new Sim_FP1_027();
                case cardIDEnum.EX1_323w:
                    return new Sim_EX1_323w();
                case cardIDEnum.EX1_129:
                    return new Sim_EX1_129();
                case cardIDEnum.EX1_405:
                    return new Sim_EX1_405();
                case cardIDEnum.EX1_317:
                    return new Sim_EX1_317();
                case cardIDEnum.EX1_606:
                    return new Sim_EX1_606();
                case cardIDEnum.FP1_006:
                    return new Sim_FP1_006();
                case cardIDEnum.NEW1_008:
                    return new Sim_NEW1_008();
                case cardIDEnum.CS2_119:
                    return new Sim_CS2_119();
                case cardIDEnum.CS2_121:
                    return new Sim_CS2_121();
                case cardIDEnum.CS1h_001:
                    return new Sim_CS1h_001();
                case cardIDEnum.EX1_tk34:
                    return new Sim_EX1_tk34();
                case cardIDEnum.NEW1_020:
                    return new Sim_NEW1_020();
                case cardIDEnum.CS2_196:
                    return new Sim_CS2_196();
                case cardIDEnum.EX1_312:
                    return new Sim_EX1_312();
                case cardIDEnum.FP1_022:
                    return new Sim_FP1_022();
                case cardIDEnum.EX1_160b:
                    return new Sim_EX1_160b();
                case cardIDEnum.EX1_563:
                    return new Sim_EX1_563();
                case cardIDEnum.FP1_031:
                    return new Sim_FP1_031();
                case cardIDEnum.NEW1_029:
                    return new Sim_NEW1_029();
                case cardIDEnum.CS1_129:
                    return new Sim_CS1_129();
                case cardIDEnum.HERO_03:
                    return new Sim_HERO_03();
                case cardIDEnum.Mekka4t:
                    return new Sim_Mekka4t();
                case cardIDEnum.EX1_158:
                    return new Sim_EX1_158();
                case cardIDEnum.NEW1_025:
                    return new Sim_NEW1_025();
                case cardIDEnum.FP1_012t:
                    return new Sim_FP1_012t();
                case cardIDEnum.EX1_083:
                    return new Sim_EX1_083();
                case cardIDEnum.EX1_295:
                    return new Sim_EX1_295();
                case cardIDEnum.EX1_407:
                    return new Sim_EX1_407();
                case cardIDEnum.NEW1_004:
                    return new Sim_NEW1_004();
                case cardIDEnum.FP1_019:
                    return new Sim_FP1_019();
                case cardIDEnum.PRO_001at:
                    return new Sim_PRO_001at();
                case cardIDEnum.EX1_625t:
                    return new Sim_EX1_625t();
                case cardIDEnum.EX1_014:
                    return new Sim_EX1_014();
                case cardIDEnum.CS2_097:
                    return new Sim_CS2_097();
                case cardIDEnum.EX1_558:
                    return new Sim_EX1_558();
                case cardIDEnum.EX1_tk29:
                    return new Sim_EX1_tk29();
                case cardIDEnum.CS2_186:
                    return new Sim_CS2_186();
                case cardIDEnum.EX1_084:
                    return new Sim_EX1_084();
                case cardIDEnum.NEW1_012:
                    return new Sim_NEW1_012();
                case cardIDEnum.FP1_014t:
                    return new Sim_FP1_014t();
                case cardIDEnum.EX1_578:
                    return new Sim_EX1_578();
                case cardIDEnum.CS2_221:
                    return new Sim_CS2_221();
                case cardIDEnum.EX1_019:
                    return new Sim_EX1_019();
                case cardIDEnum.FP1_019t:
                    return new Sim_FP1_019t();
                case cardIDEnum.EX1_132:
                    return new Sim_EX1_132();
                case cardIDEnum.EX1_284:
                    return new Sim_EX1_284();
                case cardIDEnum.EX1_105:
                    return new Sim_EX1_105();
                case cardIDEnum.NEW1_011:
                    return new Sim_NEW1_011();
                case cardIDEnum.EX1_017:
                    return new Sim_EX1_017();
                case cardIDEnum.EX1_249:
                    return new Sim_EX1_249();
                case cardIDEnum.FP1_002t:
                    return new Sim_FP1_002t();
                case cardIDEnum.EX1_313:
                    return new Sim_EX1_313();
                case cardIDEnum.EX1_155b:
                    return new Sim_EX1_155b();
                case cardIDEnum.NEW1_033:
                    return new Sim_NEW1_033();
                case cardIDEnum.CS2_106:
                    return new Sim_CS2_106();
                case cardIDEnum.FP1_018:
                    return new Sim_FP1_018();
                case cardIDEnum.DS1_233:
                    return new Sim_DS1_233();
                case cardIDEnum.DS1_175:
                    return new Sim_DS1_175();
                case cardIDEnum.NEW1_024:
                    return new Sim_NEW1_024();
                case cardIDEnum.CS2_189:
                    return new Sim_CS2_189();
                case cardIDEnum.NEW1_037:
                    return new Sim_NEW1_037();
                case cardIDEnum.EX1_414:
                    return new Sim_EX1_414();
                case cardIDEnum.EX1_538t:
                    return new Sim_EX1_538t();
                case cardIDEnum.EX1_586:
                    return new Sim_EX1_586();
                case cardIDEnum.EX1_310:
                    return new Sim_EX1_310();
                case cardIDEnum.NEW1_010:
                    return new Sim_NEW1_010();
                case cardIDEnum.EX1_534t:
                    return new Sim_EX1_534t();
                case cardIDEnum.FP1_028:
                    return new Sim_FP1_028();
                case cardIDEnum.EX1_604:
                    return new Sim_EX1_604();
                case cardIDEnum.EX1_160:
                    return new Sim_EX1_160();
                case cardIDEnum.EX1_165t1:
                    return new Sim_EX1_165t1();
                case cardIDEnum.CS2_062:
                    return new Sim_CS2_062();
                case cardIDEnum.CS2_155:
                    return new Sim_CS2_155();
                case cardIDEnum.CS2_213:
                    return new Sim_CS2_213();
                case cardIDEnum.CS2_004:
                    return new Sim_CS2_004();
                case cardIDEnum.CS2_023:
                    return new Sim_CS2_023();
                case cardIDEnum.EX1_164:
                    return new Sim_EX1_164();
                case cardIDEnum.EX1_009:
                    return new Sim_EX1_009();
                case cardIDEnum.FP1_007:
                    return new Sim_FP1_007();
                case cardIDEnum.EX1_345:
                    return new Sim_EX1_345();
                case cardIDEnum.EX1_116:
                    return new Sim_EX1_116();
                case cardIDEnum.EX1_399:
                    return new Sim_EX1_399();
                case cardIDEnum.EX1_587:
                    return new Sim_EX1_587();
                case cardIDEnum.EX1_571:
                    return new Sim_EX1_571();
                case cardIDEnum.EX1_335:
                    return new Sim_EX1_335();
                case cardIDEnum.HERO_08:
                    return new Sim_HERO_08();
                case cardIDEnum.EX1_166a:
                    return new Sim_EX1_166a();
                case cardIDEnum.EX1_finkle:
                    return new Sim_EX1_finkle();
                case cardIDEnum.EX1_164b:
                    return new Sim_EX1_164b();
                case cardIDEnum.EX1_283:
                    return new Sim_EX1_283();
                case cardIDEnum.EX1_339:
                    return new Sim_EX1_339();
                case cardIDEnum.EX1_531:
                    return new Sim_EX1_531();
                case cardIDEnum.EX1_134:
                    return new Sim_EX1_134();
                case cardIDEnum.EX1_350:
                    return new Sim_EX1_350();
                case cardIDEnum.EX1_308:
                    return new Sim_EX1_308();
                case cardIDEnum.CS2_197:
                    return new Sim_CS2_197();
                case cardIDEnum.skele21:
                    return new Sim_skele21();
                case cardIDEnum.FP1_013:
                    return new Sim_FP1_013();
                case cardIDEnum.EX1_509:
                    return new Sim_EX1_509();
                case cardIDEnum.EX1_612:
                    return new Sim_EX1_612();
                case cardIDEnum.EX1_021:
                    return new Sim_EX1_021();
                case cardIDEnum.CS2_226:
                    return new Sim_CS2_226();
                case cardIDEnum.EX1_608:
                    return new Sim_EX1_608();
                case cardIDEnum.EX1_624:
                    return new Sim_EX1_624();
                case cardIDEnum.EX1_616:
                    return new Sim_EX1_616();
                case cardIDEnum.EX1_008:
                    return new Sim_EX1_008();
                case cardIDEnum.PlaceholderCard:
                    return new Sim_PlaceholderCard();
                case cardIDEnum.EX1_045:
                    return new Sim_EX1_045();
                case cardIDEnum.EX1_015:
                    return new Sim_EX1_015();
                case cardIDEnum.CS2_171:
                    return new Sim_CS2_171();
                case cardIDEnum.CS2_041:
                    return new Sim_CS2_041();
                case cardIDEnum.EX1_128:
                    return new Sim_EX1_128();
                case cardIDEnum.CS2_112:
                    return new Sim_CS2_112();
                case cardIDEnum.HERO_07:
                    return new Sim_HERO_07();
                case cardIDEnum.EX1_412:
                    return new Sim_EX1_412();
                case cardIDEnum.CS2_117:
                    return new Sim_CS2_117();
                case cardIDEnum.EX1_562:
                    return new Sim_EX1_562();
                case cardIDEnum.EX1_055:
                    return new Sim_EX1_055();
                case cardIDEnum.FP1_012:
                    return new Sim_FP1_012();
                case cardIDEnum.EX1_317t:
                    return new Sim_EX1_317t();
                case cardIDEnum.EX1_278:
                    return new Sim_EX1_278();
                case cardIDEnum.CS2_tk1:
                    return new Sim_CS2_tk1();
                case cardIDEnum.EX1_590:
                    return new Sim_EX1_590();
                case cardIDEnum.CS1_130:
                    return new Sim_CS1_130();
                case cardIDEnum.NEW1_008b:
                    return new Sim_NEW1_008b();
                case cardIDEnum.EX1_365:
                    return new Sim_EX1_365();
                case cardIDEnum.CS2_141:
                    return new Sim_CS2_141();
                case cardIDEnum.PRO_001:
                    return new Sim_PRO_001();
                case cardIDEnum.CS2_173:
                    return new Sim_CS2_173();
                case cardIDEnum.CS2_017:
                    return new Sim_CS2_017();
                case cardIDEnum.EX1_392:
                    return new Sim_EX1_392();
                case cardIDEnum.EX1_593:
                    return new Sim_EX1_593();
                case cardIDEnum.EX1_049:
                    return new Sim_EX1_049();
                case cardIDEnum.EX1_002:
                    return new Sim_EX1_002();
                case cardIDEnum.CS2_056:
                    return new Sim_CS2_056();
                case cardIDEnum.EX1_596:
                    return new Sim_EX1_596();
                case cardIDEnum.EX1_136:
                    return new Sim_EX1_136();
                case cardIDEnum.EX1_323:
                    return new Sim_EX1_323();
                case cardIDEnum.CS2_073:
                    return new Sim_CS2_073();
                case cardIDEnum.EX1_001:
                    return new Sim_EX1_001();
                case cardIDEnum.EX1_044:
                    return new Sim_EX1_044();
                case cardIDEnum.Mekka4:
                    return new Sim_Mekka4();
                case cardIDEnum.CS2_142:
                    return new Sim_CS2_142();
                case cardIDEnum.EX1_573:
                    return new Sim_EX1_573();
                case cardIDEnum.FP1_009:
                    return new Sim_FP1_009();
                case cardIDEnum.CS2_050:
                    return new Sim_CS2_050();
                case cardIDEnum.EX1_390:
                    return new Sim_EX1_390();
                case cardIDEnum.EX1_610:
                    return new Sim_EX1_610();
                case cardIDEnum.hexfrog:
                    return new Sim_hexfrog();
                case cardIDEnum.CS2_082:
                    return new Sim_CS2_082();
                case cardIDEnum.NEW1_040:
                    return new Sim_NEW1_040();
                case cardIDEnum.DREAM_01:
                    return new Sim_DREAM_01();
                case cardIDEnum.EX1_595:
                    return new Sim_EX1_595();
                case cardIDEnum.CS2_013:
                    return new Sim_CS2_013();
                case cardIDEnum.CS2_077:
                    return new Sim_CS2_077();
                case cardIDEnum.NEW1_014:
                    return new Sim_NEW1_014();
                case cardIDEnum.GAME_002:
                    return new Sim_GAME_002();
                case cardIDEnum.EX1_165:
                    return new Sim_EX1_165();
                case cardIDEnum.CS2_013t:
                    return new Sim_CS2_013t();
                case cardIDEnum.EX1_tk11:
                    return new Sim_EX1_tk11();
                case cardIDEnum.EX1_591:
                    return new Sim_EX1_591();
                case cardIDEnum.EX1_549:
                    return new Sim_EX1_549();
                case cardIDEnum.CS2_045:
                    return new Sim_CS2_045();
                case cardIDEnum.CS2_237:
                    return new Sim_CS2_237();
                case cardIDEnum.CS2_027:
                    return new Sim_CS2_027();
                case cardIDEnum.CS2_101t:
                    return new Sim_CS2_101t();
                case cardIDEnum.CS2_063:
                    return new Sim_CS2_063();
                case cardIDEnum.EX1_145:
                    return new Sim_EX1_145();
                case cardIDEnum.EX1_110:
                    return new Sim_EX1_110();
                case cardIDEnum.EX1_408:
                    return new Sim_EX1_408();
                case cardIDEnum.EX1_544:
                    return new Sim_EX1_544();
                case cardIDEnum.CS2_151:
                    return new Sim_CS2_151();
                case cardIDEnum.CS2_088:
                    return new Sim_CS2_088();
                case cardIDEnum.EX1_057:
                    return new Sim_EX1_057();
                case cardIDEnum.FP1_020:
                    return new Sim_FP1_020();
                case cardIDEnum.CS2_169:
                    return new Sim_CS2_169();
                case cardIDEnum.EX1_573t:
                    return new Sim_EX1_573t();
                case cardIDEnum.EX1_323h:
                    return new Sim_EX1_323h();
                case cardIDEnum.EX1_tk9:
                    return new Sim_EX1_tk9();
                case cardIDEnum.CS2_037:
                    return new Sim_CS2_037();
                case cardIDEnum.CS2_007:
                    return new Sim_CS2_007();
                case cardIDEnum.CS2_227:
                    return new Sim_CS2_227();
                case cardIDEnum.NEW1_003:
                    return new Sim_NEW1_003();
                case cardIDEnum.GAME_006:
                    return new Sim_GAME_006();
                case cardIDEnum.EX1_320:
                    return new Sim_EX1_320();
                case cardIDEnum.EX1_097:
                    return new Sim_EX1_097();
                case cardIDEnum.tt_004:
                    return new Sim_tt_004();
                case cardIDEnum.EX1_096:
                    return new Sim_EX1_096();
                case cardIDEnum.EX1_126:
                    return new Sim_EX1_126();
                case cardIDEnum.EX1_577:
                    return new Sim_EX1_577();
                case cardIDEnum.EX1_319:
                    return new Sim_EX1_319();
                case cardIDEnum.EX1_611:
                    return new Sim_EX1_611();
                case cardIDEnum.CS2_146:
                    return new Sim_CS2_146();
                case cardIDEnum.EX1_154b:
                    return new Sim_EX1_154b();
                case cardIDEnum.skele11:
                    return new Sim_skele11();
                case cardIDEnum.EX1_165t2:
                    return new Sim_EX1_165t2();
                case cardIDEnum.CS2_172:
                    return new Sim_CS2_172();
                case cardIDEnum.CS2_114:
                    return new Sim_CS2_114();
                case cardIDEnum.CS1_069:
                    return new Sim_CS1_069();
                case cardIDEnum.EX1_173:
                    return new Sim_EX1_173();
                case cardIDEnum.CS1_042:
                    return new Sim_CS1_042();
                case cardIDEnum.EX1_506a:
                    return new Sim_EX1_506a();
                case cardIDEnum.EX1_298:
                    return new Sim_EX1_298();
                case cardIDEnum.CS2_104:
                    return new Sim_CS2_104();
                case cardIDEnum.FP1_001:
                    return new Sim_FP1_001();
                case cardIDEnum.HERO_02:
                    return new Sim_HERO_02();
                case cardIDEnum.CS2_051:
                    return new Sim_CS2_051();
                case cardIDEnum.NEW1_016:
                    return new Sim_NEW1_016();
                case cardIDEnum.EX1_033:
                    return new Sim_EX1_033();
                case cardIDEnum.EX1_028:
                    return new Sim_EX1_028();
                case cardIDEnum.EX1_621:
                    return new Sim_EX1_621();
                case cardIDEnum.EX1_554:
                    return new Sim_EX1_554();
                case cardIDEnum.EX1_091:
                    return new Sim_EX1_091();
                case cardIDEnum.FP1_017:
                    return new Sim_FP1_017();
                case cardIDEnum.EX1_409:
                    return new Sim_EX1_409();
                case cardIDEnum.EX1_410:
                    return new Sim_EX1_410();
                case cardIDEnum.CS2_039:
                    return new Sim_CS2_039();
                case cardIDEnum.EX1_557:
                    return new Sim_EX1_557();
                case cardIDEnum.DS1_070:
                    return new Sim_DS1_070();
                case cardIDEnum.CS2_033:
                    return new Sim_CS2_033();
                case cardIDEnum.EX1_536:
                    return new Sim_EX1_536();
                case cardIDEnum.EX1_559:
                    return new Sim_EX1_559();
                case cardIDEnum.CS2_052:
                    return new Sim_CS2_052();
                case cardIDEnum.EX1_539:
                    return new Sim_EX1_539();
                case cardIDEnum.EX1_575:
                    return new Sim_EX1_575();
                case cardIDEnum.CS2_083b:
                    return new Sim_CS2_083b();
                case cardIDEnum.CS2_061:
                    return new Sim_CS2_061();
                case cardIDEnum.NEW1_021:
                    return new Sim_NEW1_021();
                case cardIDEnum.DS1_055:
                    return new Sim_DS1_055();
                case cardIDEnum.EX1_625:
                    return new Sim_EX1_625();
                case cardIDEnum.CS2_026:
                    return new Sim_CS2_026();
                case cardIDEnum.EX1_294:
                    return new Sim_EX1_294();
                case cardIDEnum.EX1_287:
                    return new Sim_EX1_287();
                case cardIDEnum.EX1_625t2:
                    return new Sim_EX1_625t2();
                case cardIDEnum.CS2_118:
                    return new Sim_CS2_118();
                case cardIDEnum.CS2_124:
                    return new Sim_CS2_124();
                case cardIDEnum.Mekka3:
                    return new Sim_Mekka3();
                case cardIDEnum.EX1_112:
                    return new Sim_EX1_112();
                case cardIDEnum.FP1_011:
                    return new Sim_FP1_011();
                case cardIDEnum.HERO_04:
                    return new Sim_HERO_04();
                case cardIDEnum.EX1_607:
                    return new Sim_EX1_607();
                case cardIDEnum.DREAM_03:
                    return new Sim_DREAM_03();
                case cardIDEnum.FP1_003:
                    return new Sim_FP1_003();
                case cardIDEnum.CS2_105:
                    return new Sim_CS2_105();
                case cardIDEnum.FP1_002:
                    return new Sim_FP1_002();
                case cardIDEnum.EX1_567:
                    return new Sim_EX1_567();
                case cardIDEnum.FP1_008:
                    return new Sim_FP1_008();
                case cardIDEnum.DS1_184:
                    return new Sim_DS1_184();
                case cardIDEnum.CS2_029:
                    return new Sim_CS2_029();
                case cardIDEnum.GAME_005:
                    return new Sim_GAME_005();
                case cardIDEnum.CS2_187:
                    return new Sim_CS2_187();
                case cardIDEnum.EX1_020:
                    return new Sim_EX1_020();
                case cardIDEnum.EX1_011:
                    return new Sim_EX1_011();
                case cardIDEnum.CS2_057:
                    return new Sim_CS2_057();
                case cardIDEnum.EX1_274:
                    return new Sim_EX1_274();
                case cardIDEnum.EX1_306:
                    return new Sim_EX1_306();
                case cardIDEnum.EX1_170:
                    return new Sim_EX1_170();
                case cardIDEnum.EX1_617:
                    return new Sim_EX1_617();
                case cardIDEnum.CS2_101:
                    return new Sim_CS2_101();
                case cardIDEnum.FP1_015:
                    return new Sim_FP1_015();
                case cardIDEnum.CS2_005:
                    return new Sim_CS2_005();
                case cardIDEnum.EX1_537:
                    return new Sim_EX1_537();
                case cardIDEnum.EX1_384:
                    return new Sim_EX1_384();
                case cardIDEnum.EX1_362:
                    return new Sim_EX1_362();
                case cardIDEnum.EX1_301:
                    return new Sim_EX1_301();
                case cardIDEnum.CS2_235:
                    return new Sim_CS2_235();
                case cardIDEnum.EX1_029:
                    return new Sim_EX1_029();
                case cardIDEnum.CS2_042:
                    return new Sim_CS2_042();
                case cardIDEnum.EX1_155a:
                    return new Sim_EX1_155a();
                case cardIDEnum.CS2_102:
                    return new Sim_CS2_102();
                case cardIDEnum.EX1_609:
                    return new Sim_EX1_609();
                case cardIDEnum.NEW1_027:
                    return new Sim_NEW1_027();
                case cardIDEnum.EX1_165a:
                    return new Sim_EX1_165a();
                case cardIDEnum.EX1_570:
                    return new Sim_EX1_570();
                case cardIDEnum.EX1_131:
                    return new Sim_EX1_131();
                case cardIDEnum.EX1_556:
                    return new Sim_EX1_556();
                case cardIDEnum.EX1_543:
                    return new Sim_EX1_543();
                case cardIDEnum.NEW1_009:
                    return new Sim_NEW1_009();
                case cardIDEnum.EX1_100:
                    return new Sim_EX1_100();
                case cardIDEnum.EX1_573a:
                    return new Sim_EX1_573a();
                case cardIDEnum.CS2_084:
                    return new Sim_CS2_084();
                case cardIDEnum.EX1_582:
                    return new Sim_EX1_582();
                case cardIDEnum.EX1_043:
                    return new Sim_EX1_043();
                case cardIDEnum.EX1_050:
                    return new Sim_EX1_050();
                case cardIDEnum.FP1_005:
                    return new Sim_FP1_005();
                case cardIDEnum.EX1_620:
                    return new Sim_EX1_620();
                case cardIDEnum.EX1_303:
                    return new Sim_EX1_303();
                case cardIDEnum.HERO_09:
                    return new Sim_HERO_09();
                case cardIDEnum.EX1_067:
                    return new Sim_EX1_067();
                case cardIDEnum.EX1_277:
                    return new Sim_EX1_277();
                case cardIDEnum.Mekka2:
                    return new Sim_Mekka2();
                case cardIDEnum.FP1_024:
                    return new Sim_FP1_024();
                case cardIDEnum.FP1_030:
                    return new Sim_FP1_030();
                case cardIDEnum.EX1_178:
                    return new Sim_EX1_178();
                case cardIDEnum.CS2_222:
                    return new Sim_CS2_222();
                case cardIDEnum.EX1_160a:
                    return new Sim_EX1_160a();
                case cardIDEnum.CS2_012:
                    return new Sim_CS2_012();
                case cardIDEnum.EX1_246:
                    return new Sim_EX1_246();
                case cardIDEnum.EX1_572:
                    return new Sim_EX1_572();
                case cardIDEnum.EX1_089:
                    return new Sim_EX1_089();
                case cardIDEnum.CS2_059:
                    return new Sim_CS2_059();
                case cardIDEnum.EX1_279:
                    return new Sim_EX1_279();
                case cardIDEnum.CS2_168:
                    return new Sim_CS2_168();
                case cardIDEnum.tt_010:
                    return new Sim_tt_010();
                case cardIDEnum.NEW1_023:
                    return new Sim_NEW1_023();
                case cardIDEnum.CS2_075:
                    return new Sim_CS2_075();
                case cardIDEnum.EX1_316:
                    return new Sim_EX1_316();
                case cardIDEnum.CS2_025:
                    return new Sim_CS2_025();
                case cardIDEnum.CS2_234:
                    return new Sim_CS2_234();
                case cardIDEnum.EX1_130:
                    return new Sim_EX1_130();
                case cardIDEnum.CS2_064:
                    return new Sim_CS2_064();
                case cardIDEnum.EX1_161:
                    return new Sim_EX1_161();
                case cardIDEnum.CS2_049:
                    return new Sim_CS2_049();
                case cardIDEnum.EX1_154:
                    return new Sim_EX1_154();
                case cardIDEnum.EX1_080:
                    return new Sim_EX1_080();
                case cardIDEnum.NEW1_022:
                    return new Sim_NEW1_022();
                case cardIDEnum.EX1_251:
                    return new Sim_EX1_251();
                case cardIDEnum.FP1_025:
                    return new Sim_FP1_025();
                case cardIDEnum.EX1_371:
                    return new Sim_EX1_371();
                case cardIDEnum.CS2_mirror:
                    return new Sim_CS2_mirror();
                case cardIDEnum.EX1_594:
                    return new Sim_EX1_594();
                case cardIDEnum.EX1_560:
                    return new Sim_EX1_560();
                case cardIDEnum.CS2_236:
                    return new Sim_CS2_236();
                case cardIDEnum.EX1_402:
                    return new Sim_EX1_402();
                case cardIDEnum.EX1_506:
                    return new Sim_EX1_506();
                case cardIDEnum.DS1_178:
                    return new Sim_DS1_178();
                case cardIDEnum.EX1_315:
                    return new Sim_EX1_315();
                case cardIDEnum.CS2_094:
                    return new Sim_CS2_094();
                case cardIDEnum.NEW1_040t:
                    return new Sim_NEW1_040t();
                case cardIDEnum.CS2_131:
                    return new Sim_CS2_131();
                case cardIDEnum.EX1_082:
                    return new Sim_EX1_082();
                case cardIDEnum.CS2_093:
                    return new Sim_CS2_093();
                case cardIDEnum.CS2_boar:
                    return new Sim_CS2_boar();
                case cardIDEnum.NEW1_019:
                    return new Sim_NEW1_019();
                case cardIDEnum.EX1_289:
                    return new Sim_EX1_289();
                case cardIDEnum.EX1_025t:
                    return new Sim_EX1_025t();
                case cardIDEnum.EX1_398t:
                    return new Sim_EX1_398t();
                case cardIDEnum.CS2_091:
                    return new Sim_CS2_091();
                case cardIDEnum.EX1_241:
                    return new Sim_EX1_241();
                case cardIDEnum.EX1_085:
                    return new Sim_EX1_085();
                case cardIDEnum.CS2_200:
                    return new Sim_CS2_200();
                case cardIDEnum.CS2_034:
                    return new Sim_CS2_034();
                case cardIDEnum.EX1_583:
                    return new Sim_EX1_583();
                case cardIDEnum.EX1_584:
                    return new Sim_EX1_584();
                case cardIDEnum.EX1_155:
                    return new Sim_EX1_155();
                case cardIDEnum.EX1_622:
                    return new Sim_EX1_622();
                case cardIDEnum.CS2_203:
                    return new Sim_CS2_203();
                case cardIDEnum.EX1_124:
                    return new Sim_EX1_124();
                case cardIDEnum.EX1_379:
                    return new Sim_EX1_379();
                case cardIDEnum.EX1_032:
                    return new Sim_EX1_032();
                case cardIDEnum.EX1_391:
                    return new Sim_EX1_391();
                case cardIDEnum.EX1_366:
                    return new Sim_EX1_366();
                case cardIDEnum.EX1_400:
                    return new Sim_EX1_400();
                case cardIDEnum.EX1_614:
                    return new Sim_EX1_614();
                case cardIDEnum.EX1_561:
                    return new Sim_EX1_561();
                case cardIDEnum.EX1_332:
                    return new Sim_EX1_332();
                case cardIDEnum.HERO_05:
                    return new Sim_HERO_05();
                case cardIDEnum.CS2_065:
                    return new Sim_CS2_065();
                case cardIDEnum.ds1_whelptoken:
                    return new Sim_ds1_whelptoken();
                case cardIDEnum.CS2_032:
                    return new Sim_CS2_032();
                case cardIDEnum.CS2_120:
                    return new Sim_CS2_120();
                case cardIDEnum.EX1_247:
                    return new Sim_EX1_247();
                case cardIDEnum.EX1_154a:
                    return new Sim_EX1_154a();
                case cardIDEnum.EX1_554t:
                    return new Sim_EX1_554t();
                case cardIDEnum.NEW1_026t:
                    return new Sim_NEW1_026t();
                case cardIDEnum.EX1_623:
                    return new Sim_EX1_623();
                case cardIDEnum.EX1_383t:
                    return new Sim_EX1_383t();
                case cardIDEnum.EX1_597:
                    return new Sim_EX1_597();
                case cardIDEnum.EX1_130a:
                    return new Sim_EX1_130a();
                case cardIDEnum.CS2_011:
                    return new Sim_CS2_011();
                case cardIDEnum.EX1_169:
                    return new Sim_EX1_169();
                case cardIDEnum.EX1_tk33:
                    return new Sim_EX1_tk33();
                case cardIDEnum.EX1_250:
                    return new Sim_EX1_250();
                case cardIDEnum.EX1_564:
                    return new Sim_EX1_564();
                case cardIDEnum.EX1_349:
                    return new Sim_EX1_349();
                case cardIDEnum.EX1_102:
                    return new Sim_EX1_102();
                case cardIDEnum.EX1_058:
                    return new Sim_EX1_058();
                case cardIDEnum.EX1_243:
                    return new Sim_EX1_243();
                case cardIDEnum.PRO_001c:
                    return new Sim_PRO_001c();
                case cardIDEnum.EX1_116t:
                    return new Sim_EX1_116t();
                case cardIDEnum.FP1_029:
                    return new Sim_FP1_029();
                case cardIDEnum.CS2_089:
                    return new Sim_CS2_089();
                case cardIDEnum.EX1_248:
                    return new Sim_EX1_248();
                case cardIDEnum.CS2_122:
                    return new Sim_CS2_122();
                case cardIDEnum.EX1_393:
                    return new Sim_EX1_393();
                case cardIDEnum.CS2_232:
                    return new Sim_CS2_232();
                case cardIDEnum.EX1_165b:
                    return new Sim_EX1_165b();
                case cardIDEnum.NEW1_030:
                    return new Sim_NEW1_030();
                case cardIDEnum.CS2_150:
                    return new Sim_CS2_150();
                case cardIDEnum.CS2_152:
                    return new Sim_CS2_152();
                case cardIDEnum.EX1_160t:
                    return new Sim_EX1_160t();
                case cardIDEnum.CS2_127:
                    return new Sim_CS2_127();
                case cardIDEnum.DS1_188:
                    return new Sim_DS1_188();
                case CardDB.cardIDEnum.GVG_001:
                    return new Sim_GVG_001();
                case CardDB.cardIDEnum.GVG_002:
                    return new Sim_GVG_002();
                case CardDB.cardIDEnum.GVG_003:
                    return new Sim_GVG_003();
                case CardDB.cardIDEnum.GVG_004:
                    return new Sim_GVG_004();
                case CardDB.cardIDEnum.GVG_005:
                    return new Sim_GVG_005();
                case CardDB.cardIDEnum.GVG_006:
                    return new Sim_GVG_006();
                case CardDB.cardIDEnum.GVG_007:
                    return new Sim_GVG_007();
                case CardDB.cardIDEnum.GVG_008:
                    return new Sim_GVG_008();
                case CardDB.cardIDEnum.GVG_009:
                    return new Sim_GVG_009();
                case CardDB.cardIDEnum.GVG_010:
                    return new Sim_GVG_010();
                case CardDB.cardIDEnum.GVG_011:
                    return new Sim_GVG_011();
                case CardDB.cardIDEnum.GVG_012:
                    return new Sim_GVG_012();
                case CardDB.cardIDEnum.GVG_013:
                    return new Sim_GVG_013();
                case CardDB.cardIDEnum.GVG_014:
                    return new Sim_GVG_014();
                case CardDB.cardIDEnum.GVG_015:
                    return new Sim_GVG_015();
                case CardDB.cardIDEnum.GVG_016:
                    return new Sim_GVG_016();
                case CardDB.cardIDEnum.GVG_017:
                    return new Sim_GVG_017();
                case CardDB.cardIDEnum.GVG_018:
                    return new Sim_GVG_018();
                case CardDB.cardIDEnum.GVG_019:
                    return new Sim_GVG_019();
                case CardDB.cardIDEnum.GVG_020:
                    return new Sim_GVG_020();
                case CardDB.cardIDEnum.GVG_021:
                    return new Sim_GVG_021();
                case CardDB.cardIDEnum.GVG_022:
                    return new Sim_GVG_022();
                case CardDB.cardIDEnum.GVG_023:
                    return new Sim_GVG_023();
                case CardDB.cardIDEnum.GVG_024:
                    return new Sim_GVG_024();
                case CardDB.cardIDEnum.GVG_025:
                    return new Sim_GVG_025();
                case CardDB.cardIDEnum.GVG_026:
                    return new Sim_GVG_026();
                case CardDB.cardIDEnum.GVG_027:
                    return new Sim_GVG_027();
                case CardDB.cardIDEnum.GVG_028:
                    return new Sim_GVG_028();
                case CardDB.cardIDEnum.GVG_028t:
                    return new Sim_GVG_028t();
                case CardDB.cardIDEnum.GVG_029:
                    return new Sim_GVG_029();
                case CardDB.cardIDEnum.GVG_030:
                    return new Sim_GVG_030();
                case CardDB.cardIDEnum.GVG_030a:
                    return new Sim_GVG_030a();
                case CardDB.cardIDEnum.GVG_030b:
                    return new Sim_GVG_030b();
                case CardDB.cardIDEnum.GVG_031:
                    return new Sim_GVG_031();
                case CardDB.cardIDEnum.GVG_032:
                    return new Sim_GVG_032();
                case CardDB.cardIDEnum.GVG_032a:
                    return new Sim_GVG_032a();
                case CardDB.cardIDEnum.GVG_032b:
                    return new Sim_GVG_032b();
                case CardDB.cardIDEnum.GVG_033:
                    return new Sim_GVG_033();
                case CardDB.cardIDEnum.GVG_034:
                    return new Sim_GVG_034();
                case CardDB.cardIDEnum.GVG_035:
                    return new Sim_GVG_035();
                case CardDB.cardIDEnum.GVG_036:
                    return new Sim_GVG_036();
                case CardDB.cardIDEnum.GVG_037:
                    return new Sim_GVG_037();
                case CardDB.cardIDEnum.GVG_038:
                    return new Sim_GVG_038();
                case CardDB.cardIDEnum.GVG_039:
                    return new Sim_GVG_039();
                case CardDB.cardIDEnum.GVG_040:
                    return new Sim_GVG_040();
                case CardDB.cardIDEnum.GVG_041:
                    return new Sim_GVG_041();
                case CardDB.cardIDEnum.GVG_041a:
                    return new Sim_GVG_041a();
                case CardDB.cardIDEnum.GVG_041b:
                    return new Sim_GVG_041b();
                case CardDB.cardIDEnum.GVG_042:
                    return new Sim_GVG_042();
                case CardDB.cardIDEnum.GVG_043:
                    return new Sim_GVG_043();
                case CardDB.cardIDEnum.GVG_044:
                    return new Sim_GVG_044();
                case CardDB.cardIDEnum.GVG_045:
                    return new Sim_GVG_045();
                case CardDB.cardIDEnum.GVG_045t:
                    return new Sim_GVG_045t();
                case CardDB.cardIDEnum.GVG_046:
                    return new Sim_GVG_046();
                case CardDB.cardIDEnum.GVG_047:
                    return new Sim_GVG_047();
                case CardDB.cardIDEnum.GVG_048:
                    return new Sim_GVG_048();
                case CardDB.cardIDEnum.GVG_049:
                    return new Sim_GVG_049();
                case CardDB.cardIDEnum.GVG_050:
                    return new Sim_GVG_050();
                case CardDB.cardIDEnum.GVG_051:
                    return new Sim_GVG_051();
                case CardDB.cardIDEnum.GVG_052:
                    return new Sim_GVG_052();
                case CardDB.cardIDEnum.GVG_053:
                    return new Sim_GVG_053();
                case CardDB.cardIDEnum.GVG_054:
                    return new Sim_GVG_054();
                case CardDB.cardIDEnum.GVG_055:
                    return new Sim_GVG_055();
                case CardDB.cardIDEnum.GVG_056:
                    return new Sim_GVG_056();
                case CardDB.cardIDEnum.GVG_056t:
                    return new Sim_GVG_056t();
                case CardDB.cardIDEnum.GVG_057:
                    return new Sim_GVG_057();
                case CardDB.cardIDEnum.GVG_058:
                    return new Sim_GVG_058();
                case CardDB.cardIDEnum.GVG_059:
                    return new Sim_GVG_059();
                case CardDB.cardIDEnum.GVG_060:
                    return new Sim_GVG_060();
                case CardDB.cardIDEnum.GVG_061:
                    return new Sim_GVG_061();
                case CardDB.cardIDEnum.GVG_062:
                    return new Sim_GVG_062();
                case CardDB.cardIDEnum.GVG_063:
                    return new Sim_GVG_063();
                case CardDB.cardIDEnum.GVG_064:
                    return new Sim_GVG_064();
                case CardDB.cardIDEnum.GVG_065:
                    return new Sim_GVG_065();
                case CardDB.cardIDEnum.GVG_066:
                    return new Sim_GVG_066();
                case CardDB.cardIDEnum.GVG_067:
                    return new Sim_GVG_067();
                case CardDB.cardIDEnum.GVG_068:
                    return new Sim_GVG_068();
                case CardDB.cardIDEnum.GVG_069:
                    return new Sim_GVG_069();
                case CardDB.cardIDEnum.GVG_070:
                    return new Sim_GVG_070();
                case CardDB.cardIDEnum.GVG_071:
                    return new Sim_GVG_071();
                case CardDB.cardIDEnum.GVG_072:
                    return new Sim_GVG_072();
                case CardDB.cardIDEnum.GVG_073:
                    return new Sim_GVG_073();
                case CardDB.cardIDEnum.GVG_074:
                    return new Sim_GVG_074();
                case CardDB.cardIDEnum.GVG_075:
                    return new Sim_GVG_075();
                case CardDB.cardIDEnum.GVG_076:
                    return new Sim_GVG_076();
                case CardDB.cardIDEnum.GVG_077:
                    return new Sim_GVG_077();
                case CardDB.cardIDEnum.GVG_078:
                    return new Sim_GVG_078();
                case CardDB.cardIDEnum.GVG_079:
                    return new Sim_GVG_079();
                case CardDB.cardIDEnum.GVG_080:
                    return new Sim_GVG_080();
                case CardDB.cardIDEnum.GVG_080t:
                    return new Sim_GVG_080t();
                case CardDB.cardIDEnum.GVG_081:
                    return new Sim_GVG_081();
                case CardDB.cardIDEnum.GVG_082:
                    return new Sim_GVG_082();
                case CardDB.cardIDEnum.GVG_083:
                    return new Sim_GVG_083();
                case CardDB.cardIDEnum.GVG_084:
                    return new Sim_GVG_084();
                case CardDB.cardIDEnum.GVG_085:
                    return new Sim_GVG_085();
                case CardDB.cardIDEnum.GVG_086:
                    return new Sim_GVG_086();
                case CardDB.cardIDEnum.GVG_087:
                    return new Sim_GVG_087();
                case CardDB.cardIDEnum.GVG_088:
                    return new Sim_GVG_088();
                case CardDB.cardIDEnum.GVG_089:
                    return new Sim_GVG_089();
                case CardDB.cardIDEnum.GVG_090:
                    return new Sim_GVG_090();
                case CardDB.cardIDEnum.GVG_091:
                    return new Sim_GVG_091();
                case CardDB.cardIDEnum.GVG_092:
                    return new Sim_GVG_092();
                case CardDB.cardIDEnum.GVG_093:
                    return new Sim_GVG_093();
                case CardDB.cardIDEnum.GVG_094:
                    return new Sim_GVG_094();
                case CardDB.cardIDEnum.GVG_095:
                    return new Sim_GVG_095();
                case CardDB.cardIDEnum.GVG_096:
                    return new Sim_GVG_096();
                case CardDB.cardIDEnum.GVG_097:
                    return new Sim_GVG_097();
                case CardDB.cardIDEnum.GVG_098:
                    return new Sim_GVG_098();
                case CardDB.cardIDEnum.GVG_099:
                    return new Sim_GVG_099();
                case CardDB.cardIDEnum.GVG_100:
                    return new Sim_GVG_100();
                case CardDB.cardIDEnum.GVG_101:
                    return new Sim_GVG_101();
                case CardDB.cardIDEnum.GVG_102:
                    return new Sim_GVG_102();
                case CardDB.cardIDEnum.GVG_103:
                    return new Sim_GVG_103();
                case CardDB.cardIDEnum.GVG_104:
                    return new Sim_GVG_104();
                case CardDB.cardIDEnum.GVG_105:
                    return new Sim_GVG_105();
                case CardDB.cardIDEnum.GVG_106:
                    return new Sim_GVG_106();
                case CardDB.cardIDEnum.GVG_107:
                    return new Sim_GVG_107();
                case CardDB.cardIDEnum.GVG_108:
                    return new Sim_GVG_108();
                case CardDB.cardIDEnum.GVG_109:
                    return new Sim_GVG_109();
                case CardDB.cardIDEnum.GVG_110:
                    return new Sim_GVG_110();
                case CardDB.cardIDEnum.GVG_110t:
                    return new Sim_GVG_110t();
                case CardDB.cardIDEnum.GVG_111:
                    return new Sim_GVG_111();
                case CardDB.cardIDEnum.GVG_111t:
                    return new Sim_GVG_111t();
                case CardDB.cardIDEnum.GVG_112:
                    return new Sim_GVG_112();
                case CardDB.cardIDEnum.GVG_113:
                    return new Sim_GVG_113();
                case CardDB.cardIDEnum.GVG_114:
                    return new Sim_GVG_114();
                case CardDB.cardIDEnum.GVG_115:
                    return new Sim_GVG_115();
                case CardDB.cardIDEnum.GVG_116:
                    return new Sim_GVG_116();
                case CardDB.cardIDEnum.GVG_117:
                    return new Sim_GVG_117();
                case CardDB.cardIDEnum.GVG_118:
                    return new Sim_GVG_118();
                case CardDB.cardIDEnum.GVG_119:
                    return new Sim_GVG_119();
                case CardDB.cardIDEnum.GVG_120:
                    return new Sim_GVG_120();
                case CardDB.cardIDEnum.GVG_121:
                    return new Sim_GVG_121();
                case CardDB.cardIDEnum.GVG_122:
                    return new Sim_GVG_122();
                case CardDB.cardIDEnum.GVG_123:
                    return new Sim_GVG_123();
                case CardDB.cardIDEnum.PART_001:
                    return new Sim_PART_001();
                case CardDB.cardIDEnum.PART_002:
                    return new Sim_PART_002();
                case CardDB.cardIDEnum.PART_003:
                    return new Sim_PART_003();
                case CardDB.cardIDEnum.PART_004:
                    return new Sim_PART_004();
                case CardDB.cardIDEnum.PART_005:
                    return new Sim_PART_005();
                case CardDB.cardIDEnum.PART_006:
                    return new Sim_PART_006();
                case CardDB.cardIDEnum.PART_007:
                    return new Sim_PART_007();
            }

            return new SimTemplate();
        }

        private void enumCreator()
        {
            //call this, if carddb.txt was changed, to get latest public enum cardIDEnum
            Helpfunctions.Instance.logg("public enum cardIDEnum");
            Helpfunctions.Instance.logg("{");
            Helpfunctions.Instance.logg("None,");
            foreach (string cardid in this.allCardIDS)
            {
                Helpfunctions.Instance.logg(cardid + ",");
            }
            Helpfunctions.Instance.logg("}");



            Helpfunctions.Instance.logg("public cardIDEnum cardIdstringToEnum(string s)");
            Helpfunctions.Instance.logg("{");
            foreach (string cardid in this.allCardIDS)
            {
                Helpfunctions.Instance.logg("if(s==\"" + cardid + "\") return CardDB.cardIDEnum." + cardid + ";");
            }
            Helpfunctions.Instance.logg("return CardDB.cardIDEnum.None;");
            Helpfunctions.Instance.logg("}");

            List<string> namelist = new List<string>();

            foreach (string cardid in this.namelist)
            {
                if (namelist.Contains(cardid)) continue;
                namelist.Add(cardid);
            }


            Helpfunctions.Instance.logg("public enum cardName");
            Helpfunctions.Instance.logg("{");
            foreach (string cardid in namelist)
            {
                Helpfunctions.Instance.logg(cardid + ",");
            }
            Helpfunctions.Instance.logg("}");

            Helpfunctions.Instance.logg("public cardName cardNamestringToEnum(string s)");
            Helpfunctions.Instance.logg("{");
            foreach (string cardid in namelist)
            {
                Helpfunctions.Instance.logg("if(s==\"" + cardid + "\") return CardDB.cardName." + cardid + ";");
            }
            Helpfunctions.Instance.logg("return CardDB.cardName.unknown;");
            Helpfunctions.Instance.logg("}");

            // simcard creator:

            Helpfunctions.Instance.logg("public SimTemplate getSimCard(cardIDEnum id)");
            Helpfunctions.Instance.logg("{");
            foreach (string cardid in this.allCardIDS)
            {
                Helpfunctions.Instance.logg("if(id == CardDB.cardIDEnum." + cardid + ") return new Sim_" + cardid + "();");
            }
            Helpfunctions.Instance.logg("return new SimTemplate();");
            Helpfunctions.Instance.logg("}");

        }

        private void setAdditionalData()
        {
            PenalityManager pen = PenalityManager.Instance;

            foreach (Card c in this.cardlist)
            {
                if (pen.cardDrawBattleCryDatabase.ContainsKey(c.name))
                {
                    c.isCarddraw = pen.cardDrawBattleCryDatabase[c.name];
                }

                if (pen.DamageTargetSpecialDatabase.ContainsKey(c.name))
                {
                    c.damagesTargetWithSpecial = true;
                }

                if (pen.DamageTargetDatabase.ContainsKey(c.name))
                {
                    c.damagesTarget = true;
                }

                if (pen.priorityTargets.ContainsKey(c.name))
                {
                    c.targetPriority = pen.priorityTargets[c.name];
                }

                if (pen.specialMinions.ContainsKey(c.name))
                {
                    c.isSpecialMinion = true;
                }
            }
        }

    }

    public class BoardTester
    {

        public string evalFunction = "control";
        int maxwide = 3000;
        int twoturnsim = 256;
        bool simEnemy2Turn = false;
        int pprob1 = 50;
        int pprob2 = 80;
        bool playarround = false;

        int ownPlayer = 1;
        int enemmaxman = 0;

        Minion ownHero;
        Minion enemyHero;

        int ownHEntity = 0;
        int enemyHEntity = 1;

        int mana = 0;
        int maxmana = 0;
        string ownheroname = "";
        int ownherohp = 0;
        int ownheromaxhp = 30;
        int enemyheromaxhp = 30;
        int ownherodefence = 0;
        bool ownheroready = false;
        bool ownHeroimmunewhileattacking = false;
        int ownheroattacksThisRound = 0;
        int ownHeroAttack = 0;
        int ownHeroTempAttack = 0;
        string ownHeroWeapon = "";
        int ownHeroWeaponAttack = 0;
        int ownHeroWeaponDurability = 0;
        int numOptionPlayedThisTurn = 0;
        int numMinionsPlayedThisTurn = 0;
        int cardsPlayedThisTurn = 0;
        int overdrive = 0;

        int ownDecksize = 30;
        int enemyDecksize = 30;
        int ownFatigue = 0;
        int enemyFatigue = 0;

        bool heroImmune = false;
        bool enemyHeroImmune = false;

        int enemySecretAmount = 0;
        List<SecretItem> enemySecrets = new List<SecretItem>();

        bool ownHeroFrozen = false;

        List<string> ownsecretlist = new List<string>();
        string enemyheroname = "";
        int enemyherohp = 0;
        int enemyherodefence = 0;
        bool enemyFrozen = false;
        int enemyWeaponAttack = 0;
        int enemyWeaponDur = 0;
        string enemyWeapon = "";
        int enemyNumberHand = 5;

        List<Minion> ownminions = new List<Minion>();
        List<Minion> enemyminions = new List<Minion>();
        List<Handmanager.Handcard> handcards = new List<Handmanager.Handcard>();
        List<CardDB.cardIDEnum> enemycards = new List<CardDB.cardIDEnum>();
        List<GraveYardItem> turnGraveYard = new List<GraveYardItem>();

        bool feugendead = false;
        bool stalaggdead = false;
        public bool datareaded = false;

        public BoardTester(string data = "")
        {
            string og = "";
            string eg = "";

            string omd = "";
            string emd = "";

            int ets = 20;
            int ents = 20;

            int ntssw = 10;
            int ntssd = 6;
            int ntssm = 50;

            int alpha = 50;

            bool dosecrets = false;

            Settings.Instance.simulatePlacement = false;

            Hrtprozis.Instance.clearAll();
            Handmanager.Instance.clearAll();
            string[] lines = new string[0] { };
            if (data == "")
            {
                this.datareaded = false;
                try
                {
                    string path = Settings.Instance.path;
                    lines = System.IO.File.ReadAllLines(path + "test.txt");
                    this.datareaded = true;
                }
                catch
                {
                    this.datareaded = false;
                    Helpfunctions.Instance.logg("cant find test.txt");
                    Helpfunctions.Instance.ErrorLog("cant find test.txt");
                    return;
                }
            }
            else
            {
                this.datareaded = true;
                lines = data.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
            }

            CardDB.Card heroability = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_034);
            CardDB.Card enemyability = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_034);
            bool abilityReady = false;

            int readstate = 0;
            int counter = 0;

            Minion tempminion = new Minion();
            int j = 0;
            foreach (string sss in lines)
            {
                string s = sss + " ";
                Helpfunctions.Instance.logg(s);

                if (s.StartsWith("ailoop"))
                {
                    break;
                }
                if (s.StartsWith("####"))
                {
                    continue;
                }
                if (s.StartsWith("start calculations, current time: "))
                {
                    Ai.Instance.currentCalculatedBoard = s.Split(' ')[4].Split(' ')[0];

                    this.evalFunction = s.Split(' ')[6].Split(' ')[0];

                    this.maxwide = Convert.ToInt32(s.Split(' ')[7].Split(' ')[0]);

                    //following params are optional
                    this.twoturnsim = 256;
                    if (s.Contains("twoturnsim ")) this.twoturnsim = Convert.ToInt32(s.Split(new string[] { "twoturnsim " }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);

                    if (s.Contains(" face "))
                    {
                        string facehp = s.Split(new string[] { "face " }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0];
                        ComboBreaker.Instance.attackFaceHP = Convert.ToInt32(facehp);
                    }

                    this.playarround = false;
                    if (s.Contains("playaround "))
                    {
                        string probs = s.Split(new string[] { "playaround " }, StringSplitOptions.RemoveEmptyEntries)[1];
                        this.playarround = true;
                        this.pprob1 = Convert.ToInt32(probs.Split(' ')[0]);
                        this.pprob2 = Convert.ToInt32(probs.Split(' ')[1]);
                    }

                    if (s.Contains(" ets "))
                    {
                        string eturnsim = s.Split(new string[] { " ets " }, StringSplitOptions.RemoveEmptyEntries)[1];
                        ets = Convert.ToInt32(eturnsim.Split(' ')[0]);
                    }

                    if (s.Contains(" ets2 "))
                    {
                        string eturnsim2 = s.Split(new string[] { " ets2 " }, StringSplitOptions.RemoveEmptyEntries)[1];
                        int ets2 = Convert.ToInt32(eturnsim2.Split(' ')[0]);
                        Settings.Instance.enemyTurnMaxWideSecondTime = ets2;
                    }


                    if (s.Contains(" ents "))
                    {
                        this.simEnemy2Turn = true;
                        string eturnsim = s.Split(new string[] { " ents " }, StringSplitOptions.RemoveEmptyEntries)[1];
                        ents = Convert.ToInt32(eturnsim.Split(' ')[0]);
                    }

                    if (s.Contains(" ntss "))
                    {
                        string probs = s.Split(new string[] { " ntss " }, StringSplitOptions.RemoveEmptyEntries)[1];
                        ntssd = Convert.ToInt32(probs.Split(' ')[0]);
                        ntssw = Convert.ToInt32(probs.Split(' ')[1]);
                        ntssm = Convert.ToInt32(probs.Split(' ')[2]);
                    }

                    if (s.Contains(" secret")) dosecrets = true;

                    if (s.Contains(" weight "))
                    {
                        string alphaval = s.Split(new string[] { " weight " }, StringSplitOptions.RemoveEmptyEntries)[1];
                        alpha = Convert.ToInt32(alphaval.Split(' ')[0]);
                    }


                    if (s.Contains(" plcmnt"))
                    {
                        Settings.Instance.simulatePlacement = true;
                    }

                    continue;
                }

                if (s.StartsWith("enemy secretsCount:"))
                {
                    this.enemySecretAmount = Convert.ToInt32(s.Split(' ')[2]);
                    this.enemySecrets.Clear();
                    if (this.enemySecretAmount >= 1 && s.Contains(";"))
                    {
                        string secretstuff = s.Split(';')[1];
                        foreach (string sec in secretstuff.Split(','))
                        {
                            if (sec == "" || sec == String.Empty || sec == " ") continue;
                            this.enemySecrets.Add(new SecretItem(sec));
                        }

                    }
                    continue;
                }

                if (s.StartsWith("mana "))
                {
                    string ss = s.Replace("mana ", "");
                    mana = Convert.ToInt32(ss.Split('/')[0]);
                    maxmana = Convert.ToInt32(ss.Split('/')[1]);
                }

                if (s.StartsWith("emana "))
                {
                    string ss = s.Replace("emana ", "");
                    enemmaxman = Convert.ToInt32(ss);
                }

                if (s.StartsWith("Enemy cards: "))
                {
                    enemyNumberHand = Convert.ToInt32(s.Split(' ')[2]);
                    continue;
                }

                if (s.StartsWith("GraveYard:"))
                {
                    if (s.Contains("fgn")) this.feugendead = true;
                    if (s.Contains("stlgg")) this.stalaggdead = true;
                    continue;
                }

                if (s.StartsWith("osecrets: "))
                {
                    string secs = s.Replace("osecrets: ", "");
                    foreach (string sec in secs.Split(' '))
                    {
                        if (sec == "" || sec == string.Empty) continue;
                        this.ownsecretlist.Add(sec);
                    }
                    continue;
                }

                if (s.StartsWith("ownDiedMinions: "))
                {
                    omd = s;
                    continue;
                }

                if (s.StartsWith("enemyDiedMinions: "))
                {
                    emd = s;
                    continue;
                }



                if (s.StartsWith("probs: "))
                {
                    int i = 0;
                    foreach (string p in s.Split(' '))
                    {
                        if (p.StartsWith("probs:") || p == "" || p == null) continue;
                        int num = Convert.ToInt32(p);
                        CardDB.cardIDEnum c = CardDB.cardIDEnum.None;
                        if (i == 0)
                        {
                            if (this.enemyheroname == "mage")
                            {
                                c = CardDB.cardIDEnum.CS2_032;
                            }
                            if (this.enemyheroname == "warrior")
                            {
                                c = CardDB.cardIDEnum.EX1_400;
                            }

                            if (this.enemyheroname == "hunter")
                            {
                                c = CardDB.cardIDEnum.EX1_538;
                            }

                            if (this.enemyheroname == "priest")
                            {
                                c = CardDB.cardIDEnum.CS1_112;
                            }

                            if (this.enemyheroname == "shaman")
                            {
                                c = CardDB.cardIDEnum.EX1_259;
                            }

                            if (this.enemyheroname == "pala")
                            {
                                c = CardDB.cardIDEnum.CS2_093;
                            }

                            if (this.enemyheroname == "druid")
                            {
                                c = CardDB.cardIDEnum.CS2_012;
                            }
                        }

                        if (i == 1)
                        {
                            if (this.enemyheroname == "mage")
                            {
                                c = CardDB.cardIDEnum.CS2_028;
                            }
                        }

                        if (num == 1)
                        {
                            enemycards.Add(c);
                        }
                        if (num == 0)
                        {
                            enemycards.Add(c);
                            enemycards.Add(c);
                        }
                        i++;
                    }

                    Probabilitymaker.Instance.setEnemyCards(enemycards);
                    continue;
                }

                if (s.StartsWith("og:"))
                {
                    og = s;
                    continue;
                }
                if (s.StartsWith("eg:"))
                {
                    eg = s;
                    continue;
                }

                if (readstate == 42 && counter == 1) // player
                {
                    this.overdrive = Convert.ToInt32(s.Split(' ')[2]);
                    this.numMinionsPlayedThisTurn = Convert.ToInt32(s.Split(' ')[0]);
                    this.cardsPlayedThisTurn = Convert.ToInt32(s.Split(' ')[1]);
                    this.ownPlayer = Convert.ToInt32(s.Split(' ')[3]);
                }

                if (readstate == 1 && counter == 1) // class + hp + defence + immunewhile attacking + immune
                {
                    ownheroname = s.Split(' ')[0];
                    ownherohp = Convert.ToInt32(s.Split(' ')[1]);
                    ownheromaxhp = Convert.ToInt32(s.Split(' ')[2]);
                    ownherodefence = Convert.ToInt32(s.Split(' ')[3]);
                    this.ownHeroimmunewhileattacking = (s.Split(' ')[4] == "True") ? true : false;
                    this.heroImmune = (s.Split(' ')[5] == "True") ? true : false;
                    ownHEntity = Convert.ToInt32(s.Split(' ')[6]);
                    ownheroready = (s.Split(' ')[7] == "True") ? true : false;
                    ownheroattacksThisRound = Convert.ToInt32(s.Split(' ')[8]);
                    ownHeroFrozen = (s.Split(' ')[9] == "True") ? true : false;
                    ownHeroAttack = Convert.ToInt32(s.Split(' ')[10]);
                    ownHeroTempAttack = Convert.ToInt32(s.Split(' ')[11]);

                }

                if (readstate == 1 && counter == 2) // own hero weapon
                {
                    ownHeroWeaponAttack = Convert.ToInt32(s.Split(' ')[1]);
                    this.ownHeroWeaponDurability = Convert.ToInt32(s.Split(' ')[2]);
                    if (ownHeroWeaponAttack == 0)
                    {
                        ownHeroWeapon = ""; //:D
                    }
                    else
                    {
                        ownHeroWeapon = s.Split(' ')[3];
                    }
                }

                if (readstate == 1 && counter == 3) // ability + abilityready
                {
                    abilityReady = (s.Split(' ')[1] == "True");
                    heroability = CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(s.Split(' ')[2]));
                }

                if (readstate == 1 && counter >= 5) // secrets
                {
                    if (!s.StartsWith("enemyhero:"))
                    {
                        ownsecretlist.Add(s.Replace(" ", ""));
                    }
                }

                if (readstate == 2 && counter == 1) // class + hp + defence + frozen + immune
                {
                    enemyheroname = s.Split(' ')[0];
                    enemyherohp = Convert.ToInt32(s.Split(' ')[1]);
                    enemyheromaxhp = Convert.ToInt32(s.Split(' ')[2]);
                    enemyherodefence = Convert.ToInt32(s.Split(' ')[3]);
                    enemyFrozen = (s.Split(' ')[4] == "True") ? true : false;
                    enemyHeroImmune = (s.Split(' ')[5] == "True") ? true : false;
                    enemyHEntity = Convert.ToInt32(s.Split(' ')[6]);
                }

                if (readstate == 2 && counter == 2) // wepon + stuff
                {
                    this.enemyWeaponAttack = Convert.ToInt32(s.Split(' ')[1]);
                    this.enemyWeaponDur = Convert.ToInt32(s.Split(' ')[2]);
                    if (enemyWeaponDur == 0)
                    {
                        this.enemyWeapon = "";
                    }
                    else
                    {
                        this.enemyWeapon = s.Split(' ')[3];
                    }

                }
                if (readstate == 2 && counter == 3) // ability
                {
                    enemyability = CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(s.Split(' ')[2]));
                }
                if (readstate == 2 && counter == 4) // fatigue
                {
                    this.ownDecksize = Convert.ToInt32(s.Split(' ')[1]);
                    this.enemyDecksize = Convert.ToInt32(s.Split(' ')[3]);
                    this.ownFatigue = Convert.ToInt32(s.Split(' ')[2]);
                    this.enemyFatigue = Convert.ToInt32(s.Split(' ')[4]);
                }

                if (readstate == 3) // minion + enchantment
                {
                    if (s.Contains(" zp:"))
                    {

                        string minionname = s.Split(' ')[0];
                        string minionid = s.Split(' ')[1];
                        int zp = Convert.ToInt32(s.Split(new string[] { " zp:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                        int ent = 1000 + j;
                        if (s.Contains(" e:")) ent = Convert.ToInt32(s.Split(new string[] { " e:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                        int attack = Convert.ToInt32(s.Split(new string[] { " A:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                        int hp = Convert.ToInt32(s.Split(new string[] { " H:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                        int maxhp = Convert.ToInt32(s.Split(new string[] { " mH:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                        bool ready = s.Split(new string[] { " rdy:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0] == "True";
                        int natt = 0;
                        if (s.Contains(" natt:")) natt = Convert.ToInt32(s.Split(new string[] { " natt:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);

                        // optional params (bools)
                        bool ex = s.Contains(" ex");
                        bool taunt = s.Contains(" tnt");
                        bool frzn = s.Contains(" frz");
                        bool silenced = s.Contains(" silenced");
                        bool divshield = s.Contains(" divshield");
                        bool ptt = s.Contains(" ptt");
                        bool wndfry = s.Contains(" wndfr");
                        bool stl = s.Contains(" stlth");
                        bool pois = s.Contains(" poi");
                        bool immn = s.Contains(" imm");
                        bool cncdl = s.Contains(" cncdl");
                        bool destroyOnOwnTurnStart = s.Contains(" dstrOwnTrnStrt");
                        bool destroyOnOwnTurnEnd = s.Contains(" dstrOwnTrnnd");
                        bool destroyOnEnemyTurnStart = s.Contains(" dstrEnmTrnStrt");
                        bool destroyOnEnemyTurnEnd = s.Contains(" dstrEnmTrnnd");
                        bool shadowmadnessed = s.Contains(" shdwmdnssd");
                        bool cntlower = s.Contains(" cantLowerHpBelowOne");
                        //optional params (ints)


                        int chrg = 0;//charge
                        if (s.Contains(" chrg(")) chrg = Convert.ToInt32(s.Split(new string[] { " chrg(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int adjadmg = 0;//adjadmg
                        if (s.Contains(" adjaattk(")) adjadmg = Convert.ToInt32(s.Split(new string[] { " adjaattk(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int tmpdmg = 0;//adjadmg
                        if (s.Contains(" tmpattck(")) tmpdmg = Convert.ToInt32(s.Split(new string[] { " tmpattck(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int spllpwr = 0;//adjadmg
                        if (s.Contains(" spllpwr(")) spllpwr = Convert.ToInt32(s.Split(new string[] { " spllpwr(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int ancestralspirit = 0;//adjadmg
                        if (s.Contains(" ancstrl(")) ancestralspirit = Convert.ToInt32(s.Split(new string[] { " ancstrl(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int ownBlessingOfWisdom = 0;//adjadmg
                        if (s.Contains(" ownBlssng(")) ownBlessingOfWisdom = Convert.ToInt32(s.Split(new string[] { " ownBlssng(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int enemyBlessingOfWisdom = 0;//adjadmg
                        if (s.Contains(" enemyBlssng(")) enemyBlessingOfWisdom = Convert.ToInt32(s.Split(new string[] { " enemyBlssng(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int souloftheforest = 0;//adjadmg
                        if (s.Contains(" souloffrst(")) souloftheforest = Convert.ToInt32(s.Split(new string[] { " souloffrst(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);



                        tempminion = createNewMinion(new Handmanager.Handcard(CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(minionid))), zp, true);
                        tempminion.own = true;
                        tempminion.entitiyID = ent;
                        tempminion.handcard.entity = ent;
                        tempminion.Angr = attack;
                        tempminion.Hp = hp;
                        tempminion.maxHp = maxhp;
                        tempminion.Ready = ready;
                        tempminion.numAttacksThisTurn = natt;
                        tempminion.exhausted = ex;
                        tempminion.taunt = taunt;
                        tempminion.frozen = frzn;
                        tempminion.silenced = silenced;
                        tempminion.divineshild = divshield;
                        tempminion.playedThisTurn = ptt;
                        tempminion.windfury = wndfry;
                        tempminion.stealth = stl;
                        tempminion.poisonous = pois;
                        tempminion.immune = immn;

                        tempminion.concedal = cncdl;
                        tempminion.destroyOnOwnTurnStart = destroyOnOwnTurnStart;
                        tempminion.destroyOnOwnTurnEnd = destroyOnOwnTurnEnd;
                        tempminion.destroyOnEnemyTurnStart = destroyOnEnemyTurnStart;
                        tempminion.destroyOnEnemyTurnEnd = destroyOnEnemyTurnEnd;
                        tempminion.shadowmadnessed = shadowmadnessed;
                        tempminion.cantLowerHPbelowONE = cntlower;

                        tempminion.charge = chrg;
                        tempminion.AdjacentAngr = adjadmg;
                        tempminion.tempAttack = tmpdmg;
                        tempminion.spellpower = spllpwr;

                        tempminion.ancestralspirit = ancestralspirit;
                        tempminion.ownBlessingOfWisdom = ownBlessingOfWisdom;
                        tempminion.enemyBlessingOfWisdom = enemyBlessingOfWisdom;
                        tempminion.souloftheforest = souloftheforest;

                        if (maxhp > hp) tempminion.wounded = true;
                        tempminion.updateReadyness();
                        this.ownminions.Add(tempminion);



                    }

                }

                if (readstate == 4) // minion or enchantment
                {
                    if (s.Contains(" zp:"))
                    {

                        string minionname = s.Split(' ')[0];
                        string minionid = s.Split(' ')[1];
                        int zp = Convert.ToInt32(s.Split(new string[] { " zp:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                        int ent = 1000 + j;
                        if (s.Contains(" e:")) ent = Convert.ToInt32(s.Split(new string[] { " e:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                        int attack = Convert.ToInt32(s.Split(new string[] { " A:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                        int hp = Convert.ToInt32(s.Split(new string[] { " H:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                        int maxhp = Convert.ToInt32(s.Split(new string[] { " mH:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);
                        bool ready = s.Split(new string[] { " rdy:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0] == "True" ? true : false;
                        int natt = 0;
                        //if (s.Contains(" natt:")) natt = Convert.ToInt32(s.Split(new string[] { " natt:" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(' ')[0]);

                        // optional params (bools)
                        bool ex = s.Contains(" ex");
                        bool taunt = s.Contains(" tnt");
                        bool frzn = s.Contains(" frz");
                        bool silenced = s.Contains(" silenced");
                        bool divshield = s.Contains(" divshield");
                        bool ptt = s.Contains(" ptt");
                        bool wndfry = s.Contains(" wndfr");
                        bool stl = s.Contains(" stlth");
                        bool pois = s.Contains(" poi");
                        bool immn = s.Contains(" imm");
                        bool cncdl = s.Contains(" cncdl");
                        bool destroyOnOwnTurnStart = s.Contains(" dstrOwnTrnStrt");
                        bool destroyOnOwnTurnEnd = s.Contains(" dstrOwnTrnnd");
                        bool destroyOnEnemyTurnStart = s.Contains(" dstrEnmTrnStrt");
                        bool destroyOnEnemyTurnEnd = s.Contains(" dstrEnmTrnnd");
                        bool shadowmadnessed = s.Contains(" shdwmdnssd");
                        bool cntlower = s.Contains(" cantLowerHpBelowOne");

                        //optional params (ints)


                        int chrg = 0;//charge
                        if (s.Contains(" chrg(")) chrg = Convert.ToInt32(s.Split(new string[] { " chrg(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int adjadmg = 0;//adjadmg
                        if (s.Contains(" adjaattk(")) adjadmg = Convert.ToInt32(s.Split(new string[] { " adjaattk(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int tmpdmg = 0;//adjadmg
                        if (s.Contains(" tmpattck(")) tmpdmg = Convert.ToInt32(s.Split(new string[] { " tmpattck(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int spllpwr = 0;//adjadmg
                        if (s.Contains(" spllpwr(")) spllpwr = Convert.ToInt32(s.Split(new string[] { " spllpwr(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int ancestralspirit = 0;//adjadmg
                        if (s.Contains(" ancstrl(")) ancestralspirit = Convert.ToInt32(s.Split(new string[] { " ancstrl(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int ownBlessingOfWisdom = 0;//adjadmg
                        if (s.Contains(" ownBlssng(")) ownBlessingOfWisdom = Convert.ToInt32(s.Split(new string[] { " ownBlssng(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int enemyBlessingOfWisdom = 0;//adjadmg
                        if (s.Contains(" enemyBlssng(")) enemyBlessingOfWisdom = Convert.ToInt32(s.Split(new string[] { " enemyBlssng(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);

                        int souloftheforest = 0;//adjadmg
                        if (s.Contains(" souloffrst(")) souloftheforest = Convert.ToInt32(s.Split(new string[] { " souloffrst(" }, StringSplitOptions.RemoveEmptyEntries)[1].Split(')')[0]);



                        tempminion = createNewMinion(new Handmanager.Handcard(CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(minionid))), zp, false);
                        tempminion.own = false;
                        tempminion.entitiyID = ent;
                        tempminion.handcard.entity = ent;
                        tempminion.Angr = attack;
                        tempminion.Hp = hp;
                        tempminion.maxHp = maxhp;
                        tempminion.Ready = ready;
                        tempminion.numAttacksThisTurn = natt;
                        tempminion.exhausted = ex;
                        tempminion.taunt = taunt;
                        tempminion.frozen = frzn;
                        tempminion.silenced = silenced;
                        tempminion.divineshild = divshield;
                        tempminion.playedThisTurn = ptt;
                        tempminion.windfury = wndfry;
                        tempminion.stealth = stl;
                        tempminion.poisonous = pois;
                        tempminion.immune = immn;

                        tempminion.concedal = cncdl;
                        tempminion.destroyOnOwnTurnStart = destroyOnOwnTurnStart;
                        tempminion.destroyOnOwnTurnEnd = destroyOnOwnTurnEnd;
                        tempminion.destroyOnEnemyTurnStart = destroyOnEnemyTurnStart;
                        tempminion.destroyOnEnemyTurnEnd = destroyOnEnemyTurnEnd;
                        tempminion.shadowmadnessed = shadowmadnessed;
                        tempminion.cantLowerHPbelowONE = cntlower;

                        tempminion.charge = chrg;
                        tempminion.AdjacentAngr = adjadmg;
                        tempminion.tempAttack = tmpdmg;
                        tempminion.spellpower = spllpwr;

                        tempminion.ancestralspirit = ancestralspirit;
                        tempminion.ownBlessingOfWisdom = ownBlessingOfWisdom;
                        tempminion.enemyBlessingOfWisdom = enemyBlessingOfWisdom;
                        tempminion.souloftheforest = souloftheforest;

                        if (maxhp > hp) tempminion.wounded = true;
                        tempminion.updateReadyness();
                        this.enemyminions.Add(tempminion);


                    }


                }

                if (readstate == 5) // minion or enchantment
                {

                    Handmanager.Handcard card = new Handmanager.Handcard();

                    string minionname = s.Split(' ')[2];
                    string minionid = s.Split(' ')[6];
                    int pos = Convert.ToInt32(s.Split(' ')[1]);
                    int mana = Convert.ToInt32(s.Split(' ')[3]);
                    card.card = CardDB.Instance.getCardDataFromID(CardDB.Instance.cardIdstringToEnum(minionid));
                    card.entity = Convert.ToInt32(s.Split(' ')[5]);
                    card.addattack = 0;
                    if (s.Split(' ').Length >= 8 && s.Split(' ')[7] != "")
                    {
                        card.addattack = Convert.ToInt32(s.Split(' ')[7]);
                    }
                    card.manacost = mana;
                    card.position = pos;
                    handcards.Add(card);

                }


                if (s.StartsWith("ownhero:"))
                {
                    readstate = 1;
                    counter = 0;
                }

                if (s.StartsWith("enemyhero:"))
                {
                    readstate = 2;
                    counter = 0;
                }

                if (s.StartsWith("OwnMinions:"))
                {
                    readstate = 3;
                    counter = 0;
                }

                if (s.StartsWith("EnemyMinions:"))
                {
                    readstate = 4;
                    counter = 0;
                }

                if (s.StartsWith("Own Handcards:"))
                {
                    readstate = 5;
                    counter = 0;
                }

                if (s.StartsWith("player:"))
                {
                    readstate = 42;
                    counter = 0;
                }



                counter++;
                j++;
            }
            Helpfunctions.Instance.logg("rdy");


            Hrtprozis.Instance.setOwnPlayer(ownPlayer);
            Handmanager.Instance.setOwnPlayer(ownPlayer);

            this.numOptionPlayedThisTurn = 0;
            this.numOptionPlayedThisTurn += this.cardsPlayedThisTurn + ownheroattacksThisRound;
            foreach (Minion m in this.ownminions)
            {
                this.numOptionPlayedThisTurn += m.numAttacksThisTurn;
            }


            Hrtprozis.Instance.updatePlayer(this.maxmana, this.mana, this.cardsPlayedThisTurn, this.numMinionsPlayedThisTurn, this.numOptionPlayedThisTurn, this.overdrive, ownHEntity, enemyHEntity);
            Hrtprozis.Instance.updateSecretStuff(this.ownsecretlist, enemySecretAmount);

            bool herowindfury = false;
            if (this.ownHeroWeapon == "doomhammer") herowindfury = true;

            //create heros:

            this.ownHero = new Minion();
            this.enemyHero = new Minion();
            this.ownHero.isHero = true;
            this.enemyHero.isHero = true;
            this.ownHero.own = true;
            this.enemyHero.own = false;
            this.ownHero.maxHp = this.ownheromaxhp;
            this.enemyHero.maxHp = this.enemyheromaxhp;
            this.ownHero.entitiyID = ownHEntity;
            this.enemyHero.entitiyID = enemyHEntity;

            this.ownHero.Angr = ownHeroAttack;
            this.ownHero.Hp = ownherohp;
            this.ownHero.armor = ownherodefence;
            this.ownHero.frozen = ownHeroFrozen;
            this.ownHero.immuneWhileAttacking = ownHeroimmunewhileattacking;
            this.ownHero.immune = heroImmune;
            this.ownHero.numAttacksThisTurn = ownheroattacksThisRound;
            this.ownHero.windfury = herowindfury;

            this.enemyHero.Angr = enemyWeaponAttack;
            this.enemyHero.Hp = enemyherohp;
            this.enemyHero.frozen = enemyFrozen;
            this.enemyHero.armor = enemyherodefence;
            this.enemyHero.immune = enemyHeroImmune;
            this.enemyHero.Ready = false;

            this.ownHero.updateReadyness();


            //set Simulation stuff

            Ai.Instance.botBase = new BehaviorControl();



            if (this.evalFunction == "rush") Ai.Instance.botBase = new BehaviorRush();

            if (this.evalFunction == "mana") Ai.Instance.botBase = new BehaviorMana();

            Ai.Instance.setMaxWide(this.maxwide);
            Ai.Instance.setTwoTurnSimulation(false, this.twoturnsim);
            Settings.Instance.simEnemySecondTurn = this.simEnemy2Turn;
            //Ai.Instance.nextTurnSimulator.updateParams();
            Settings.Instance.playarround = this.playarround;
            Settings.Instance.playaroundprob = this.pprob1;
            Settings.Instance.playaroundprob2 = this.pprob2;
            Ai.Instance.setPlayAround();

            //save data
            Hrtprozis.Instance.updateOwnHero(this.ownHeroWeapon, this.ownHeroWeaponAttack, this.ownHeroWeaponDurability, this.ownheroname, heroability, abilityReady, this.ownHero);
            Hrtprozis.Instance.updateEnemyHero(this.enemyWeapon, this.enemyWeaponAttack, this.enemyWeaponDur, this.enemyheroname, enemmaxman, enemyability, this.enemyHero);

            Hrtprozis.Instance.updateMinions(this.ownminions, this.enemyminions);

            Hrtprozis.Instance.updateFatigueStats(this.ownDecksize, this.ownFatigue, this.enemyDecksize, this.enemyFatigue);

            Handmanager.Instance.setHandcards(this.handcards, this.handcards.Count, enemyNumberHand);

            Probabilitymaker.Instance.setEnemySecretData(enemySecrets);

            Probabilitymaker.Instance.setTurnGraveYard(this.turnGraveYard);
            Probabilitymaker.Instance.stalaggDead = this.stalaggdead;
            Probabilitymaker.Instance.feugenDead = this.feugendead;

            if (og != "") Probabilitymaker.Instance.readGraveyards(og, eg);
            if (omd != "") Probabilitymaker.Instance.readTurnGraveYard(omd, emd);
            //Ai.Instance.enemyTurnSim.maxwide = ets;
            //Ai.Instance.enemySecondTurnSim.maxwide = ents;
            Settings.Instance.enemyTurnMaxWide = ets;
            Settings.Instance.enemySecondTurnMaxWide = ents;

            Settings.Instance.nextTurnDeep = ntssd;
            Settings.Instance.nextTurnMaxWide = ntssw;
            Settings.Instance.nextTurnTotalBoards = ntssm;
            //Ai.Instance.nextTurnSimulator.updateParams(ntssd, ntssw, ntssm);

            Settings.Instance.useSecretsPlayArround = dosecrets;

            Settings.Instance.setWeights(alpha);

        }



        public Minion createNewMinion(Handmanager.Handcard hc, int zonepos, bool own)
        {
            Minion m = new Minion
            {
                handcard = new Handmanager.Handcard(hc),
                zonepos = zonepos,
                entitiyID = hc.entity,
                Angr = hc.card.Attack,
                Hp = hc.card.Health,
                maxHp = hc.card.Health,
                name = hc.card.name,
                playedThisTurn = true,
                numAttacksThisTurn = 0
            };

            m.own = own;
            m.isHero = false;
            m.entitiyID = hc.entity;
            m.playedThisTurn = true;
            m.numAttacksThisTurn = 0;
            m.windfury = hc.card.windfury;
            m.taunt = hc.card.tank;
            m.charge = (hc.card.Charge) ? 1 : 0;
            m.divineshild = hc.card.Shield;
            m.poisonous = hc.card.poisionous;
            m.stealth = hc.card.Stealth;

            m.updateReadyness();

            if (m.name == CardDB.cardName.lightspawn)
            {
                m.Angr = m.Hp;
            }
            return m;
        }




    }

    public class miniEnch
    {
        public CardDB.cardIDEnum CARDID = CardDB.cardIDEnum.None;
        public int creator = 0; // the minion
        public int controllerOfCreator = 0; // own or enemys buff?

        public miniEnch(CardDB.cardIDEnum id, int crtr, int controler)
        {
            this.CARDID = id;
            this.creator = crtr;
            this.controllerOfCreator = controler;
        }

    }

    public class Minion
    {
        //dont silence----------------------------
        public int anzGotDmg = 0;
        public bool isHero = false;
        public bool own;

        public CardDB.cardName name = CardDB.cardName.unknown;
        public Handmanager.Handcard handcard;
        public int entitiyID = -1;
        //public int id = -1;//delete this
        public int zonepos = 0;

        public bool playedThisTurn = false;
        public int numAttacksThisTurn = 0;
        public bool immuneWhileAttacking = false;

        public bool allreadyAttacked = false;

        //---------------------------------------
        public bool shadowmadnessed = false;//´can be silenced :D

        public int ancestralspirit = 0;
        public bool destroyOnOwnTurnStart = false; // depends on own!
        public bool destroyOnEnemyTurnStart = false; // depends on own!
        public bool destroyOnOwnTurnEnd = false; // depends on own!
        public bool destroyOnEnemyTurnEnd = false; // depends on own!

        public bool concedal = false;
        public int souloftheforest = 0;

        public int ownBlessingOfWisdom = 0;
        public int enemyBlessingOfWisdom = 0;
        public int spellpower = 0;

        public bool cantBeTargetedBySpellsOrHeroPowers = false;

        public int Hp = 0;
        public int maxHp = 0;
        public int armor = 0;

        public int Angr = 0;
        public int AdjacentAngr = 0;
        public int tempAttack = 0;

        public bool Ready = false;

        public bool taunt = false;
        public bool wounded = false;//hp red?

        public bool divineshild = false;
        public bool windfury = false;
        public bool frozen = false;
        public bool stealth = false;
        public bool immune = false;
        public bool exhausted = false;

        public int charge = 0;
        public bool poisonous = false;
        public bool cantLowerHPbelowONE = false;

        public bool silenced = false;

        public Minion()
        {
            this.handcard = new Handmanager.Handcard();
        }

        public Minion(Minion m)
        {
            //dont silence----------------------------
            this.anzGotDmg = m.anzGotDmg;
            this.isHero = m.isHero;
            this.own = m.own;

            this.name = m.name;
            this.handcard = m.handcard;//new?
            this.entitiyID = m.entitiyID;
            this.zonepos = m.zonepos;

            this.allreadyAttacked = m.allreadyAttacked;


            this.playedThisTurn = m.playedThisTurn;
            this.numAttacksThisTurn = m.numAttacksThisTurn;
            this.immuneWhileAttacking = m.immuneWhileAttacking;

            //---------------------------------------
            this.shadowmadnessed = m.shadowmadnessed;

            this.ancestralspirit = m.ancestralspirit;
            this.destroyOnOwnTurnStart = m.destroyOnOwnTurnStart; // depends on own!
            this.destroyOnEnemyTurnStart = m.destroyOnEnemyTurnStart; // depends on own!
            this.destroyOnOwnTurnEnd = m.destroyOnOwnTurnEnd; // depends on own!
            this.destroyOnEnemyTurnEnd = m.destroyOnEnemyTurnEnd; // depends on own!

            this.concedal = m.concedal;
            this.souloftheforest = m.souloftheforest;

            this.ownBlessingOfWisdom = m.ownBlessingOfWisdom;
            this.enemyBlessingOfWisdom = m.enemyBlessingOfWisdom;
            this.spellpower = m.spellpower;

            this.Hp = m.Hp;
            this.maxHp = m.maxHp;
            this.armor = m.armor;

            this.Angr = m.Angr;
            this.AdjacentAngr = m.AdjacentAngr;
            this.tempAttack = m.tempAttack;

            this.Ready = m.Ready;

            this.taunt = m.taunt;
            this.wounded = m.wounded;

            this.divineshild = m.divineshild;
            this.windfury = m.windfury;
            this.frozen = m.frozen;
            this.stealth = m.stealth;
            this.immune = m.immune;
            this.exhausted = m.exhausted;

            this.charge = m.charge;
            this.poisonous = m.poisonous;
            this.cantLowerHPbelowONE = m.cantLowerHPbelowONE;

            this.silenced = m.silenced;
        }

        public void setMinionTominion(Minion m)
        {
            //dont silence----------------------------
            this.anzGotDmg = m.anzGotDmg;
            this.isHero = m.isHero;
            this.own = m.own;

            this.name = m.name;
            this.handcard = m.handcard;//new?
            //this.entitiyID = m.entitiyID;
            this.zonepos = m.zonepos;


            this.allreadyAttacked = m.allreadyAttacked;

            this.playedThisTurn = m.playedThisTurn;
            this.numAttacksThisTurn = m.numAttacksThisTurn;
            this.immuneWhileAttacking = m.immuneWhileAttacking;

            //---------------------------------------
            this.shadowmadnessed = m.shadowmadnessed;

            this.ancestralspirit = m.ancestralspirit;
            this.destroyOnOwnTurnStart = m.destroyOnOwnTurnStart; // depends on own!
            this.destroyOnEnemyTurnStart = m.destroyOnEnemyTurnStart; // depends on own!
            this.destroyOnOwnTurnEnd = m.destroyOnOwnTurnEnd; // depends on own!
            this.destroyOnEnemyTurnEnd = m.destroyOnEnemyTurnEnd; // depends on own!

            this.concedal = m.concedal;
            this.souloftheforest = m.souloftheforest;

            this.ownBlessingOfWisdom = m.ownBlessingOfWisdom;
            this.enemyBlessingOfWisdom = m.enemyBlessingOfWisdom;
            this.spellpower = m.spellpower;

            this.Hp = m.Hp;
            this.maxHp = m.maxHp;
            this.armor = m.armor;

            this.Angr = m.Angr;
            this.AdjacentAngr = m.AdjacentAngr;
            this.tempAttack = m.tempAttack;

            this.Ready = m.Ready;

            this.taunt = m.taunt;
            this.wounded = m.wounded;

            this.divineshild = m.divineshild;
            this.windfury = m.windfury;
            this.frozen = m.frozen;
            this.stealth = m.stealth;
            this.immune = m.immune;
            this.exhausted = m.exhausted;

            this.charge = m.charge;
            this.poisonous = m.poisonous;
            this.cantLowerHPbelowONE = m.cantLowerHPbelowONE;

            this.silenced = m.silenced;
        }

        public int getRealAttack()
        {
            return this.Angr;
        }

        public void getDamageOrHeal(int dmg, Playfield p, bool isMinionAttack, bool dontCalcLostDmg)
        {
            if (this.Hp <= 0) return;

            if (this.immune && dmg > 0) return;

            if (this.isHero)
            {
                int copy = this.Hp;
                if (dmg < 0 || this.armor <= 0)
                {
                    //if (dmg < 0) return;

                    //heal

                    this.Hp = Math.Min(30, this.Hp - dmg);
                    if (copy < this.Hp)
                    {
                        p.tempTrigger.charsGotHealed++;
                    }
                    if (copy - this.Hp >= 1)
                    {
                        p.secretTrigger_HeroGotDmg(this.own, copy - this.Hp);
                    }
                }
                else
                {
                    if (this.armor > 0 && dmg > 0)
                    {

                        int rest = this.armor - dmg;
                        if (rest < 0)
                        {
                            this.Hp += rest;
                            p.secretTrigger_HeroGotDmg(this.own, rest);
                        }
                        this.armor = Math.Max(0, this.armor - dmg);

                    }
                }
                if (this.cantLowerHPbelowONE && this.Hp <= 0) this.Hp = 1;


                if (this.Hp < copy)
                {
                    this.anzGotDmg++;
                }
                return;
            }

            //its a Minion--------------------------------------------------------------


            int damage = dmg;
            int heal = 0;
            if (dmg < 0) heal = -dmg;

            bool woundedbefore = this.wounded;
            if (heal < 0) // heal was shifted in damage
            {
                damage = -1 * heal;
                heal = 0;
            }

            if (damage >= 1) this.allreadyAttacked = true;

            if (damage >= 1 && this.divineshild)
            {
                this.divineshild = false;
                if (!own && !dontCalcLostDmg && p.turnCounter == 0)
                {
                    if (isMinionAttack)
                    {
                        p.lostDamage += damage - 1;
                    }
                    else
                    {
                        p.lostDamage += (damage - 1) * (damage - 1);
                    }
                }
                return;
            }

            if (this.cantLowerHPbelowONE && damage >= 1 && damage >= this.Hp) damage = this.Hp - 1;

            if (!own && !dontCalcLostDmg && this.Hp < damage && p.turnCounter == 0)
            {
                if (isMinionAttack)
                {
                    p.lostDamage += (damage - this.Hp);
                }
                else
                {
                    p.lostDamage += (damage - this.Hp) * (damage - this.Hp);
                }
            }

            int hpcopy = this.Hp;

            if (damage >= 1)
            {
                this.Hp = this.Hp - damage;
            }

            if (heal >= 1)
            {
                if (own && !dontCalcLostDmg && heal <= 999 && this.Hp + heal > this.maxHp) p.lostHeal += this.Hp + heal - this.maxHp;

                this.Hp = this.Hp + Math.Min(heal, this.maxHp - this.Hp);
            }



            if (this.Hp > hpcopy)
            {
                //minionWasHealed
                p.tempTrigger.minionsGotHealed++;
                p.tempTrigger.charsGotHealed++;
            }

            if (this.Hp < hpcopy)
            {
                if (this.own)
                {
                    p.tempTrigger.ownMinionsGotDmg++;
                }
                else
                {
                    p.tempTrigger.enemyMinionsGotDmg++;
                }
                this.anzGotDmg++;
            }

            if (this.maxHp == this.Hp)
            {
                this.wounded = false;
            }
            else
            {
                this.wounded = true;
            }



            if (this.name == CardDB.cardName.lightspawn && !this.silenced)
            {
                this.Angr = this.Hp;
            }

            if (woundedbefore && !this.wounded)
            {
                this.handcard.card.sim_card.onEnrageStop(p, this);
            }

            if (!woundedbefore && this.wounded)
            {
                this.handcard.card.sim_card.onEnrageStart(p, this);
            }

            if (this.Hp <= 0)
            {
                this.minionDied(p);
            }



        }

        public void minionDied(Playfield p)
        {
            if (this.name == CardDB.cardName.stalagg)
            {
                p.stalaggDead = true;
            }
            else
            {
                if (this.name == CardDB.cardName.feugen) p.feugenDead = true;
            }



            if (own)
            {

                p.tempTrigger.ownMinionsDied++;
                if (this.handcard.card.race == 20)
                {
                    p.tempTrigger.ownBeastDied++;
                }
                if (this.handcard.card.race == 17)
                {
                    p.tempTrigger.ownMechanicDied++;
                }
                if (this.handcard.card.race == 14)
                {
                    p.tempTrigger.ownMurlocDied++;
                }
            }
            else
            {
                p.tempTrigger.enemyMinionsDied++;
                if (this.handcard.card.race == 20)
                {
                    p.tempTrigger.enemyBeastDied++;
                }
                if (this.handcard.card.race == 17)
                {
                    p.tempTrigger.enemyMechanicDied++;
                }
                if (this.handcard.card.race == 14)
                {
                    p.tempTrigger.enemyMurlocDied++;
                }
            }

            if (p.diedMinions != null)
            {
                GraveYardItem gyi = new GraveYardItem(this.handcard.card.cardIDenum, this.entitiyID, this.own);
                p.diedMinions.Add(gyi);
            }
        }

        public void updateReadyness()
        {
            Ready = false;
            //default test (minion must be unfrozen!)
            if (isHero)
            {
                if (!frozen && ((charge >= 1 && playedThisTurn) || !playedThisTurn) && (numAttacksThisTurn == 0 || (numAttacksThisTurn == 1 && windfury))) Ready = true;
                return;
            }

            if (!silenced && (name == CardDB.cardName.ragnarosthefirelord || name == CardDB.cardName.ancientwatcher)) return;

            if (!frozen && ((charge >= 1 && playedThisTurn) || !playedThisTurn || shadowmadnessed) && (numAttacksThisTurn == 0 || (numAttacksThisTurn == 1 && windfury) || (!silenced && this.name == CardDB.cardName.v07tr0n && numAttacksThisTurn <= 3))) Ready = true;

        }

        public void becomeSilence(Playfield p)
        {
            p.minionGetOrEraseAllAreaBuffs(this, false);
            //buffs
            ancestralspirit = 0;
            destroyOnOwnTurnStart = false;
            destroyOnEnemyTurnStart = false;
            destroyOnOwnTurnEnd = false;
            destroyOnEnemyTurnEnd = false;
            concedal = false;
            souloftheforest = 0;
            ownBlessingOfWisdom = 0;
            enemyBlessingOfWisdom = 0;

            cantBeTargetedBySpellsOrHeroPowers = false;

            charge = 0;
            taunt = false;
            divineshild = false;
            windfury = false;
            frozen = false;
            stealth = false;
            immune = false;
            poisonous = false;
            cantLowerHPbelowONE = false;


            if (own) p.spellpower -= spellpower;
            else p.enemyspellpower -= spellpower;

            spellpower = 0;

            //delete enrage (if minion is silenced the first time)
            if (wounded && handcard.card.Enrage && !silenced)
            {
                handcard.card.sim_card.onEnrageStop(p, this);
            }

            //reset attack
            Angr = handcard.card.Attack;
            tempAttack = 0;//we dont toutch the adjacent buffs!


            //reset hp and heal it
            if (maxHp < handcard.card.Health)//minion has lower maxHp as his card -> heal his hp
            {
                Hp += handcard.card.Health - maxHp; //heal minion
            }
            maxHp = handcard.card.Health;
            if (Hp > maxHp) Hp = maxHp;

            if (!silenced)//minion WAS not silenced, deactivate his aura
            {
                handcard.card.sim_card.onAuraEnds(p, this);
            }

            silenced = true;
            this.updateReadyness();
            p.minionGetOrEraseAllAreaBuffs(this, true);
            if (own)
            {
                p.tempTrigger.ownMinionsChanged = true;
            }
            else
            {
                p.tempTrigger.enemyMininsChanged = true;
            }
            if (this.shadowmadnessed)
            {
                this.shadowmadnessed = false;
                p.minionGetControlled(this, !own, false);
            }
        }

        public void loadEnchantments(List<miniEnch> enchants, int ownPlayerControler)
        {
            foreach (miniEnch me in enchants)
            {
                // deathrattles reborns and destoyings----------------------------------------------
                if (me.CARDID == CardDB.cardIDEnum.CS2_038e) //ancestral spirit
                {
                    this.ancestralspirit++;
                }
                if (me.CARDID == CardDB.cardIDEnum.EX1_584e) //ancient mage
                {
                    this.spellpower++;
                }
                if (me.CARDID == CardDB.cardIDEnum.GVG_010b) //Velen's Chosen (+2+4, +spellpower)
                {
                    this.spellpower++;
                }
                if (me.CARDID == CardDB.cardIDEnum.EX1_158e) //soul of the forest
                {
                    this.souloftheforest++;
                }

                if (me.CARDID == CardDB.cardIDEnum.EX1_128e) //conceal
                {
                    this.concedal = true;
                }
                if (me.CARDID == CardDB.cardIDEnum.PART_004e) //conceal
                {
                    this.concedal = true;
                }

                if (me.CARDID == CardDB.cardIDEnum.CS2_063e) //corruption
                {
                    if (me.controllerOfCreator == ownPlayerControler)
                    {
                        this.destroyOnOwnTurnStart = true;
                    }
                    else
                    {
                        this.destroyOnEnemyTurnStart = true;
                    }
                }

                if (me.CARDID == CardDB.cardIDEnum.EX1_363e || me.CARDID == CardDB.cardIDEnum.EX1_363e2) //corruption
                {
                    if (me.controllerOfCreator == ownPlayerControler)
                    {
                        this.ownBlessingOfWisdom++;
                    }
                    else
                    {
                        this.enemyBlessingOfWisdom++;
                    }
                }

                if (me.CARDID == CardDB.cardIDEnum.DREAM_05e) //nightmare
                {
                    if (me.controllerOfCreator == ownPlayerControler)
                    {
                        this.destroyOnOwnTurnStart = true;
                    }
                    else
                    {
                        this.destroyOnEnemyTurnStart = true;
                    }
                }

                if (me.CARDID == CardDB.cardIDEnum.EX1_316e) //overwhelmingpower
                {
                    if (me.controllerOfCreator == ownPlayerControler)
                    {
                        this.destroyOnOwnTurnEnd = true;
                    }
                    else
                    {
                        this.destroyOnEnemyTurnEnd = true;
                    }
                }

                if (me.CARDID == CardDB.cardIDEnum.NEW1_036e) //commanding shout
                {
                    this.cantLowerHPbelowONE = true;
                }
                if (me.CARDID == CardDB.cardIDEnum.NEW1_036e2) //commanding shout
                {
                    this.cantLowerHPbelowONE = true;
                }

                if (me.CARDID == CardDB.cardIDEnum.EX1_334e) //Dark Command
                {
                    this.shadowmadnessed = true;
                }

                if (me.CARDID == CardDB.cardIDEnum.FP1_030e) //Necrotic Aura
                {
                    //todo Eure Zauber kosten in diesem Zug (5) mehr.
                }
                if (me.CARDID == CardDB.cardIDEnum.NEW1_029t) //death to millhouse!
                {
                    // todo spells cost (0) this turn!
                }
                if (me.CARDID == CardDB.cardIDEnum.EX1_612o) //Power of the Kirin Tor
                {
                    // todo Your next Secret costs (0).
                }
                if (me.CARDID == CardDB.cardIDEnum.EX1_084e) //warsongcommander
                {
                    this.charge++;
                }
                if (me.CARDID == CardDB.cardIDEnum.DS1_178e) //rhino
                {
                    this.charge++;
                }
                if (me.CARDID == CardDB.cardIDEnum.CS2_103e2)// sturmangriff    +2 angriff und ansturm/.
                {
                    this.charge++;
                }

                //ancientbuffs-------------------------------------------------
                if (me.CARDID == CardDB.cardIDEnum.EX1_565o) //flametongue
                {
                    this.AdjacentAngr += 2;
                }
                if (me.CARDID == CardDB.cardIDEnum.EX1_162o) //dire wolf alpha
                {
                    this.AdjacentAngr += 1;
                }
                //tempbuffs-------------------------------------------------

                if (me.CARDID == CardDB.cardIDEnum.CS2_105e) //heldenhafter stoss
                {
                    this.tempAttack += 4;
                }
                if (me.CARDID == CardDB.cardIDEnum.EX1_570e) //bite
                {
                    this.tempAttack += 4;
                }
                if (me.CARDID == CardDB.cardIDEnum.CS2_083e) //sharpened
                {
                    this.tempAttack += 1;
                }
                if (me.CARDID == CardDB.cardIDEnum.EX1_046e) //tempered
                {
                    this.tempAttack += 2;
                }
                if (me.CARDID == CardDB.cardIDEnum.CS2_188o) //inspiring
                {
                    this.tempAttack += 2;
                }
                if (me.CARDID == CardDB.cardIDEnum.CS2_045e) //rockbiter
                {
                    this.tempAttack += 3;
                }
                if (me.CARDID == CardDB.cardIDEnum.CS2_046e) //bloodlust
                {
                    this.tempAttack += 3;
                }

                if (me.CARDID == CardDB.cardIDEnum.CS2_011o) //Savage Roar
                {
                    this.tempAttack += 2;
                }
                if (me.CARDID == CardDB.cardIDEnum.CS2_017o) //Claws
                {
                    this.tempAttack += 1;
                }
                if (me.CARDID == CardDB.cardIDEnum.EX1_549o) //bestial wrath
                {
                    this.tempAttack += 2;
                    this.immune = true;
                }
                if (me.CARDID == CardDB.cardIDEnum.CS2_005o) //Claw
                {
                    this.tempAttack += 2;
                }
                if (me.CARDID == CardDB.cardIDEnum.GVG_011a) //Shrink Ray
                {
                    this.tempAttack -= 2; //todo might not be correct
                }
                if (me.CARDID == CardDB.cardIDEnum.GVG_057a) //Seal of Light
                {
                    this.tempAttack += 2;
                }




            }
        }

    }

    public abstract class Behavior
    {
        public virtual float getPlayfieldValue(Playfield p)
        {
            return 0;
        }

        public virtual int getEnemyMinionValue(Minion m, Playfield p)
        {
            return 0;
        }

    }

    public class BehaviorControl : Behavior
    {
        PenalityManager penman = PenalityManager.Instance;

        public override float getPlayfieldValue(Playfield p)
        {
            if (p.value >= -2000000) return p.value;
            int retval = 0;
            int hpboarder = 10;
            if (p.ownHeroName == HeroEnum.warlock && p.enemyHeroName != HeroEnum.mage) hpboarder = 6;
            int aggroboarder = 11;

            retval -= p.evaluatePenality;
            retval += p.owncards.Count * 5;

            retval += p.ownMaxMana;
            retval -= p.enemyMaxMana;

            retval += p.ownMaxMana * 20 - p.enemyMaxMana * 20;

            if (p.enemyHeroName == HeroEnum.mage || p.enemyHeroName == HeroEnum.druid) retval -= 2 * p.enemyspellpower;

            if (p.ownHero.Hp + p.ownHero.armor > hpboarder)
            {
                retval += p.ownHero.Hp + p.ownHero.armor;
            }
            else
            {
                retval -= (hpboarder + 1 - p.ownHero.Hp - p.ownHero.armor) * (hpboarder + 1 - p.ownHero.Hp - p.ownHero.armor);
            }


            if (p.enemyHero.Hp + p.enemyHero.armor > aggroboarder)
            {
                retval += -p.enemyHero.Hp - p.enemyHero.armor;
            }
            else
            {
                retval += 3 * (aggroboarder + 1 - p.enemyHero.Hp - p.enemyHero.armor);
            }

            if (p.ownWeaponAttack >= 1)
            {
                retval += p.ownWeaponAttack * p.ownWeaponDurability;
            }

            if (!p.enemyHero.frozen)
            {
                retval -= p.enemyWeaponDurability * p.enemyWeaponAttack;
            }
            else
            {
                if (p.enemyWeaponDurability >= 1)
                {
                    retval += 12;
                }
            }

            //RR card draw value depending on the turn and distance to lethal
            //RR if lethal is close, carddraw value is increased
            if (Ai.Instance.lethalMissing <= 5) //RR
            {
                retval += p.owncarddraw * 100;
            }
            if (p.ownMaxMana < 4)
            {
                retval += p.owncarddraw * 2;
            }
            else
            {
                retval += p.owncarddraw * 5;
            }

            retval += p.owncarddraw * 5;
            retval -= p.enemycarddraw * 15;

            //int owntaunt = 0;
            int readycount = 0;
            int ownMinionsCount = 0;
            foreach (Minion m in p.ownMinions)
            {
                retval += 5;
                retval += m.Hp * 2;
                retval += m.Angr * 2;
                retval += m.handcard.card.rarity;
                if (!m.playedThisTurn && m.windfury) retval += m.Angr;
                if (m.divineshild) retval += 1;
                if (m.stealth) retval += 1;
                if (m.handcard.card.isSpecialMinion)
                {
                    retval += 1;
                    if (!m.taunt && m.stealth) retval += 20;
                }
                else
                {
                    if (m.Angr <= 2 && m.Hp <= 2 && !m.divineshild) retval -= 5;
                }
                //if (!m.taunt && m.stealth && penman.specialMinions.ContainsKey(m.name)) retval += 20;
                //if (m.poisonous) retval += 1;
                if (m.divineshild && m.taunt) retval += 4;
                //if (m.taunt && m.handcard.card.name == CardDB.cardName.frog) owntaunt++;
                if (m.Angr > 1 || m.Hp > 1) ownMinionsCount++;
                //if (m.handcard.card.isToken && m.Angr <= 2 && m.Hp <= 2) retval -= 5;
                //if (!penman.specialMinions.ContainsKey(m.name) && m.Angr <= 2 && m.Hp <= 2) retval -= 5;
                if (m.handcard.card.name == CardDB.cardName.direwolfalpha || m.handcard.card.name == CardDB.cardName.flametonguetotem || m.handcard.card.name == CardDB.cardName.stormwindchampion || m.handcard.card.name == CardDB.cardName.raidleader) retval += 10;
                if (m.handcard.card.name == CardDB.cardName.bloodmagethalnos) retval += 10;
                if (m.handcard.card.name == CardDB.cardName.nerubianegg && m.Angr >= 1) retval += 2;
                if (m.Ready) readycount++;
            }

            /*if (p.enemyMinions.Count >= 0)
            {
                int anz = p.enemyMinions.Count;
                if (owntaunt == 0) retval -= 10 * anz;
                retval += owntaunt * 10 - 11 * anz;
            }*/


            bool useAbili = false;
            bool usecoin = false;
            foreach (Action a in p.playactions)
            {
                if (a.actionType == actionEnum.attackWithHero && p.enemyHero.Hp <= p.attackFaceHP) retval++;
                if (a.actionType == actionEnum.useHeroPower) useAbili = true;
                if (p.ownHeroName == HeroEnum.warrior && a.actionType == actionEnum.attackWithHero && useAbili) retval -= 1;
                //if (a.actionType == actionEnum.useHeroPower && a.card.card.name == CardDB.cardName.lesserheal && (!a.target.own)) retval -= 5;
                if (a.actionType != actionEnum.playcard) continue;
                if ((a.card.card.name == CardDB.cardName.thecoin || a.card.card.name == CardDB.cardName.innervate)) usecoin = true;
                //save spell for all classes: (except for rouge if he has no combo)
                if (a.target == null) continue;
                if (p.ownHeroName != HeroEnum.thief && a.card.card.type == CardDB.cardtype.SPELL && (!a.target.own && a.target.isHero) && a.card.card.name != CardDB.cardName.shieldblock) retval -= 11;
                if (p.ownHeroName == HeroEnum.thief && a.card.card.type == CardDB.cardtype.SPELL && (a.target.isHero && !a.target.own)) retval -= 11;
            }
            if (usecoin && useAbili && p.ownMaxMana <= 2) retval -= 40;
            if (usecoin) retval -= 5 * p.manaTurnEnd;
            //if (usecoin && p.mana >= 1) retval -= 20;

            int mobsInHand = 0;
            int bigMobsInHand = 0;
            foreach (Handmanager.Handcard hc in p.owncards)
            {
                if (hc.card.type == CardDB.cardtype.MOB)
                {
                    mobsInHand++;
                    if (hc.card.Attack >= 3) bigMobsInHand++;
                }
            }

            if (ownMinionsCount - p.enemyMinions.Count >= 4 && bigMobsInHand >= 1)
            {
                retval += bigMobsInHand * 25;
            }


            bool hasTank = false;
            foreach (Minion m in p.enemyMinions)
            {
                retval -= this.getEnemyMinionValue(m, p);
                hasTank = hasTank || m.taunt;
            }

            foreach (SecretItem si in p.enemySecretList)
            {
                if (readycount >= 1 && !hasTank && si.canbeTriggeredWithAttackingHero)
                {
                    retval -= 100;
                }
                if (readycount >= 1 && p.enemyMinions.Count >= 1 && si.canbeTriggeredWithAttackingMinion)
                {
                    retval -= 100;
                }
                if (si.canbeTriggeredWithPlayingMinion && mobsInHand >= 1)
                {
                    retval -= 25;
                }
            }

            retval -= p.enemySecretCount;
            retval -= p.lostDamage;//damage which was to high (like killing a 2/1 with an 3/3 -> => lostdamage =2
            retval -= p.lostWeaponDamage;

            //if (p.ownMinions.Count == 0) retval -= 20;
            //if (p.enemyMinions.Count == 0) retval += 20;
            if (p.enemyHero.Hp <= 0) retval = 10000;
            //soulfire etc
            int deletecardsAtLast = 0;
            foreach (Action a in p.playactions)
            {
                if (a.actionType != actionEnum.playcard) continue;
                if (a.card.card.name == CardDB.cardName.soulfire || a.card.card.name == CardDB.cardName.doomguard || a.card.card.name == CardDB.cardName.succubus) deletecardsAtLast = 1;
                if (deletecardsAtLast == 1 && !(a.card.card.name == CardDB.cardName.soulfire || a.card.card.name == CardDB.cardName.doomguard || a.card.card.name == CardDB.cardName.succubus)) retval -= 20;
            }
            if (p.enemyHero.Hp >= 1 && p.guessingHeroHP <= 0)
            {
                if (p.turnCounter < 2) retval += p.owncarddraw * 100;
                retval -= 1000;
            }
            if (p.ownHero.Hp <= 0) retval = -10000;

            p.value = retval;
            return retval;
        }



        public override int getEnemyMinionValue(Minion m, Playfield p)
        {
            int retval = 5;
            retval += m.Hp * 2;
            if (!m.frozen && !((m.name == CardDB.cardName.ancientwatcher || m.name == CardDB.cardName.ragnarosthefirelord) && !m.silenced))
            {
                retval += m.Angr * 2;
                if (m.windfury) retval += m.Angr * 2;
                if (m.Angr >= 4) retval += 10;
                if (m.Angr >= 7) retval += 50;
            }

            if (m.Angr == 0) retval -= 7;

            retval += m.handcard.card.rarity;
            if (m.taunt) retval += 5;
            if (m.divineshild) retval += m.Angr;
            if (m.divineshild && m.taunt) retval += 5;
            if (m.stealth) retval += 1;

            if (m.poisonous) retval += 4;

            if (m.handcard.card.targetPriority >= 1 && !m.silenced)
            {
                retval += m.handcard.card.targetPriority;
            }
            if (m.name == CardDB.cardName.nerubianegg && m.Angr <= 3 && !m.taunt) retval = 0;
            return retval;
        }

    }

    public class BehaviorRush : Behavior
    {
        PenalityManager penman = PenalityManager.Instance;

        public override float getPlayfieldValue(Playfield p)
        {
            if (p.value >= -2000000) return p.value;
            int retval = 0;
            retval -= p.evaluatePenality;
            retval += p.owncards.Count * 3;

            retval += p.ownHero.Hp + p.ownHero.armor;
            retval += -(p.enemyHero.Hp + p.enemyHero.armor);

            retval += p.ownMaxMana * 15 - p.enemyMaxMana * 15;

            if (p.ownWeaponAttack >= 1)
            {
                retval += p.ownWeaponAttack * p.ownWeaponDurability;
            }

            if (!p.enemyHero.frozen)
            {
                retval -= p.enemyWeaponDurability * p.enemyWeaponAttack;
            }
            else
            {
                if (p.enemyHeroName != HeroEnum.mage && p.enemyHeroName != HeroEnum.priest)
                {
                    retval += 11;
                }
            }

            //RR card draw value depending on the turn and distance to lethal
            //RR if lethal is close, carddraw value is increased


            if (Ai.Instance.lethalMissing <= 5) //RR
            {
                retval += p.owncarddraw * 100;
            }
            if (p.ownMaxMana < 4)
            {
                retval += p.owncarddraw * 2;
            }
            else
            {
                retval += p.owncarddraw * 5;
            }
            retval += p.owncarddraw * 5;
            retval -= p.enemycarddraw * 15;

            bool useAbili = false;
            bool usecoin = false;
            foreach (Action a in p.playactions)
            {
                if (a.actionType == actionEnum.attackWithHero && p.enemyHero.Hp <= p.attackFaceHP) retval++;
                if (a.actionType == actionEnum.useHeroPower) useAbili = true;
                if (p.ownHeroName == HeroEnum.warrior && a.actionType == actionEnum.attackWithHero && useAbili) retval -= 1;
                //if (a.actionType == actionEnum.useHeroPower && a.card.card.name == CardDB.cardName.lesserheal && (!a.target.own)) retval -= 5;
                if (a.actionType != actionEnum.playcard) continue;
                if ((a.card.card.name == CardDB.cardName.thecoin || a.card.card.name == CardDB.cardName.innervate)) usecoin = true;
            }
            if (usecoin && useAbili && p.ownMaxMana <= 2) retval -= 40;
            if (usecoin) retval -= 5 * p.manaTurnEnd;
            //if (usecoin && p.mana >= 1) retval -= 20;

            foreach (Minion m in p.ownMinions)
            {
                retval += m.Hp * 1;
                retval += m.Angr * 2;
                retval += m.handcard.card.rarity;
                if (m.windfury) retval += m.Angr;
                if (m.taunt) retval += 1;
                if (!m.taunt && m.stealth && m.handcard.card.isSpecialMinion) retval += 20;
                if (m.handcard.card.name == CardDB.cardName.silverhandrecruit && m.Angr == 1 && m.Hp == 1) retval -= 5;
                if (m.handcard.card.name == CardDB.cardName.direwolfalpha || m.handcard.card.name == CardDB.cardName.flametonguetotem || m.handcard.card.name == CardDB.cardName.stormwindchampion || m.handcard.card.name == CardDB.cardName.raidleader) retval += 10;
            }

            foreach (Minion m in p.enemyMinions)
            {
                retval -= this.getEnemyMinionValue(m, p);
            }

            retval -= p.enemySecretCount;
            retval -= p.lostDamage;//damage which was to high (like killing a 2/1 with an 3/3 -> => lostdamage =2
            retval -= p.lostWeaponDamage;
            if (p.ownMinions.Count == 0) retval -= 20;
            if (p.enemyMinions.Count >= 4) retval -= 20;
            if (p.enemyHero.Hp <= 0) retval = 10000;
            //soulfire etc
            int deletecardsAtLast = 0;
            foreach (Action a in p.playactions)
            {
                if (a.actionType != actionEnum.playcard) continue;
                if (a.card.card.name == CardDB.cardName.soulfire || a.card.card.name == CardDB.cardName.doomguard || a.card.card.name == CardDB.cardName.succubus) deletecardsAtLast = 1;
                if (deletecardsAtLast == 1 && !(a.card.card.name == CardDB.cardName.soulfire || a.card.card.name == CardDB.cardName.doomguard || a.card.card.name == CardDB.cardName.succubus)) retval -= 20;
            }
            if (p.enemyHero.Hp >= 1 && p.guessingHeroHP <= 0)
            {
                if (p.turnCounter < 2) retval += p.owncarddraw * 500;
                retval -= 1000;
            }
            if (p.ownHero.Hp <= 0) retval = -10000;

            p.value = retval;
            return retval;
        }

        public override int getEnemyMinionValue(Minion m, Playfield p)
        {
            int retval = 0;
            if (p.enemyMinions.Count >= 4 || m.taunt || (m.handcard.card.targetPriority >= 1 && !m.silenced) || m.Angr >= 5)
            {
                retval += m.Hp;
                if (!m.frozen && !((m.name == CardDB.cardName.ancientwatcher || m.name == CardDB.cardName.ragnarosthefirelord) && !m.silenced))
                {
                    retval += m.Angr * 2;
                    if (m.windfury) retval += 2 * m.Angr;
                }
                if (m.taunt) retval += 5;
                if (m.divineshild) retval += m.Angr;
                if (m.frozen) retval -= 1; // because its bad for enemy :D
                if (m.poisonous) retval += 4;
                retval += m.handcard.card.rarity;
            }


            if (m.handcard.card.targetPriority >= 1 && !m.silenced) retval += m.handcard.card.targetPriority;
            if (m.Angr >= 4) retval += 20;
            if (m.Angr >= 7) retval += 50;
            if (m.name == CardDB.cardName.nerubianegg && m.Angr <= 3 && !m.taunt) retval = 0;
            return retval;
        }


    }

    public class BehaviorMana : Behavior
    {
        PenalityManager penman = PenalityManager.Instance;

        public override float getPlayfieldValue(Playfield p)
        {
            if (p.value >= -2000000) return p.value;
            int retval = 0;

            retval += p.ownHero.Hp + p.ownHero.armor;
            retval -= (p.enemyHero.Hp + p.enemyHero.armor);

            foreach (Minion m in p.ownMinions)
            {
                retval += this.getEnemyMinionValue(m, p);
            }

            foreach (Minion m in p.enemyMinions)
            {
                retval -= this.getEnemyMinionValue(m, p);
            }

            foreach (Handmanager.Handcard hc in p.owncards)
            {
                int r = Math.Max(hc.getManaCost(p), 1);
                if (hc.card.name == CardDB.cardName.unknown) r = 4;
                retval += r;
            }

            retval -= p.enemySecretCount;
            retval -= p.lostDamage;//damage which was to high (like killing a 2/1 with an 3/3 -> => lostdamage =2
            retval -= p.lostWeaponDamage;
            if (p.enemyHero.Hp <= 0) retval = 10000;
            if (p.enemyHero.Hp >= 1 && p.guessingHeroHP <= 0)
            {
                retval += p.owncarddraw * 500;
                retval -= 1000;
            }
            if (p.ownHero.Hp <= 0) retval = -10000;

            p.value = retval;
            return retval;
        }

        public override int getEnemyMinionValue(Minion m, Playfield p)
        {
            int retval = 0;
            retval += m.handcard.card.cost;
            if (m.handcard.card.name == CardDB.cardName.unknown) retval = 4;
            return retval;
        }


    }

    public enum TAG_RACE
    {
        INVALID,
        BLOODELF,
        DRAENEI,
        DWARF,
        GNOME,
        GOBLIN,
        HUMAN,
        NIGHTELF,
        ORC,
        TAUREN,
        TROLL,
        UNDEAD,
        WORGEN,
        GOBLIN2,
        MURLOC,
        DEMON,
        SCOURGE,
        MECHANICAL,
        ELEMENTAL,
        OGRE,
        PET,
        TOTEM,
        NERUBIAN,
        PIRATE,
        DRAGON
    }

    public enum CHOICE_TYPE
    {
        INVALID,
        MULLIGAN,
        GENERAL
    }

    public class SimTemplate
    {

        public virtual void onSecretPlay(Playfield p, bool ownplay, Minion attacker, Minion target, out int number)
        {
            number = 0;
        }

        public virtual void onSecretPlay(Playfield p, bool ownplay, Minion target, int number)
        {
            return;
        }

        public virtual void onSecretPlay(Playfield p, bool ownplay, int number)
        {
            return;
        }



        public virtual void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            return;
        }

        public virtual void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            return;
        }

        public virtual void onAuraStarts(Playfield p, Minion m)
        {
            return;
        }

        public virtual void onAuraEnds(Playfield p, Minion m)
        {
            return;
        }


        public virtual void onEnrageStart(Playfield p, Minion m)
        {
            return;
        }

        public virtual void onEnrageStop(Playfield p, Minion m)
        {
            return;
        }

        public virtual void onAMinionGotHealedTrigger(Playfield p, Minion triggerEffectMinion, bool ownerOfMinionGotHealed)
        {
            return;
        }

        public virtual void onAHeroGotHealedTrigger(Playfield p, Minion triggerEffectMinion, bool ownerOfHeroGotHealed)
        {
            return;
        }


        public virtual void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            return;
        }

        public virtual void onTurnStartTrigger(Playfield p, Minion triggerEffectMinion, bool turnStartOfOwner)
        {
            return;
        }

        public virtual void onMinionGotDmgTrigger(Playfield p, Minion triggerEffectMinion, bool ownDmgdMinion)
        {
            return;
        }

        public virtual void onMinionDiedTrigger(Playfield p, Minion triggerEffectMinion, Minion diedMinion)
        {
            return;
        }

        public virtual void onMinionIsSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            return;
        }

        public virtual void onMinionWasSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            return;
        }

        public virtual void onDeathrattle(Playfield p, Minion m)
        {
            return;
        }

        public virtual void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            return;
        }

        public virtual void onCardWasPlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            return;
        }




    }

    class Sim_CS1h_001 : SimTemplate //lesserheal
    {

        //    heldenfähigkeit/\nstellt 2 leben wieder her.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int heal = 2;
            if (ownplay)
            {
                if (p.anzOwnAuchenaiSoulpriest >= 1) heal = -heal;
                if (p.doublepriest >= 1) heal *= (2 * p.doublepriest);
            }
            else
            {
                if (p.anzEnemyAuchenaiSoulpriest >= 1) heal = -heal;
                if (p.enemydoublepriest >= 1) heal *= (2 * p.enemydoublepriest);
            }
            p.minionGetDamageOrHeal(target, -heal);


        }

    }

    class Sim_CS1_042 : SimTemplate //goldshirefootman
    {

        //    spott/


    }

    class Sim_CS1_069 : SimTemplate //fencreeper
    {

        //    spott/


    }

    class Sim_CS1_112 : SimTemplate//holy nova
    {
        //todo make it better :D
        //FÃ¼gt allen Feinden $2 Schaden zu. Stellt bei allen befreundeten Charakteren #2 Leben wieder her.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            int heal = (ownplay) ? p.getSpellHeal(2) : p.getEnemySpellHeal(2);
            if (ownplay)
            {
                p.minionGetDamageOrHeal(p.ownHero, -heal);
                p.minionGetDamageOrHeal(p.enemyHero, dmg);
                foreach (Minion m in p.ownMinions)
                {
                    p.minionGetDamageOrHeal(m, -heal);
                }

                foreach (Minion m in p.enemyMinions)
                {
                    p.minionGetDamageOrHeal(m, dmg);
                }
            }
            else
            {
                p.minionGetDamageOrHeal(p.enemyHero, -heal);
                p.minionGetDamageOrHeal(p.ownHero, dmg);
                foreach (Minion m in p.enemyMinions)
                {
                    p.minionGetDamageOrHeal(m, -heal);
                }

                foreach (Minion m in p.ownMinions)
                {
                    p.minionGetDamageOrHeal(m, dmg);
                }
            }
        }

    }

    class Sim_CS1_113 : SimTemplate //mindcontrol
    {

        //    übernehmt die kontrolle über einen feindlichen diener.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetControlled(target, ownplay, false);
        }

    }

    class Sim_CS1_129 : SimTemplate //innerfire
    {

        //    setzt den angriff eines dieners auf einen wert, der seinem leben entspricht.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionSetAngrToHP(target);
        }

    }

    class Sim_CS1_130 : SimTemplate //holysmite
    {

        //    verursacht $2 schaden.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_CS2_003 : SimTemplate//Mind Vision
    {

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int anz = (ownplay) ? p.enemyAnzCards : p.owncards.Count;
            if (anz >= 1)
            {
                p.drawACard(CardDB.cardName.unknown, ownplay, true);
            }
        }

    }

    class Sim_CS2_004 : SimTemplate //powerwordshield
    {

        //    verleiht einem diener +2 leben.\nzieht eine karte.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 0, 2);
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_CS2_005 : SimTemplate //claw
    {

        //    verleiht eurem helden +2 angriff in diesem zug und 2 rüstung.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                p.minionGetArmor(p.ownHero, 2);
                p.minionGetTempBuff(p.ownHero, 2, 0);
            }
            else
            {
                p.minionGetArmor(p.enemyHero, 2);
                p.minionGetTempBuff(p.enemyHero, 2, 0);
            }
        }

    }

    class Sim_CS2_007 : SimTemplate //healingtouch
    {

        //    stellt #8 leben wieder her.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int heal = (ownplay) ? p.getSpellHeal(8) : p.getEnemySpellHeal(8);
            p.minionGetDamageOrHeal(target, -heal);

        }

    }

    class Sim_CS2_008 : SimTemplate//moonfire
    {

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            p.minionGetDamageOrHeal(target, dmg);

        }

    }

    class Sim_CS2_009 : SimTemplate//Mark of the Wild
    {

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            target.taunt = true;
            p.minionGetBuffed(target, 2, 2);
        }

    }

    class Sim_CS2_011 : SimTemplate //savageroar
    {

        //    verleiht euren charakteren +2 angriff in diesem zug.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;
            foreach (Minion t in temp)
            {
                p.minionGetTempBuff(t, 2, 0);
            }
            p.minionGetTempBuff(ownplay ? p.ownHero : p.enemyHero, 2, 0);
        }

    }

    class Sim_CS2_012 : SimTemplate //swipe
    {

        //    fügt einem feind $4 schaden und allen anderen feinden $1 schaden zu.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            int dmg1 = (ownplay) ? p.getSpellDamageDamage(4) : p.getEnemySpellDamageDamage(4);

            List<Minion> temp = (ownplay) ? p.enemyMinions : p.ownMinions;
            p.minionGetDamageOrHeal(target, dmg1);
            foreach (Minion m in temp)
            {
                if (m.entitiyID != target.entitiyID)
                {
                    p.minionGetDamageOrHeal(m, dmg);
                }
            }
            if (ownplay)
            {
                if (p.enemyHero.entitiyID != target.entitiyID)
                {
                    p.minionGetDamageOrHeal(p.enemyHero, dmg);
                }
            }
            else
            {
                if (p.ownHero.entitiyID != target.entitiyID)
                {
                    p.minionGetDamageOrHeal(p.ownHero, dmg);
                }

            }
        }

    }

    class Sim_CS2_013 : SimTemplate //wildgrowth
    {

        //    erhaltet einen leeren manakristall.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                if (p.ownMaxMana < 10)
                {
                    p.ownMaxMana++;
                }
                else
                {
                    p.drawACard(CardDB.cardName.excessmana, true, true);
                }

            }
            else
            {
                if (p.enemyMaxMana < 10)
                {
                    p.enemyMaxMana++;
                }
                else
                {
                    p.drawACard(CardDB.cardName.excessmana, false, true);
                }
            }
        }

    }

    class Sim_CS2_013t : SimTemplate //excessmana
    {

        //    zieht eine karte. i&gt;(ihr könnt nur 10 mana in eurer leiste haben.)/i&gt;
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_CS2_017 : SimTemplate //shapeshift
    {

        //    heldenfähigkeit/\n+1 angriff in diesem zug.\n+1 rüstung.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                p.minionGetTempBuff(p.ownHero, 1, 0);
                p.minionGetArmor(p.ownHero, 1);
            }
            else
            {
                p.minionGetTempBuff(p.enemyHero, 1, 0);
                p.minionGetArmor(p.enemyHero, 1);
            }
        }

    }

    class Sim_CS2_022 : SimTemplate//Polymorph
    {

        private CardDB.Card sheep = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_tk1);

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionTransform(target, sheep);
        }

    }

    class Sim_CS2_023 : SimTemplate //arcaneintellect
    {

        //    zieht 2 karten.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, ownplay);
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_CS2_024 : SimTemplate//Frostbolt
    {

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);
            target.frozen = true;
            p.minionGetDamageOrHeal(target, dmg);

        }

    }

    class Sim_CS2_025 : SimTemplate //arcaneexplosion
    {

        //    fügt allen feindlichen dienern $1 schaden zu.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            p.allMinionOfASideGetDamage(!ownplay, dmg);
        }

    }

    class Sim_CS2_026 : SimTemplate //frostnova
    {

        //    friert/ alle feindlichen diener ein.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            List<Minion> temp = (ownplay) ? p.enemyMinions : p.ownMinions;
            foreach (Minion t in temp)
            {
                t.frozen = true;
            }
        }
    }

    class Sim_CS2_027 : SimTemplate //mirrorimage
    {
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_mirror);
        //    ruft zwei diener (0/2) mit spott/ herbei.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;

            p.callKid(kid, posi, ownplay);
            p.callKid(kid, posi, ownplay);
        }

    }

    class Sim_CS2_028 : SimTemplate //blizzard
    {

        //    fügt allen feindlichen dienern $2 schaden zu und friert/ sie ein.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            p.allMinionOfASideGetDamage(!ownplay, dmg, true);
        }

    }

    class Sim_CS2_029 : SimTemplate //fireball
    {

        //    verursacht $6 schaden.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(6) : p.getEnemySpellDamageDamage(6);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_CS2_031 : SimTemplate //icelance
    {

        //    friert/ einen charakter ein. wenn er bereits eingefroren/ ist, werden ihm stattdessen $4 schaden zugefügt.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(4) : p.getEnemySpellDamageDamage(4);


            if (target.frozen)
            {
                p.minionGetDamageOrHeal(target, dmg);
            }
            else
            {
                target.frozen = true;
            }


        }

    }

    class Sim_CS2_032 : SimTemplate //flamestrike
    {

        //    fügt allen feindlichen dienern $4 schaden zu.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(4) : p.getEnemySpellDamageDamage(4);
            p.allMinionOfASideGetDamage(!ownplay, dmg);
        }

    }

    class Sim_CS2_033 : SimTemplate //waterelemental
    {

        //    friert/ jeden charakter ein, der von diesem diener verletzt wurde.

    }

    class Sim_CS2_034 : SimTemplate //fireblast
    {

        //    heldenfähigkeit/\nverursacht 1 schaden.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = 1;
            if (ownplay)
            {
                if (p.doublepriest >= 1) dmg *= (2 * p.doublepriest);
            }
            else
            {
                if (p.enemydoublepriest >= 1) dmg *= (2 * p.enemydoublepriest);
            }
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_CS2_037 : SimTemplate //frostshock
    {

        //    fügt einem feindlichen charakter $1 schaden zu und friert/ ihn ein.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            target.frozen = true;
            p.minionGetDamageOrHeal(target, dmg);

        }

    }

    class Sim_CS2_038 : SimTemplate //ancestralspirit
    {

        //    verleiht einem diener „todesröcheln:/ ruft diesen diener erneut herbei.“
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            target.ancestralspirit++;
        }

    }

    class Sim_CS2_039 : SimTemplate //windfury
    {

        //    verleiht einem diener windzorn/.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetWindfurry(target);
        }

    }

    class Sim_CS2_041 : SimTemplate //ancestralhealing
    {

        //    stellt das volle leben eines dieners wieder her und verleiht ihm spott/.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            target.taunt = true;
            int heal = (ownplay) ? p.getSpellHeal(target.maxHp) : p.getEnemySpellHeal(target.maxHp);
            p.minionGetDamageOrHeal(target, -heal);
        }

    }

    class Sim_CS2_042 : SimTemplate //fireelemental
    {

        //    kampfschrei:/ verursacht 3 schaden.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int dmg = 3;
            p.minionGetDamageOrHeal(target, dmg);

        }

    }

    class Sim_CS2_045 : SimTemplate //rockbiterweapon
    {

        //    verleiht einem befreundeten charakter +3 angriff in diesem zug.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetTempBuff(target, 3, 0);
        }

    }

    class Sim_CS2_046 : SimTemplate //bloodlust
    {

        //    verleiht euren dienern +3 angriff in diesem zug.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;
            foreach (Minion m in temp)
            {
                p.minionGetTempBuff(m, 3, 0);
            }
        }

    }

    class Sim_CS2_049 : SimTemplate //totemiccall
    {

        //    heldenfähigkeit/\nbeschwört ein zufälliges totem.
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_050);//
        CardDB.Card kid2 = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_052);//
        //    heldenfähigkeit/\nruft einen rekruten der silbernen hand (1/1) herbei.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;
            bool spawnspellpower = true;
            foreach (Minion m in (ownplay) ? p.ownMinions : p.enemyMinions)
            {
                if (m.handcard.card.cardIDenum == CardDB.cardIDEnum.CS2_052)
                {
                    spawnspellpower = false;
                    break;
                }
            }
            p.callKid((spawnspellpower) ? kid2 : kid, posi, ownplay);
        }
    }

    class Sim_CS2_050 : SimTemplate //searingtotem
    {

        // fire totem of shaman ability


    }

    class Sim_CS2_051 : SimTemplate //stoneclawtotem
    {

        //    spott/


    }

    class Sim_CS2_052 : SimTemplate //wrathofairtotem
    {

        //    zauberschaden +1/
        public override void onAuraStarts(Playfield p, Minion m)
        {
            if (m.own)
            {
                p.spellpower++;
            }
            else
            {
                p.enemyspellpower++;
            }
        }


        public override void onAuraEnds(Playfield p, Minion m)
        {
            if (m.own)
            {
                p.spellpower--;
            }
            else
            {
                p.enemyspellpower--;
            }
        }

    }

    class Sim_CS2_053 : SimTemplate//far sight
    {

        //todo: bonus for it?
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_CS2_056 : SimTemplate //lifetap
    {

        //    heldenfähigkeit/\nzieht eine karte und erleidet 2 schaden.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, ownplay);

            int dmg = 2;
            if (ownplay)
            {
                if (p.doublepriest >= 1) dmg *= (2 * p.doublepriest);
                p.minionGetDamageOrHeal(p.ownHero, dmg);
            }
            else
            {
                if (p.enemydoublepriest >= 1) dmg *= (2 * p.enemydoublepriest);
                p.minionGetDamageOrHeal(p.enemyHero, dmg);
            }
        }


    }

    class Sim_CS2_057 : SimTemplate //shadowbolt
    {

        //    fügt einem diener $4 schaden zu.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(4) : p.getEnemySpellDamageDamage(4);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_CS2_059 : SimTemplate //bloodimp
    {

        //    verstohlenheit/. verleiht am ende eures zuges einem anderen zufälligen befreundeten diener +1 leben.

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            List<Minion> temp2 = new List<Minion>((turnEndOfOwner) ? p.ownMinions : p.enemyMinions);
            temp2.Sort((a, b) => a.Hp.CompareTo(b.Hp));//buff the weakest
            foreach (Minion mins in temp2)
            {
                if (triggerEffectMinion.entitiyID == mins.entitiyID) continue;
                p.minionGetBuffed(mins, 0, 1);
                break;
            }
        }

    }

    class Sim_CS2_061 : SimTemplate //drainlife
    {

        //    verursacht $2 schaden. stellt bei eurem helden #2 leben wieder her.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            int heal = (ownplay) ? p.getSpellHeal(2) : p.getEnemySpellHeal(2);
            p.minionGetDamageOrHeal(target, dmg);

            p.minionGetDamageOrHeal(ownplay ? p.ownHero : p.enemyHero, -heal);
        }

    }

    class Sim_CS2_062 : SimTemplate //hellfire
    {

        //    fügt allen charakteren $3 schaden zu.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);
            p.allCharsGetDamage(dmg);
        }

    }

    class Sim_CS2_063 : SimTemplate //corruption
    {

        //    wählt einen feindlichen diener aus. vernichtet ihn zu beginn eures zuges.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            //if ownplay == true -> destroyOnOwnturnstart =true   else  destroyonenemyturnstart
            target.destroyOnOwnTurnStart = target.destroyOnOwnTurnStart || ownplay;
            target.destroyOnEnemyTurnStart = target.destroyOnEnemyTurnStart || !ownplay;

        }

    }

    class Sim_CS2_064 : SimTemplate //dreadinfernal
    {

        //    kampfschrei:/ fügt allen anderen charakteren 1 schaden zu.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int dmg = 1;
            p.allCharsGetDamage(dmg); // dreadinfernal is not on board yet!
        }
    }

    class Sim_CS2_065 : SimTemplate //voidwalker
    {

        //    spott/


    }

    class Sim_CS2_072 : SimTemplate //backstab
    {

        //    fügt einem unverletzten diener $2 schaden zu.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_CS2_073 : SimTemplate //coldblood
    {

        //    verleiht einem diener +2 angriff. combo:/ stattdessen +4 angriff.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int ag = (p.cardsPlayedThisTurn >= 1 || !ownplay) ? 4 : 2; // we suggest, whether enemy is playing this, it is combo
            p.minionGetBuffed(target, ag, 0);
        }

    }

    class Sim_CS2_074 : SimTemplate //deadlypoison
    {

        //    eure waffe erhält +2 angriff.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                if (p.ownWeaponDurability >= 1)
                {
                    p.ownWeaponAttack += 2;
                    p.ownHero.Angr += 2;
                }
            }
            else
            {
                if (p.enemyWeaponDurability >= 1)
                {
                    p.enemyWeaponAttack += 2;
                    p.enemyHero.Angr += 2;
                }
            }
        }

    }

    class Sim_CS2_075 : SimTemplate //sinisterstrike
    {

        //    fügt dem feindlichen helden $3 schaden zu.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);

            p.minionGetDamageOrHeal(ownplay ? p.enemyHero : p.ownHero, dmg);

        }

    }

    class Sim_CS2_076 : SimTemplate//Assassinate
    {

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetDestroyed(target);
        }

    }

    class Sim_CS2_077 : SimTemplate //sprint
    {

        //    zieht 4 karten.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, ownplay);
            p.drawACard(CardDB.cardName.unknown, ownplay);
            p.drawACard(CardDB.cardName.unknown, ownplay);
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_CS2_080 : SimTemplate //assassinsblade
    {

        //
        CardDB.Card w = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_080);

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(w, ownplay);
        }

    }

    class Sim_CS2_082 : SimTemplate //wickedknife
    {

        //    tückisches messer

    }

    class Sim_CS2_083b : SimTemplate //daggermastery
    {

        //    heldenfähigkeit/\nlegt einen dolch (1/2) an.
        CardDB.Card weapon = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_082);
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(weapon, ownplay);
        }

    }

    class Sim_CS2_084 : SimTemplate //huntersmark
    {

        //    setzt das leben eines dieners auf 1.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionSetLifetoOne(target);
        }

    }

    class Sim_CS2_087 : SimTemplate//Blessing of Might
    {
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 3, 0);
        }

    }

    class Sim_CS2_088 : SimTemplate //guardianofkings
    {

        //    kampfschrei:/ stellt bei eurem helden 6 leben wieder her.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int heal = (own.own) ? p.getMinionHeal(6) : p.getEnemyMinionHeal(6);

            p.minionGetDamageOrHeal(own.own ? p.ownHero : p.enemyHero, -heal);
        }


    }

    class Sim_CS2_089 : SimTemplate //holylight
    {

        //    stellt #6 leben wieder her.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int heal = (ownplay) ? p.getSpellHeal(6) : p.getEnemySpellHeal(6);
            p.minionGetDamageOrHeal(target, -heal);
        }

    }

    class Sim_CS2_091 : SimTemplate //lightsjustice
    {

        //
        CardDB.Card w = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_091);

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(w, ownplay);
        }
    }

    class Sim_CS2_092 : SimTemplate//blessing of kings
    {

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 4, 4);
        }

    }

    class Sim_CS2_093 : SimTemplate //consecration
    {

        //    fügt allen feinden $2 schaden zu.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            p.allCharsOfASideGetDamage(!ownplay, dmg);
        }

    }

    class Sim_CS2_094 : SimTemplate //hammerofwrath
    {

        //    verursacht $3 schaden. zieht eine karte.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);
            p.minionGetDamageOrHeal(target, dmg);
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_CS2_097 : SimTemplate //truesilverchampion
    {

        CardDB.Card card = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_097);
        //
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(card, ownplay);
        }

    }

    class Sim_CS2_101 : SimTemplate //reinforce
    {

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_101t);//silverhandrecruit

        //    heldenfähigkeit/\nruft einen rekruten der silbernen hand (1/1) herbei.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;

            p.callKid(kid, posi, ownplay);
        }

    }

    class Sim_CS2_101t : SimTemplate //silverhandrecruit
    {

        //


    }

    class Sim_CS2_102 : SimTemplate //armorup
    {

        //    heldenfähigkeit/\nerhaltet 2 rüstung.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                p.minionGetArmor(p.ownHero, 2);
            }
            else
            {
                p.minionGetArmor(p.enemyHero, 2);
            }
        }

    }

    class Sim_CS2_103 : SimTemplate//Charge
    {
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 2, 0);
            p.minionGetCharge(target);
        }

    }

    class Sim_CS2_104 : SimTemplate //rampage
    {

        //    verleiht einem verletzten diener +3/+3.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 3, 3);
        }

    }

    class Sim_CS2_105 : SimTemplate //heroicstrike
    {

        //    verleiht eurem helden +4 angriff in diesem zug.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetTempBuff(ownplay ? p.ownHero : p.enemyHero, 4, 0);

        }

    }

    class Sim_CS2_106 : SimTemplate //fierywaraxe
    {
        CardDB.Card card = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_106);
        //
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(card, ownplay);
        }

    }

    class Sim_CS2_108 : SimTemplate //execute
    {

        //    vernichtet einen verletzten feindlichen diener.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetDestroyed(target);
        }

    }

    class Sim_CS2_112 : SimTemplate //arcanitereaper
    {

        CardDB.Card card = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_112);
        //
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(card, ownplay);
        }

    }

    class Sim_CS2_114 : SimTemplate //cleave
    {

        //    fügt zwei zufälligen feindlichen dienern $2 schaden zu.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            //TODO delete new list
            int damage = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            List<Minion> temp2 = (ownplay) ? new List<Minion>(p.enemyMinions) : new List<Minion>(p.ownMinions);
            temp2.Sort((a, b) => a.Hp.CompareTo(b.Hp));
            int i = 0;
            foreach (Minion enemy in temp2)
            {
                p.minionGetDamageOrHeal(enemy, damage);
                i++;
                if (i == 2) break;
            }


        }

    }

    class Sim_CS2_117 : SimTemplate //earthenringfarseer
    {

        //    kampfschrei:/ stellt 3 leben wieder her.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int heal = (own.own) ? p.getMinionHeal(3) : p.getEnemyMinionHeal(3);
            p.minionGetDamageOrHeal(target, -heal);
        }

    }

    class Sim_CS2_118 : SimTemplate //magmarager
    {

        //

    }

    class Sim_CS2_119 : SimTemplate //oasissnapjaw
    {

        //

    }

    class Sim_CS2_120 : SimTemplate //rivercrocolisk
    {

        //

    }

    class Sim_CS2_121 : SimTemplate //frostwolfgrunt
    {

        //    spott/


    }

    class Sim_CS2_122 : SimTemplate //raidleader
    {

        //    eure anderen diener haben +1 angriff.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnRaidleader++;
                foreach (Minion m in p.ownMinions)
                {
                    if (own.entitiyID != m.entitiyID) p.minionGetBuffed(m, 1, 0);
                }
            }
            else
            {
                p.anzEnemyRaidleader++;
                foreach (Minion m in p.enemyMinions)
                {
                    if (own.entitiyID != m.entitiyID) p.minionGetBuffed(m, 1, 0);
                }
            }

        }

        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnRaidleader--;
                foreach (Minion m in p.ownMinions)
                {
                    if (own.entitiyID != m.entitiyID) p.minionGetBuffed(m, -1, 0);
                }
            }
            else
            {
                p.anzEnemyRaidleader--;
                foreach (Minion m in p.enemyMinions)
                {
                    if (own.entitiyID != m.entitiyID) p.minionGetBuffed(m, -1, 0);
                }
            }
        }

    }

    class Sim_CS2_124 : SimTemplate //wolfrider
    {

        //    ansturm/

    }

    class Sim_CS2_125 : SimTemplate //ironfurgrizzly
    {

        //    spott/


    }

    class Sim_CS2_127 : SimTemplate //silverbackpatriarch
    {

        //    spott/


    }

    class Sim_CS2_131 : SimTemplate //stormwindknight
    {

        //    ansturm/


    }

    class Sim_CS2_141 : SimTemplate //ironforgerifleman
    {

        //    kampfschrei:/ verursacht 1 schaden.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int dmg = 1;
            p.minionGetDamageOrHeal(target, dmg);
        }


    }

    class Sim_CS2_142 : SimTemplate //koboldgeomancer
    {

        //    zauberschaden +1/
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.spellpower++;
            }
            else
            {
                p.enemyspellpower++;
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {

            if (m.own)
            {
                p.spellpower--;
            }
            else
            {
                p.enemyspellpower--;
            }
        }

    }

    class Sim_CS2_146 : SimTemplate //southseadeckhand
    {

        //    hat ansturm/, während ihr eine waffe angelegt habt.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                if (p.ownWeaponDurability >= 1)
                {
                    p.minionGetCharge(own);
                }
            }
            else
            {
                if (p.enemyWeaponDurability >= 1)
                {
                    p.minionGetCharge(own);
                }
            }
        }

    }

    class Sim_CS2_147 : SimTemplate //gnomishinventor
    {

        //    kampfschrei:/ zieht eine karte.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, own.own);
        }


    }

    class Sim_CS2_150 : SimTemplate //stormpikecommando
    {

        //    kampfschrei:/ verursacht 2 schaden.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.minionGetDamageOrHeal(target, 2);
        }


    }

    class Sim_CS2_151 : SimTemplate //silverhandknight
    {
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_152);//squire
        //    kampfschrei:/ ruft einen knappen (2/2) herbei.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.callKid(kid, own.zonepos, own.own, true);
        }

    }

    class Sim_CS2_152 : SimTemplate //squire
    {

        //


    }

    class Sim_CS2_155 : SimTemplate //archmage
    {

        //    zauberschaden +1/
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.spellpower++;
            }
            else
            {
                p.enemyspellpower++;
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {

            if (m.own)
            {
                p.spellpower--;
            }
            else
            {
                p.enemyspellpower--;
            }
        }


    }

    class Sim_CS2_161 : SimTemplate //ravenholdtassassin
    {

        //    verstohlenheit/

    }

    class Sim_CS2_162 : SimTemplate//Lord of the Arena
    {



    }

    class Sim_CS2_168 : SimTemplate //murlocraider
    {

        //

    }

    class Sim_CS2_169 : SimTemplate //youngdragonhawk
    {

        //    windzorn/

    }

    class Sim_CS2_171 : SimTemplate //stonetuskboar
    {

        //    ansturm/

    }

    class Sim_CS2_172 : SimTemplate //bloodfenraptor
    {

        //


    }

    class Sim_CS2_173 : SimTemplate //bluegillwarrior
    {

        //    ansturm/

    }

    class Sim_CS2_179 : SimTemplate//senjien shieldmasta
    {


    }

    class Sim_CS2_181 : SimTemplate//Injured Blademaster
    {

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {

            p.minionGetDamageOrHeal(own, 4);
        }

    }

    class Sim_CS2_182 : SimTemplate//Chillwind Yeti
    {

    }

    class Sim_CS2_186 : SimTemplate //wargolem
    {

        //


    }

    class Sim_CS2_187 : SimTemplate //bootybaybodyguard
    {

        //    spott/

    }

    class Sim_CS2_188 : SimTemplate //abusivesergeant
    {

        //    kampfschrei:/ verleiht einem diener +2 angriff in diesem zug.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionGetTempBuff(target, 2, 0);
        }


    }

    class Sim_CS2_189 : SimTemplate //elvenarcher
    {

        //    kampfschrei:/ verursacht 1 schaden.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int dmg = 1;
            p.minionGetDamageOrHeal(target, dmg);
        }


    }

    class Sim_CS2_196 : SimTemplate //razorfenhunter
    {
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_boar);//boar
        //    kampfschrei:/ ruft einen eber (1/1) herbei.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {

            p.callKid(kid, own.zonepos, own.own, true);
        }

    }

    class Sim_CS2_197 : SimTemplate //ogremagi
    {

        //    zauberschaden +1/
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.spellpower++;
            }
            else
            {
                p.enemyspellpower++;
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {

            if (m.own)
            {
                p.spellpower--;
            }
            else
            {
                p.enemyspellpower--;
            }
        }

    }

    class Sim_CS2_200 : SimTemplate //boulderfistogre
    {

        //


    }

    class Sim_CS2_201 : SimTemplate //corehound
    {

        //

    }

    class Sim_CS2_203 : SimTemplate //ironbeakowl
    {

        //    kampfschrei:/ bringt einen diener zum schweigen/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionGetSilenced(target);
        }


    }

    class Sim_CS2_213 : SimTemplate //recklessrocketeer
    {

        //    ansturm/


    }

    class Sim_CS2_221 : SimTemplate //spitefulsmith
    {

        //    wutanfall:/ eure waffe hat +2 angriff.
        public override void onEnrageStart(Playfield p, Minion m)
        {
            if (m.own)
            {
                if (p.ownWeaponDurability >= 1)
                {
                    p.minionGetBuffed(p.ownHero, 2, 0);
                    p.ownWeaponAttack += 2;
                }
            }
            else
            {
                if (p.enemyWeaponDurability >= 1)
                {
                    p.enemyWeaponAttack += 2;
                    p.minionGetBuffed(p.enemyHero, 2, 0);
                }
            }
        }

        public override void onEnrageStop(Playfield p, Minion m)
        {
            if (m.own)
            {
                if (p.ownWeaponDurability >= 1)
                {
                    p.minionGetBuffed(p.ownHero, -2, 0);
                    p.ownWeaponAttack -= 2;
                }
            }
            else
            {
                if (p.enemyWeaponDurability >= 1)
                {
                    p.enemyWeaponAttack -= 2;
                    p.minionGetBuffed(p.enemyHero, -2, 0);
                }
            }
        }

    }

    class Sim_CS2_222 : SimTemplate //stormwindchampion
    {

        //    eure anderen diener haben +1/+1.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnStormwindChamps++;
                foreach (Minion m in p.ownMinions)
                {
                    if (own.entitiyID != m.entitiyID) p.minionGetBuffed(m, 1, 1);
                }
            }
            else
            {
                p.anzEnemyStormwindChamps++;
                foreach (Minion m in p.enemyMinions)
                {
                    if (own.entitiyID != m.entitiyID) p.minionGetBuffed(m, 1, 1);
                }
            }

        }

        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnStormwindChamps--;
                foreach (Minion m in p.ownMinions)
                {
                    if (own.entitiyID != m.entitiyID) p.minionGetBuffed(m, -1, -1);
                }
            }
            else
            {
                p.anzEnemyStormwindChamps--;
                foreach (Minion m in p.enemyMinions)
                {
                    if (own.entitiyID != m.entitiyID) p.minionGetBuffed(m, -1, -1);
                }
            }
        }

    }

    class Sim_CS2_226 : SimTemplate //frostwolfwarlord
    {

        //    kampfschrei:/ erhält +1/+1 für jeden anderen befreundeten diener auf dem schlachtfeld.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int buff = (own.own) ? p.ownMinions.Count : p.enemyMinions.Count;
            p.minionGetBuffed(own, buff, buff);
        }

    }

    class Sim_CS2_227 : SimTemplate //venturecomercenary
    {

        //    eure diener kosten (3) mehr.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own) p.soeldnerDerVenture++;
        }

        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own) p.soeldnerDerVenture--;
        }

    }

    class Sim_CS2_231 : SimTemplate//wisp
    {


    }

    class Sim_CS2_232 : SimTemplate //ironbarkprotector
    {

        //    spott/


    }

    class Sim_CS2_233 : SimTemplate//Blade Flurry
    {


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int damage = (ownplay) ? p.getSpellDamageDamage(p.ownWeaponAttack) : p.getEnemySpellDamageDamage(p.enemyWeaponAttack);

            p.allCharsOfASideGetDamage(!ownplay, damage);
            //destroy own weapon
            p.lowerWeaponDurability(1000, true);
        }

    }

    class Sim_CS2_234 : SimTemplate //shadowwordpain
    {

        //    vernichtet einen diener mit max. 3 angriff.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetDestroyed(target);
        }


    }

    class Sim_CS2_235 : SimTemplate //northshirecleric
    {

        //    zieht jedes mal eine karte, wenn ein diener geheilt wird.

        public override void onAMinionGotHealedTrigger(Playfield p, Minion triggerEffectMinion, bool ownerOfMinionGotHealed)
        {
            p.drawACard(CardDB.cardName.unknown, triggerEffectMinion.own);
        }

    }

    class Sim_CS2_236 : SimTemplate //divinespirit
    {

        //    verdoppelt das leben eines dieners.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 0, target.Hp);
        }

    }

    class Sim_CS2_237 : SimTemplate //starvingbuzzard
    {

        //    zieht jedes mal eine karte, wenn ihr ein wildtier herbeiruft.
        public override void onMinionIsSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            if (triggerEffectMinion.own == summonedMinion.own && (TAG_RACE)summonedMinion.handcard.card.race == TAG_RACE.PET)
            {
                p.drawACard(CardDB.cardName.unknown, triggerEffectMinion.own);
            }
        }

    }

    class Sim_CS2_boar : SimTemplate //boar
    {

        //


    }

    class Sim_CS2_mirror : SimTemplate //mirrorimage
    {

        //    spott/


    }

    class Sim_CS2_tk1 : SimTemplate //sheep
    {

        //


    }

    class Sim_DREAM_01 : SimTemplate //laughingsister
    {

        //    kann nicht als ziel von zaubern oder heldenfähigkeiten gewählt werden.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            own.cantBeTargetedBySpellsOrHeroPowers = true;
        }
    }

    class Sim_DREAM_02 : SimTemplate //yseraawakens
    {

        //    fügt allen charakteren mit ausnahme von ysera $5 schaden zu.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(5) : p.getEnemySpellDamageDamage(5);
            foreach (Minion m in p.ownMinions)
            {
                if (m.name != CardDB.cardName.ysera) p.minionGetDamageOrHeal(m, dmg);
            }
            foreach (Minion m in p.enemyMinions)
            {
                if (m.name != CardDB.cardName.ysera) p.minionGetDamageOrHeal(m, dmg);
            }
            p.minionGetDamageOrHeal(p.ownHero, dmg);
            p.minionGetDamageOrHeal(p.enemyHero, dmg);

        }

    }

    class Sim_DREAM_03 : SimTemplate //emeralddrake
    {

        //


    }

    class Sim_DREAM_04 : SimTemplate //dream
    {

        //    lasst einen diener auf die hand seines besitzers zurückkehren.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionReturnToHand(target, target.own, 0);
        }


    }

    class Sim_DREAM_05 : SimTemplate//Nightmare
    {

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 4, 4);
            if (ownplay)
            {
                target.destroyOnOwnTurnStart = true;
            }
            else
            {
                target.destroyOnEnemyTurnStart = true;
            }
        }

    }

    class Sim_DS1h_292 : SimTemplate //steadyshot
    {

        //    heldenfähigkeit/\nfügt dem feindlichen helden 2 schaden zu.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = 2;
            if (ownplay)
            {
                if (p.doublepriest >= 1) dmg *= (2 * p.doublepriest);
                p.minionGetDamageOrHeal(target, dmg);
            }
            else
            {
                if (p.enemydoublepriest >= 1) dmg *= (2 * p.enemydoublepriest);
                p.minionGetDamageOrHeal(target, dmg);
            }

        }

    }

    class Sim_DS1_055 : SimTemplate //darkscalehealer
    {

        //    kampfschrei:/ stellt bei allen befreundeten charakteren 2 leben wieder her.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int heal = (own.own) ? p.getMinionHeal(2) : p.getEnemyMinionHeal(2);
            p.allCharsOfASideGetDamage(own.own, -heal);
        }


    }

    class Sim_DS1_070 : SimTemplate //houndmaster
    {

        //    kampfschrei:/ verleiht einem befreundeten wildtier +2/+2 und spott/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null)
            {
                p.minionGetBuffed(target, 2, 2);
                target.taunt = true;
            }
        }


    }

    class Sim_DS1_175 : SimTemplate //timberwolf
    {

        //    eure anderen wildtiere haben +1 angriff.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnTimberWolfs++;
                foreach (Minion m in p.ownMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PET && m.entitiyID != own.entitiyID) p.minionGetBuffed(m, 1, 0);
                }
            }
            else
            {
                p.anzEnemyTimberWolfs++;
                foreach (Minion m in p.enemyMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PET && m.entitiyID != own.entitiyID) p.minionGetBuffed(m, 1, 0);
                }
            }

        }

        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnTimberWolfs--;
                foreach (Minion m in p.ownMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PET && m.entitiyID != own.entitiyID) p.minionGetBuffed(m, -1, 0);
                }
            }
            else
            {
                p.anzEnemyTimberWolfs--;
                foreach (Minion m in p.enemyMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PET && m.entitiyID != own.entitiyID) p.minionGetBuffed(m, -1, 0);
                }
            }
        }

    }

    class Sim_DS1_178 : SimTemplate //tundrarhino
    {

        //    eure wildtiere haben ansturm/.
        //todo charge?
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnTundrarhino++;
                foreach (Minion m in p.ownMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PET) p.minionGetCharge(m);
                }
            }
            else
            {
                p.anzEnemyTundrarhino++;
                foreach (Minion m in p.enemyMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PET) p.minionGetCharge(m);
                }
            }

        }

        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnTundrarhino--;
                foreach (Minion m in p.ownMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PET) p.minionLostCharge(m);
                }
            }
            else
            {
                p.anzEnemyTundrarhino--;
                foreach (Minion m in p.enemyMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PET) p.minionLostCharge(m);
                }
            }
        }

    }

    class Sim_DS1_183 : SimTemplate //multishot
    {

        //    fügt zwei zufälligen feindlichen dienern $3 schaden zu.
        //todo new list
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int damage = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);
            List<Minion> temp2 = (ownplay) ? new List<Minion>(p.enemyMinions) : new List<Minion>(p.ownMinions);
            temp2.Sort((a, b) => a.Hp.CompareTo(b.Hp));
            int i = 0;
            foreach (Minion enemy in temp2)
            {
                p.minionGetDamageOrHeal(enemy, damage);
                i++;
                if (i == 2) break;
            }
        }

    }

    class Sim_DS1_184 : SimTemplate //tracking
    {

        //    schaut euch die drei obersten karten eures decks an. zieht eine davon und werft die anderen beiden ab.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            //TODO NOT SUPPORTED YET
            //p.drawACard(CardDB.cardName.unknown, ownplay);
            p.evaluatePenality += 100;
        }

    }

    class Sim_DS1_185 : SimTemplate //arcaneshot
    {

        //    verursacht $2 schaden.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_DS1_188 : SimTemplate //gladiatorslongbow
    {
        CardDB.Card c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.DS1_188);
        //    euer held ist immun/, während er angreift.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(c, ownplay);
        }

    }

    class Sim_DS1_233 : SimTemplate //mindblast
    {

        //    fügt dem feindlichen helden $5 schaden zu.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(5) : p.getEnemySpellDamageDamage(5);

            p.minionGetDamageOrHeal(ownplay ? p.enemyHero : p.ownHero, dmg);
        }

    }

    class Sim_ds1_whelptoken : SimTemplate //whelp
    {

        //


    }

    class Sim_EX1_001 : SimTemplate //lightwarden
    {

        //    erhält jedes mal +2 angriff, wenn ein charakter geheilt wird.
        public override void onAHeroGotHealedTrigger(Playfield p, Minion triggerEffectMinion, bool ownerOfHeroGotHealed)
        {
            p.minionGetBuffed(triggerEffectMinion, 2, 0);
        }

        public override void onAMinionGotHealedTrigger(Playfield p, Minion triggerEffectMinion, bool ownerOfMinionGotHealed)
        {
            p.minionGetBuffed(triggerEffectMinion, 2, 0);
        }

    }

    class Sim_EX1_002 : SimTemplate //theblackknight
    {

        //    kampfschrei:/ vernichtet einen feindlichen diener mit spott/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionGetDestroyed(target);
        }


    }

    class Sim_EX1_004 : SimTemplate //youngpriestess
    {

        //    verleiht am ende eures zuges einem anderen zufälligen befreundeten diener +1 leben.
        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            List<Minion> temp2 = new List<Minion>((turnEndOfOwner) ? p.ownMinions : p.enemyMinions);
            temp2.Sort((a, b) => a.Hp.CompareTo(b.Hp));//buff the weakest
            foreach (Minion mins in temp2)
            {
                if (triggerEffectMinion.entitiyID == mins.entitiyID) continue;
                p.minionGetBuffed(mins, 0, 1);
                break;
            }
        }

    }

    class Sim_EX1_005 : SimTemplate //biggamehunter
    {

        //    kampfschrei:/ vernichtet einen diener mit mind. 7 angriff.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionGetDestroyed(target);
        }


    }

    class Sim_EX1_006 : SimTemplate //alarmobot
    {

        //    tauscht zu beginn eures zuges diesen diener gegen einen zufälligen diener auf eurer hand aus.

        public override void onTurnStartTrigger(Playfield p, Minion triggerEffectMinion, bool turnStartOfOwner)
        {
            if (turnStartOfOwner && triggerEffectMinion.own == turnStartOfOwner)
            {
                List<Handmanager.Handcard> temp2 = new List<Handmanager.Handcard>();
                foreach (Handmanager.Handcard hc in p.owncards)
                {
                    if (hc.card.type == CardDB.cardtype.MOB) temp2.Add(hc);
                }
                temp2.Sort((a, b) => -a.card.Attack.CompareTo(b.card.Attack));//damage the stronges
                foreach (Handmanager.Handcard mins in temp2)
                {
                    CardDB.Card c = CardDB.Instance.getCardDataFromID(mins.card.cardIDenum);
                    p.minionTransform(triggerEffectMinion, c);
                    p.removeCard(mins);
                    p.drawACard(CardDB.cardName.alarmobot, true, true);
                    break;
                }
                return;
            }

            if (!turnStartOfOwner && triggerEffectMinion.own == turnStartOfOwner)
            {
                p.minionGetBuffed(triggerEffectMinion, 4, 4);
                triggerEffectMinion.Hp = triggerEffectMinion.maxHp;
            }
        }
    }

    class Sim_EX1_007 : SimTemplate//Acolyte of Pain
    {
        //  <deDE>Zieht jedes Mal eine Karte, wenn dieser Diener Schaden erleidet.</deDE>
        public override void onMinionGotDmgTrigger(Playfield p, Minion triggerEffectMinion, bool ownDmgdMinion)
        {
            if (triggerEffectMinion.anzGotDmg >= 1)
            {
                for (int i = 0; i < triggerEffectMinion.anzGotDmg; i++)
                {
                    p.drawACard(CardDB.cardName.unknown, triggerEffectMinion.own);
                }
                triggerEffectMinion.anzGotDmg = 0;
            }
        }
    }

    class Sim_EX1_008 : SimTemplate //argentsquire
    {

        //    gottesschild/


    }

    class Sim_EX1_009 : SimTemplate //angrychicken
    {

        //    wutanfall:/ +5 angriff.
        public override void onEnrageStart(Playfield p, Minion m)
        {
            p.minionGetBuffed(m, 5, 0);
        }

        public override void onEnrageStop(Playfield p, Minion m)
        {
            p.minionGetBuffed(m, -5, 0);
        }

    }

    class Sim_EX1_010 : SimTemplate//Worgen Infiltrator
    {



    }

    class Sim_EX1_011 : SimTemplate //voodoodoctor
    {

        //    kampfschrei:/ stellt 2 leben wieder her.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int heal = (own.own) ? p.getMinionHeal(2) : p.getEnemyMinionHeal(2);
            p.minionGetDamageOrHeal(target, -heal);
        }


    }

    class Sim_EX1_012 : SimTemplate//bloodmage thalnos
    {
        public override void onAuraStarts(Playfield p, Minion own)
        {

            if (own.own)
            {
                p.spellpower++;
            }
            else
            {
                p.enemyspellpower++;
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            if (m.own)
            {
                p.spellpower--;
            }
            else
            {
                p.enemyspellpower--;
            }
        }

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.drawACard(CardDB.cardName.unknown, m.own);
        }

    }

    class Sim_EX1_014 : SimTemplate //kingmukla
    {

        //    kampfschrei:/ gebt eurem gegner 2 bananen.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.bananas, !own.own, true);
            if (own.own)
            {
                p.enemycarddraw -= 1;
            }
            p.drawACard(CardDB.cardName.bananas, !own.own, true);
            if (own.own)
            {
                p.enemycarddraw -= 1;
            }
        }


    }

    class Sim_EX1_014t : SimTemplate //bananas
    {

        //    verleiht einem diener +1/+1.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 1, 1);
        }

    }

    class Sim_EX1_015 : SimTemplate //noviceengineer
    {

        //    kampfschrei:/ zieht eine karte.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, own.own);
        }


    }

    class Sim_EX1_016 : SimTemplate //sylvanaswindrunner
    {
        //todo make it better
        //    todesröcheln:/ übernehmt die kontrolle über einen zufälligen feindlichen diener.
        public override void onDeathrattle(Playfield p, Minion m)
        {
            List<Minion> tmp = (m.own) ? p.enemyMinions : p.ownMinions;
            if (tmp.Count >= 1)
            {
                Minion target = null;
                int value = 10000;
                bool found = false;

                //search smallest minion:
                foreach (Minion mnn in tmp)
                {
                    if (mnn.Hp < value && mnn.Hp >= 1)
                    {
                        target = mnn;
                        value = target.Hp;
                        found = true;
                    }
                }
                if (found) p.minionGetControlled(target, m.own, false);
            }


        }

    }

    class Sim_EX1_016t : SimTemplate //skeleton
    {

        //


    }

    class Sim_EX1_017 : SimTemplate //junglepanther
    {

        //    verstohlenheit/

    }

    class Sim_EX1_019 : SimTemplate //shatteredsuncleric
    {

        //    kampfschrei:/ verleiht einem befreundeten diener +1/+1.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionGetBuffed(target, 1, 1);
        }


    }

    class Sim_EX1_020 : SimTemplate //scarletcrusader
    {

        //    gottesschild/


    }

    class Sim_EX1_021 : SimTemplate //thrallmarfarseer
    {

        //    windzorn/

    }

    class Sim_EX1_023 : SimTemplate//Silvermoon Guardian
    {


    }

    class Sim_EX1_025 : SimTemplate//dragonling mechanic
    {
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_025t);//mechanicaldragonling

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.callKid(kid, own.zonepos, own.own, true);
        }

    }

    class Sim_EX1_025t : SimTemplate //mechanicaldragonling
    {

        //


    }

    class Sim_EX1_028 : SimTemplate //stranglethorntiger
    {

        //    verstohlenheit/


    }

    class Sim_EX1_029 : SimTemplate //lepergnome
    {

        //    todesröcheln:/ fügt dem feindlichen helden 2 schaden zu.
        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.minionGetDamageOrHeal(m.own ? p.enemyHero : p.ownHero, 2);
        }

    }

    class Sim_EX1_032 : SimTemplate //sunwalker
    {

        //    spott/, gottesschild/

    }

    class Sim_EX1_033 : SimTemplate //windfuryharpy
    {

        //    windzorn/


    }

    class Sim_EX1_043 : SimTemplate //twilightdrake
    {

        //    kampfschrei:/ erhält +1 leben für jede karte auf eurer hand.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.minionGetBuffed(own, 0, (own.own) ? p.owncards.Count : p.enemyAnzCards);
        }


    }

    class Sim_EX1_044 : SimTemplate //questingadventurer
    {

        //    erhält jedes mal +1/+1, wenn ihr eine karte ausspielt.
        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (triggerEffectMinion.own == wasOwnCard)
            {
                p.minionGetBuffed(triggerEffectMinion, 1, 1);
            }
        }
    }

    class Sim_EX1_045 : SimTemplate //ancientwatcher
    {

        //    kann nicht angreifen.


    }

    class Sim_EX1_046 : SimTemplate//Dark Iron Dwarf
    {
        // +2 tempattack
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionGetTempBuff(target, 2, 0);
        }
    }

    class Sim_EX1_048 : SimTemplate //spellbreaker
    {

        //    kampfschrei:/ bringt einen diener zum schweigen/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionGetSilenced(target);
        }


    }

    class Sim_EX1_049 : SimTemplate //youthfulbrewmaster
    {

        //    kampfschrei:/ lasst einen befreundeten diener vom schlachtfeld auf eure hand zurückkehren.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.minionReturnToHand(target, target.own, 0);
        }


    }

    class Sim_EX1_050 : SimTemplate //coldlightoracle
    {

        //    kampfschrei:/ jeder spieler zieht 2 karten.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, true);
            p.drawACard(CardDB.cardName.unknown, true);
            p.drawACard(CardDB.cardName.unknown, false);
            p.drawACard(CardDB.cardName.unknown, false);

        }


    }

    class Sim_EX1_055 : SimTemplate //manaaddict
    {

        //    erhält jedes mal +2 angriff in diesem zug, wenn ihr einen zauber wirkt.
        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (triggerEffectMinion.own == wasOwnCard && c.type == CardDB.cardtype.SPELL)
            {
                p.minionGetTempBuff(triggerEffectMinion, 2, 0);
            }
        }

    }

    class Sim_EX1_057 : SimTemplate //ancientbrewmaster
    {

        //    kampfschrei:/ lasst einen befreundeten diener vom schlachtfeld auf eure hand zurückkehren.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionReturnToHand(target, target.own, 0);
        }

    }

    class Sim_EX1_058 : SimTemplate //sunfuryprotector
    {

        //    kampfschrei:/ verleiht benachbarten dienern spott/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.ownMinions : p.enemyMinions;
            foreach (Minion m in temp)
            {
                if (m.zonepos == own.zonepos - 1 || m.zonepos == own.zonepos)
                {
                    m.taunt = true;
                }
            }
        }

    }

    class Sim_EX1_059 : SimTemplate //crazedalchemist
    {

        //    kampfschrei:/ vertauscht angriff und leben eines dieners.
        //todo: use buffs after that
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionSwapAngrAndHP(target);
        }

    }

    class Sim_EX1_062 : SimTemplate //oldmurkeye
    {

        //    ansturm/. hat +1 angriff für jeden anderen murloc auf dem schlachtfeld.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            foreach (Minion m in p.ownMinions)
            {
                if (m.handcard.card.race == 14)
                {
                    p.minionGetBuffed(own, 1, 0);
                }
            }

            foreach (Minion m in p.enemyMinions)
            {
                if (m.handcard.card.race == 14)
                {
                    p.minionGetBuffed(own, 1, 0);
                }
            }
        }

        public override void onMinionIsSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            if (summonedMinion.handcard.card.race == 14)
            {
                p.minionGetBuffed(triggerEffectMinion, 1, 0);
            }
        }

        public override void onMinionDiedTrigger(Playfield p, Minion triggerEffectMinion, Minion diedMinion)
        {
            if (diedMinion.handcard.card.race == 14)
            {
                p.minionGetBuffed(triggerEffectMinion, -1, 0);
            }
        }

    }

    class Sim_EX1_066 : SimTemplate //acidicswampooze
    {

        //    kampfschrei:/ zerstört die waffe eures gegners.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.lowerWeaponDurability(1000, !own.own);
        }


    }

    class Sim_EX1_067 : SimTemplate //argentcommander
    {

        //    ansturm/, gottesschild/

    }

    class Sim_EX1_076 : SimTemplate //pintsizedsummoner
    {

        //todo enemy stuff
        //    der erste diener, den ihr in einem zug ausspielt, kostet (1) weniger.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own) p.winzigebeschwoererin++;
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            if (m.own) p.winzigebeschwoererin--;
        }

    }

    class Sim_EX1_080 : SimTemplate //secretkeeper
    {

        //    erhält jedes mal +1/+1, wenn ein geheimnis/ ausgespielt wird.

        //we do them manually in playfield
        /*public override void onCardWasPlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (wasOwnCard && c.Secret)
            {
                p.minionGetBuffed(triggerEffectMinion, 1, 1);
            }
        }*/

    }

    class Sim_EX1_082 : SimTemplate //madbomber
    {
        //todo make it better
        //    kampfschrei:/ verursacht 3 schaden, der zufällig auf alle anderen charaktere aufgeteilt wird.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int anz = 3;
            for (int i = 0; i < anz; i++)
            {
                if (p.ownHero.Hp <= anz)
                {
                    p.minionGetDamageOrHeal(p.ownHero, 1);
                    continue;
                }
                List<Minion> temp = new List<Minion>(p.enemyMinions);
                if (temp.Count == 0)
                {
                    temp.AddRange(p.ownMinions);
                }
                temp.Sort((a, b) => a.Hp.CompareTo(b.Hp));//destroys the weakest

                foreach (Minion m in temp)
                {
                    p.minionGetDamageOrHeal(m, 1);
                    break;
                }
                p.minionGetDamageOrHeal(p.enemyHero, 1);
            }
        }

    }

    class Sim_EX1_083 : SimTemplate //tinkmasteroverspark
    {
        CardDB.Card card1 = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_tk29); // rex
        CardDB.Card card2 = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_tk28); // squirrel
        //todo better
        //    kampfschrei:/ verwandelt einen anderen zufälligen diener in einen teufelssaurier (5/5) oder ein eichhörnchen (1/1).
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int oc = p.ownMinions.Count;
            int ec = p.enemyMinions.Count;
            if (oc == 0 && ec == 0) return;
            if (oc > ec)
            {
                List<Minion> temp = new List<Minion>(p.ownMinions);
                temp.AddRange(p.enemyMinions);
                temp.Sort((a, b) => a.Hp.CompareTo(b.Hp));//transform the weakest
                foreach (Minion m in temp)
                {
                    p.minionTransform(m, card1);
                    break;
                }
            }
            else
            {
                List<Minion> temp = new List<Minion>(p.ownMinions);
                temp.AddRange(p.enemyMinions);
                temp.Sort((a, b) => -a.Hp.CompareTo(b.Hp));//transform the strongest
                foreach (Minion m in temp)
                {
                    p.minionTransform(m, card2);
                    break;
                }
            }
        }


    }

    class Sim_EX1_084 : SimTemplate //warsongcommander
    {

        //    jedes mal, wenn ihr einen diener mit max. 3 angriff herbeiruft, erhält dieser ansturm/.

        public override void onMinionIsSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            if (triggerEffectMinion.own == summonedMinion.own && summonedMinion.handcard.card.Attack <= 3)
            {
                p.minionGetCharge(summonedMinion);
            }
        }

    }

    class Sim_EX1_085 : SimTemplate //mindcontroltech
    {
        //todo list
        //    kampfschrei:/ falls euer gegner mind. 4 diener hat, übernehmt zufällig die kontrolle über einen davon.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                if (p.enemyMinions.Count >= 4)
                {
                    List<Minion> temp = new List<Minion>(p.enemyMinions);
                    temp.Sort((a, b) => a.Angr.CompareTo(b.Angr));//we take the weekest
                    Minion targett;
                    targett = temp[0];
                    if (targett.taunt && temp.Count >= 2 && !temp[1].taunt) targett = temp[1];
                    p.minionGetControlled(targett, true, false);

                }
            }
            else
            {
                if (p.ownMinions.Count >= 4)
                {
                    List<Minion> temp = new List<Minion>(p.ownMinions);
                    temp.Sort((a, b) => a.Angr.CompareTo(b.Angr));//we take the weekest
                    Minion targett;
                    targett = temp[0];
                    if (targett.taunt && temp.Count >= 2 && !temp[1].taunt) targett = temp[1];
                    p.minionGetControlled(targett, false, false);

                }
            }
        }

    }


    class Sim_EX1_089 : SimTemplate //arcanegolem
    {

        //    ansturm/. kampfschrei:/ gebt eurem gegner 1 manakristall.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                p.enemyMaxMana = Math.Min(10, p.enemyMaxMana + 1);
            }
            else
            {
                p.ownMaxMana = Math.Min(10, p.ownMaxMana + 1);
            }
        }


    }

    class Sim_EX1_091 : SimTemplate //cabalshadowpriest
    {

        //    kampfschrei:/ übernehmt die kontrolle über einen feindlichen diener mit max. 2 angriff.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionGetControlled(target, own.own, false);
        }


    }

    class Sim_EX1_093 : SimTemplate //defenderofargus
    {

        //    kampfschrei:/ verleiht benachbarten dienern +1/+1 und spott/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.ownMinions : p.enemyMinions;
            foreach (Minion m in temp)
            {
                if (m.zonepos == own.zonepos - 1 || m.zonepos == own.zonepos)//position and position -1 because its not placed jet
                {
                    m.taunt = true;
                    p.minionGetBuffed(m, 1, 1);
                }
            }
        }


    }

    class Sim_EX1_095 : SimTemplate //gadgetzanauctioneer
    {

        //    zieht jedes mal eine karte, wenn ihr einen zauber wirkt.

        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (c.type == CardDB.cardtype.SPELL && wasOwnCard == triggerEffectMinion.own)
            {
                p.drawACard(CardDB.cardName.unknown, wasOwnCard);
            }

        }

    }

    class Sim_EX1_096 : SimTemplate //loothoarder
    {

        //    todesröcheln:/ zieht eine karte.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.drawACard(CardDB.cardName.unknown, m.own);
        }

    }

    class Sim_EX1_097 : SimTemplate //abomination
    {

        //    spott/. todesröcheln:/ fügt allen charakteren 2 schaden zu.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.allCharsGetDamage(2);
        }

    }

    class Sim_EX1_100 : SimTemplate //lorewalkercho
    {

        //    wenn ein spieler einen zauber wirkt, erhält der andere spieler eine kopie desselben auf seine hand.

        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (c.type == CardDB.cardtype.SPELL)
            {
                p.drawACard(c.name, !wasOwnCard, true);
            }
        }

    }

    class Sim_EX1_102 : SimTemplate //demolisher
    {

        //    fügt zu beginn eures zuges einem zufälligen feind 2 schaden zu.

        public override void onTurnStartTrigger(Playfield p, Minion triggerEffectMinion, bool turnStartOfOwner)
        {
            if (triggerEffectMinion.own == turnStartOfOwner)
            {
                List<Minion> temp2 = (turnStartOfOwner) ? p.enemyMinions : p.ownMinions;
                bool dmgdone = false;
                foreach (Minion mins in temp2)
                {
                    p.minionGetDamageOrHeal(mins, 2);
                    dmgdone = true;
                    break;
                }
                if (!dmgdone)
                {
                    p.minionGetDamageOrHeal(turnStartOfOwner ? p.enemyHero : p.ownHero, 2);
                };
            }
        }

    }

    class Sim_EX1_103 : SimTemplate//Coldlight Seer
    {

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.ownMinions : p.enemyMinions;

            foreach (Minion t in temp)
            {
                if ((TAG_RACE)t.handcard.card.race == TAG_RACE.MURLOC) p.minionGetBuffed(t, 0, 2);
            }
        }
    }

    class Sim_EX1_105 : SimTemplate //mountaingiant
    {

        //    kostet (1) weniger für jede andere karte auf eurer hand.

    }

    class Sim_EX1_110 : SimTemplate //cairnebloodhoof
    {

        //    todesröcheln:/ ruft baine bluthuf (4/5) herbei.
        CardDB.Card blaine = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_110t);

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.callKid(blaine, m.zonepos - 1, m.own);
        }

    }

    class Sim_EX1_110t : SimTemplate //bainebloodhoof
    {

        //


    }

    class Sim_EX1_112 : SimTemplate //gelbinmekkatorque
    {
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.Mekka1);//homingchicken
        //    kampfschrei:/ konstruiert eine fantastische erfindung.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.callKid(kid, own.zonepos, own.own, true);
        }


    }

    class Sim_EX1_116 : SimTemplate //leeroyjenkins
    {
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_116t);//whelp
        //    ansturm/. kampfschrei:/ ruft zwei welplinge (1/1) für euren gegner herbei.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {

            int pos = (own.own) ? p.enemyMinions.Count : p.ownMinions.Count;
            p.callKid(kid, pos, !own.own);
            p.callKid(kid, pos, !own.own);
        }
    }

    class Sim_EX1_116t : SimTemplate //whelp
    {

        //


    }

    class Sim_EX1_124 : SimTemplate //eviscerate
    {

        //    verursacht $2 schaden. combo:/ verursacht stattdessen $4 schaden.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(4) : p.getEnemySpellDamageDamage(4);
            if (p.cardsPlayedThisTurn == 0) dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_EX1_126 : SimTemplate //betrayal
    {

        //    zwingt einen feindlichen diener, seinen schaden benachbarten dienern zuzufügen.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            //attack right neightbor
            if (target.Angr > 0)
            {
                int dmg = target.Angr;
                List<Minion> temp = (ownplay) ? p.enemyMinions : p.ownMinions;
                foreach (Minion m in p.enemyMinions)
                {
                    if (m.zonepos + 1 == target.zonepos || m.zonepos - 1 == target.zonepos)
                    {
                        /*int oldhp = m.Hp;
                        p.minionGetDamageOrHeal(m, dmg);
                        if (!target.silenced && (target.handcard.card.name == CardDB.cardName.waterelemental ||target.handcard.card.name == CardDB.cardName.snowchugger) && m.Hp < oldhp) m.frozen=true;
                        if (!target.silenced && m.Hp < oldhp && target.poisonous) p.minionGetDestroyed(m);*/
                        p.minionAttacksMinion(target, m, true);
                    }
                }

            }

        }

    }

    class Sim_EX1_128 : SimTemplate //conceal
    {

        //    verleiht euren dienern bis zu eurem nächsten zug verstohlenheit/.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                foreach (Minion m in p.ownMinions)
                {
                    if (!m.stealth)
                    {
                        m.stealth = true;
                        m.concedal = true;
                    }
                }
            }
            else
            {
                foreach (Minion m in p.enemyMinions)
                {
                    if (!m.stealth)
                    {
                        m.stealth = true;
                        m.concedal = true;
                    }
                }
            }
        }

    }


    class Sim_EX1_129 : SimTemplate //fanofknives
    {

        //    fügt allen feindlichen dienern $1 schaden zu. zieht eine karte.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            p.allMinionOfASideGetDamage(!ownplay, dmg);
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_EX1_130 : SimTemplate //noblesacrifice
    {
        //todo secret
        //    geheimnis:/ wenn ein feind angreift, ruft ihr einen verteidiger (2/1) als neues ziel herbei.

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_130a);

        public override void onSecretPlay(Playfield p, bool ownplay, Minion attacker, Minion target, out int number)
        {
            number = 0;
            if (ownplay)
            {
                int posi = p.ownMinions.Count;
                p.callKid(kid, posi, true);
                if (p.ownMinions.Count >= 1)
                {
                    if (p.ownMinions[p.ownMinions.Count - 1].name == CardDB.cardName.defender)
                    {
                        number = p.ownMinions[p.ownMinions.Count - 1].entitiyID;
                    }
                }
            }
            else
            {
                int posi = p.enemyMinions.Count;
                p.callKid(kid, posi, false);

                if (p.enemyMinions.Count >= 1)
                {
                    if (p.enemyMinions[p.enemyMinions.Count - 1].name == CardDB.cardName.defender)
                    {
                        number = p.enemyMinions[p.enemyMinions.Count - 1].entitiyID;
                    }
                }
            }

        }

    }


    class Sim_EX1_130a : SimTemplate //defender
    {

        //


    }

    class Sim_EX1_131 : SimTemplate //defiasringleader
    {
        CardDB.Card card = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_131t);
        //    combo:/ ruft einen banditen der defias (2/1) herbei.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (p.cardsPlayedThisTurn >= 1)
            {
                p.callKid(card, own.zonepos, own.own);
            }
        }


    }

    class Sim_EX1_131t : SimTemplate //defiasbandit
    {

        //


    }

    class Sim_EX1_132 : SimTemplate //eyeforaneye
    {
        //todo secret
        //    geheimnis:/ wenn euer held schaden erleidet, wird dem feindlichen helden ebenso viel schaden zugefügt.
        public override void onSecretPlay(Playfield p, bool ownplay, int number)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(number) : p.getEnemySpellDamageDamage(number);

            p.minionGetDamageOrHeal(ownplay ? p.enemyHero : p.ownHero, dmg);
        }

    }



    class Sim_EX1_133 : SimTemplate//pertitions blade
    {
        CardDB.Card w = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_133);

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            if (p.cardsPlayedThisTurn >= 1) dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            p.minionGetDamageOrHeal(target, dmg);
            p.equipWeapon(w, ownplay);
        }

    }



    class Sim_EX1_134 : SimTemplate //si7agent
    {

        //    combo:/ verursacht 2 schaden.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (p.cardsPlayedThisTurn >= 1)
            {
                p.minionGetDamageOrHeal(target, 2);
            }
        }

    }

    class Sim_EX1_136 : SimTemplate //redemption
    {
        //todo secret
        //    geheimnis:/ wenn einer eurer diener stirbt, wird er mit 1 leben wiederbelebt.

        public override void onSecretPlay(Playfield p, bool ownplay, int number)
        {
            int posi = ownplay ? p.ownMinions.Count : p.enemyMinions.Count;

            CardDB.Card kid = CardDB.Instance.getCardDataFromID(ownplay ? p.revivingOwnMinion : p.revivingEnemyMinion);

            p.callKid(kid, posi, ownplay);
            if (ownplay)
            {
                if (p.ownMinions.Count >= 1)
                {
                    if (p.ownMinions[p.ownMinions.Count - 1].handcard.card.cardIDenum == kid.cardIDenum)
                    {
                        p.ownMinions[p.ownMinions.Count - 1].Hp = 1;
                        p.ownMinions[p.ownMinions.Count - 1].wounded = false;
                        if (p.ownMinions[p.ownMinions.Count - 1].Hp < p.ownMinions[p.ownMinions.Count - 1].maxHp)
                        {
                            p.ownMinions[p.ownMinions.Count - 1].wounded = true;
                        }
                    }
                }
            }
            else
            {
                if (p.enemyMinions.Count >= 1)
                {
                    if (p.enemyMinions[p.enemyMinions.Count - 1].handcard.card.cardIDenum == kid.cardIDenum)
                    {
                        p.enemyMinions[p.enemyMinions.Count - 1].Hp = 1;
                        p.enemyMinions[p.enemyMinions.Count - 1].wounded = false;
                        if (p.enemyMinions[p.enemyMinions.Count - 1].Hp < p.enemyMinions[p.enemyMinions.Count - 1].maxHp)
                        {
                            p.enemyMinions[p.enemyMinions.Count - 1].wounded = true;
                        }
                    }
                }
            }

        }

    }

    class Sim_EX1_137 : SimTemplate //headcrack
    {

        //    fügt dem feindlichen helden $2 schaden zu. combo:/ lasst die karte in eurem nächsten zug wieder auf eure hand zurückkehren.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);

            p.minionGetDamageOrHeal(ownplay ? p.enemyHero : p.ownHero, dmg);

            if (p.cardsPlayedThisTurn >= 1) p.evaluatePenality -= 5;
        }

    }

    class Sim_EX1_144 : SimTemplate //shadowstep
    {

        //    lasst einen befreundeten diener auf eure hand zurückkehren. der diener kostet (2) weniger.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionReturnToHand(target, ownplay, target.handcard.card.cost - 2);
        }

    }

    class Sim_EX1_145 : SimTemplate //preparation
    {

        //    der nächste zauber, den ihr in diesem zug wirkt, kostet (3) weniger.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                p.playedPreparation = true;
            }
        }

    }

    class Sim_EX1_154 : SimTemplate //wrath
    {

        //    wählt aus:/ fügt einem diener $3 schaden zu; oder fügt einem diener $1 schaden zu und zieht eine karte.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int damage = 0;
            if (choice == 1)
            {
                damage = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);
            }
            if (choice == 2)
            {
                damage = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            }

            p.minionGetDamageOrHeal(target, damage);

            if (choice == 2)
            {
                p.drawACard(CardDB.cardName.unknown, ownplay);
            }
        }

    }

    class Sim_EX1_154a : SimTemplate //wrath
    {

        //    fügt einem diener $3 schaden zu.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int damage = 0;
            damage = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);

            p.minionGetDamageOrHeal(target, damage);
        }

    }

    class Sim_EX1_154b : SimTemplate //wrath
    {

        //    fügt einem diener $1 schaden zu. zieht eine karte.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int damage = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            //this.owncarddraw++;

            p.minionGetDamageOrHeal(target, damage);
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_EX1_155 : SimTemplate //markofnature
    {

        //    wählt aus:/ verleiht einem diener +4 angriff; oder +4 leben und spott/.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (choice == 1)
            {
                p.minionGetBuffed(target, 4, 0);
            }
            if (choice == 2)
            {
                p.minionGetBuffed(target, 0, 4);
                target.taunt = true;
            }
        }

    }

    class Sim_EX1_155a : SimTemplate //markofnature
    {

        //    +4 angriff.


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 4, 0);
        }

    }

    class Sim_EX1_155b : SimTemplate //markofnature
    {

        //    +4 leben und spott/.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 0, 4);
            target.taunt = true;
        }

    }

    class Sim_EX1_158 : SimTemplate //souloftheforest
    {

        //    verleiht euren dienern „todesröcheln:/ ruft einen treant (2/2) herbei.“

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;

            foreach (Minion m in temp)
            {
                m.souloftheforest++;
            }
        }

    }

    class Sim_EX1_158t : SimTemplate //treant
    {

        //


    }

    class Sim_EX1_160 : SimTemplate //powerofthewild
    {

        //    wählt aus:/ verleiht euren dienern +1/+1; oder ruft einen panther (3/2) herbei.
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_160t);//panther

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (choice == 1)
            {
                List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;
                foreach (Minion m in temp)
                {
                    p.minionGetBuffed(m, 1, 1);
                }
            }
            if (choice == 2)
            {
                int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;
                p.callKid(kid, posi, true);

            }
        }

    }

    class Sim_EX1_160a : SimTemplate //summonapanther
    {
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_160t);//panther
        //    ruft einen panther (3/2) herbei.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;

            p.callKid(kid, posi, true);
        }

    }

    class Sim_EX1_160b : SimTemplate //leaderofthepack
    {

        //    verleiht euren dienern +1/+1.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;
            foreach (Minion m in temp)
            {
                p.minionGetBuffed(m, 1, 1);
            }
        }

    }

    class Sim_EX1_160t : SimTemplate //panther
    {

        //


    }

    class Sim_EX1_161 : SimTemplate //naturalize
    {

        //    vernichtet einen diener. euer gegner zieht 2 karten.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetDestroyed(target);
            p.drawACard(CardDB.cardName.unknown, !ownplay);
            p.drawACard(CardDB.cardName.unknown, !ownplay);
        }

    }

    class Sim_EX1_162 : SimTemplate //direwolfalpha
    {

        //    benachbarte diener haben +1 angriff.
        // note buff and debuff is handled by playfield (faster)
        /*
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                foreach (Minion m in p.ownMinions)
                {
                    if (m.zonepos-1 == own.zonepos || m.zonepos + 1 == own.zonepos)
                    {
                        p.minionGetAdjacentBuff(m, 1, 0);
                    }
                }
            }
            else
            {
                foreach (Minion m in p.enemyMinions)
                {
                    if (m.zonepos-1 == own.zonepos || m.zonepos + 1 == own.zonepos)
                    {
                        p.minionGetAdjacentBuff(m, 1, 0);
                    }
                }
            }

		}


        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own)
            {
                foreach (Minion m in p.ownMinions)
                {
                    if (m.zonepos - 1 == own.zonepos || m.zonepos + 1 == own.zonepos)
                    {
                        p.minionGetAdjacentBuff(m, -1, 0);
                    }
                }
            }
            else
            {
                foreach (Minion m in p.enemyMinions)
                {
                    if (m.zonepos - 1 == own.zonepos || m.zonepos + 1 == own.zonepos)
                    {
                        p.minionGetAdjacentBuff(m, -1, 0);
                    }
                }
            }
        }*/

    }

    class Sim_EX1_164 : SimTemplate //nourish
    {

        //    wählt aus:/ erhaltet 2 manakristalle; oder zieht 3 karten.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (choice == 1)
            {
                if (ownplay)
                {
                    if (p.ownMaxMana >= 10)
                    {
                        //p.drawACard(CardDB.cardName.excessmana, true);
                        if (p.mana < 10) p.mana++;
                    }
                    else
                    {
                        p.ownMaxMana++;
                        p.mana++;
                    }
                    if (p.ownMaxMana >= 10)
                    {
                        //this.owncarddraw++;
                        //p.drawACard(CardDB.cardName.excessmana, true);
                        if (p.mana < 10) p.mana++;
                    }
                    else
                    {
                        p.ownMaxMana++;
                        p.mana++;
                    }
                }
                else
                {
                    if (p.enemyMaxMana == 10)
                    {
                        //p.drawACard(CardDB.cardName.excessmana, false);
                        if (p.mana < 10) p.mana++;
                    }
                    else
                    {
                        p.enemyMaxMana++;
                        p.mana++;
                    }
                    if (p.enemyMaxMana == 10)
                    {
                        //this.owncarddraw++;
                        //p.drawACard(CardDB.cardName.excessmana, false);
                        if (p.mana < 10) p.mana++;
                    }
                    else
                    {
                        p.enemyMaxMana++;
                        p.mana++;
                    }
                }
            }
            if (choice == 2)
            {
                //this.owncarddraw+=3;
                p.drawACard(CardDB.cardName.unknown, ownplay);
                p.drawACard(CardDB.cardName.unknown, ownplay);
                p.drawACard(CardDB.cardName.unknown, ownplay);
            }
        }

    }

    class Sim_EX1_164a : SimTemplate //nourish
    {

        //    erhaltet 2 manakristalle.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                if (p.ownMaxMana >= 10)
                {
                    //p.drawACard(CardDB.cardName.excessmana, true);
                    if (p.mana < 10) p.mana++;
                }
                else
                {
                    p.ownMaxMana++;
                    p.mana++;
                }
                if (p.ownMaxMana >= 10)
                {
                    //this.owncarddraw++;
                    //p.drawACard(CardDB.cardName.excessmana, true);
                    if (p.mana < 10) p.mana++;
                }
                else
                {
                    p.ownMaxMana++;
                    p.mana++;
                }
            }
            else
            {
                if (p.enemyMaxMana == 10)
                {
                    //p.drawACard(CardDB.cardName.excessmana, false);
                    if (p.mana < 10) p.mana++;
                }
                else
                {
                    p.enemyMaxMana++;
                    p.mana++;
                }
                if (p.enemyMaxMana == 10)
                {
                    //this.owncarddraw++;
                    //p.drawACard(CardDB.cardName.excessmana, false);
                    if (p.mana < 10) p.mana++;
                }
                else
                {
                    p.enemyMaxMana++;
                    p.mana++;
                }
            }
        }

    }

    class Sim_EX1_164b : SimTemplate //nourish
    {

        //    zieht 3 karten.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, ownplay);
            p.drawACard(CardDB.cardName.unknown, ownplay);
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_EX1_165 : SimTemplate //druidoftheclaw
    {

        //    wählt aus:/ ansturm/; oder +2 leben und spott/.
        CardDB.Card cat = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_165t1);
        CardDB.Card bear = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_165t2);
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (choice == 1)
            {
                p.minionTransform(own, cat);
            }
            if (choice == 2)
            {
                p.minionTransform(own, bear);
            }
        }


    }

    class Sim_EX1_165a : SimTemplate //catform
    {

        //    ansturm/
        CardDB.Card cat = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_165t1);
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.minionTransform(own, cat);

        }

    }

    class Sim_EX1_165b : SimTemplate //bearform
    {

        //    +2 leben und spott/.
        CardDB.Card bear = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_165t2);
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.minionTransform(own, bear);
        }

    }

    class Sim_EX1_165t1 : SimTemplate //druidoftheclaw
    {

        //    ansturm/

    }

    class Sim_EX1_165t2 : SimTemplate //druidoftheclaw
    {

        //    spott/


    }

    class Sim_EX1_166 : SimTemplate //keeperofthegrove
    {

        //    wählt aus:/ verursacht 2 schaden; oder bringt einen diener zum schweigen/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (choice == 1)
            {
                p.minionGetDamageOrHeal(target, 2);
            }

            if (choice == 2)
            {
                p.minionGetSilenced(target);
            }
        }


    }

    class Sim_EX1_166a : SimTemplate //moonfire
    {

        //    verursacht 2 schaden.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetDamageOrHeal(target, 2);
        }

    }

    class Sim_EX1_166b : SimTemplate //dispel
    {

        //    bringt einen diener zum schweigen/.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetSilenced(target);
        }

    }

    class Sim_EX1_169 : SimTemplate //innervate
    {

        //    erhaltet 2 manakristalle nur für diesen zug.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.mana = Math.Min(p.mana + 2, 10);
        }

    }

    class Sim_EX1_170 : SimTemplate //emperorcobra
    {

        //    vernichtet jeden diener, der von diesem diener verletzt wurde.

    }

    class Sim_EX1_173 : SimTemplate //starfire
    {

        //    verursacht $5 schaden. zieht eine karte.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(5) : p.getEnemySpellDamageDamage(5);
            p.minionGetDamageOrHeal(target, dmg);
            //this.owncarddraw++;
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_EX1_178 : SimTemplate //ancientofwar
    {

        //    wählt aus:/ +5 angriff; oder +5 leben und spott/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (choice == 2)
            {
                p.minionGetBuffed(own, 5, 0);
            }
            if (choice == 1)
            {
                p.minionGetBuffed(own, 0, 5);
                own.taunt = true;
            }
        }


    }


    class Sim_EX1_178a : SimTemplate //rooted
    {

        //    +5 leben und spott/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.minionGetBuffed(own, 0, 5);
            own.taunt = true;
        }


    }

    class Sim_EX1_178b : SimTemplate //uproot
    {

        //    +5 angriff.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.minionGetBuffed(own, 5, 0);
        }



    }

    class Sim_EX1_238 : SimTemplate //lightningbolt
    {

        //    verursacht $3 schaden. überladung:/ (1)

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);
            p.minionGetDamageOrHeal(target, dmg);
            if (ownplay) p.ueberladung++;
        }

    }

    class Sim_EX1_241 : SimTemplate //lavaburst
    {

        //    verursacht $5 schaden. überladung:/ (2)

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(5) : p.getEnemySpellDamageDamage(5);
            p.minionGetDamageOrHeal(target, dmg);
            if (ownplay) p.ueberladung += 2;
        }

    }

    class Sim_EX1_243 : SimTemplate //dustdevil
    {

        //    windzorn/, überladung:/ (2)
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own) p.ueberladung += 2;
        }

    }

    class Sim_EX1_244 : SimTemplate//totemic might
    {
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;
            foreach (Minion t in temp)
            {
                if (t.handcard.card.race == 21) // if minion is a totem, buff it
                {
                    p.minionGetBuffed(t, 0, 2);
                }
            }
        }

    }

    class Sim_EX1_245 : SimTemplate //earthshock
    {

        //    bringt einen diener zum schweigen/ und fügt ihm dann $1 schaden zu.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetSilenced(target);
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_EX1_246 : SimTemplate //hex
    {
        CardDB.Card card = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.hexfrog);
        //    verwandelt einen diener in einen frosch (0/1) mit spott/.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionTransform(target, card);
        }

    }

    class Sim_EX1_247 : SimTemplate //stormforgedaxe
    {
        CardDB.Card card = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_247);
        //
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(card, ownplay);
            if (ownplay) p.ueberladung++;
        }

    }

    class Sim_EX1_248 : SimTemplate //feralspirit
    {
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_tk11);//spiritwolf
        //    ruft zwei geisterwölfe (2/3) mit spott/ herbei. überladung:/ (2)

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;

            p.callKid(kid, posi, ownplay);
            p.callKid(kid, posi, ownplay);
            if (ownplay) p.ueberladung += 2;
        }

    }

    class Sim_EX1_249 : SimTemplate //barongeddon
    {

        //    fügt am ende eures zuges allen anderen charakteren 2 schaden zu.

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (turnEndOfOwner == triggerEffectMinion.own)
            {
                foreach (Minion m in p.enemyMinions)
                {
                    if (triggerEffectMinion.entitiyID != m.entitiyID) p.minionGetDamageOrHeal(m, 2);
                }
                foreach (Minion m in p.ownMinions)
                {
                    if (triggerEffectMinion.entitiyID != m.entitiyID) p.minionGetDamageOrHeal(m, 2);
                }
                p.minionGetDamageOrHeal(p.ownHero, 2);
                p.minionGetDamageOrHeal(p.enemyHero, 2);
            }
        }

    }

    class Sim_EX1_250 : SimTemplate //earthelemental
    {

        //    spott/, überladung:/ (3)
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own) p.ueberladung += 3;
        }


    }

    class Sim_EX1_251 : SimTemplate //forkedlightning
    {

        //    fügt zwei zufälligen feindlichen dienern $2 schaden zu. überladung:/ (2)
        //todo list
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int damage = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            List<Minion> temp2 = new List<Minion>(p.enemyMinions);
            temp2.Sort((a, b) => a.Hp.CompareTo(b.Hp));
            int i = 0;
            foreach (Minion enemy in temp2)
            {
                p.minionGetDamageOrHeal(enemy, damage);
                i++;
                if (i == 2) break;
            }
            if (ownplay) p.ueberladung += 2;
        }

    }

    class Sim_EX1_258 : SimTemplate//Unbound Elemental
    {
        // erhält jedes Mal +1/+1, wenn Ihr eine Karte mit uberladung&lt; ausspielt.
        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (wasOwnCard == triggerEffectMinion.own && c.Recall)
            {
                p.minionGetBuffed(triggerEffectMinion, 1, 1);
            }
        }

    }

    class Sim_EX1_259 : SimTemplate//Lightning Storm
    {
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);
            p.allMinionOfASideGetDamage(!ownplay, dmg);
        }

    }

    class Sim_EX1_274 : SimTemplate //etherealarcanist
    {

        //    erhält +2/+2, wenn ihr am ende eures zuges über ein aktives geheimnis/ verfügt.
        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (triggerEffectMinion.own == turnEndOfOwner)
            {
                int b = (turnEndOfOwner) ? p.ownSecretsIDList.Count : p.enemySecretCount;
                if (b >= 1) p.minionGetBuffed(triggerEffectMinion, 2, 2);

            }
        }

    }

    class Sim_EX1_275 : SimTemplate //coneofcold
    {

        //    friert/ einen diener sowie seine benachbarten diener ein und fügt ihnen $1 schaden zu.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            p.minionGetDamageOrHeal(target, dmg);
            target.frozen = true;
            List<Minion> temp = (target.own) ? p.ownMinions : p.enemyMinions;
            foreach (Minion m in temp)
            {
                if (target.zonepos == m.zonepos + 1 || target.zonepos + 1 == m.zonepos)
                {
                    p.minionGetDamageOrHeal(m, dmg);
                    m.frozen = true;
                }

            }
        }


    }

    class Sim_EX1_277 : SimTemplate //arcanemissiles
    {

        //    verursacht $3 schaden, der zufällig auf feindliche charaktere verteilt wird.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            // optimistic

            int i = 0;
            List<Minion> temp = (ownplay) ? p.enemyMinions : p.ownMinions;
            int times = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);

            if ((ownplay && p.enemyHero.Hp <= times) || (!ownplay && p.ownHero.Hp <= times))
            {
                if (ownplay) p.minionGetDamageOrHeal(p.enemyHero, p.enemyHero.Hp - 1);
                else p.minionGetDamageOrHeal(p.ownHero, p.ownHero.Hp - 1);
            }
            else
            {
                while (i < times)
                {
                    if (temp.Count >= 1)
                    {
                        //search Minion with lowest hp
                        Minion enemy = temp[0];
                        int minhp = 10000;
                        bool found = false;
                        foreach (Minion m in temp)
                        {
                            if (m.name == CardDB.cardName.nerubianegg && enemy.Hp >= 2) continue; //dont attack nerubianegg!

                            if (m.Hp >= 2 && minhp > m.Hp)
                            {
                                enemy = m;
                                minhp = m.Hp;
                                found = true;
                            }
                        }

                        if (found)
                        {
                            p.minionGetDamageOrHeal(enemy, 1);
                        }
                        else
                        {
                            p.minionGetDamageOrHeal(ownplay ? p.enemyHero : p.ownHero, 1);
                        }

                    }
                    else
                    {
                        p.minionGetDamageOrHeal(ownplay ? p.enemyHero : p.ownHero, 1);
                    }

                    i++;
                }
            }
        }

    }


    class Sim_EX1_278 : SimTemplate //shiv
    {

        //    verursacht $1 schaden. zieht eine karte.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            p.minionGetDamageOrHeal(target, dmg);
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_EX1_279 : SimTemplate //pyroblast
    {

        //    verursacht $10 schaden.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(10) : p.getEnemySpellDamageDamage(10);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_EX1_283 : SimTemplate //frostelemental
    {

        //    kampfschrei:/ friert/ einen charakter ein.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            target.frozen = true;
        }


    }

    class Sim_EX1_284 : SimTemplate //azuredrake
    {

        //    zauberschaden +1/. kampfschrei:/ zieht eine karte.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {

            p.drawACard(CardDB.cardName.unknown, own.own);
        }

        public override void onAuraStarts(Playfield p, Minion m)
        {
            if (m.own)
            {
                p.spellpower++;
            }
            else
            {
                p.enemyspellpower++;
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            if (m.own)
            {
                p.spellpower--;
            }
            else
            {
                p.enemyspellpower--;
            }
        }


    }

    class Sim_EX1_287 : SimTemplate //counterspell
    {
        //todo secret
        //    geheimnis:/ wenn euer gegner einen zauber wirkt, kontert/ ihr ihn.

    }

    class Sim_EX1_289 : SimTemplate //icebarrier
    {

        //todo secret
        //    geheimnis:/ wenn euer held angegriffen wird, erhält er 8 rüstung.
        public override void onSecretPlay(Playfield p, bool ownplay, Minion target, int number)
        {

            p.minionGetArmor(target, 8);
        }

    }


    class Sim_EX1_294 : SimTemplate //mirrorentity
    {
        //todo secret
        //    geheimnis:/ wenn euer gegner einen diener ausspielt, beschwört ihr eine kopie desselben herbei.

        public override void onSecretPlay(Playfield p, bool ownplay, Minion target, int number)
        {

            int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;
            p.callKid(target.handcard.card, posi, ownplay);
            if (ownplay)
            {
                if (p.ownMinions.Count >= 1 && p.ownMinions[p.ownMinions.Count - 1].name == target.handcard.card.name)
                {
                    int e = p.ownMinions[p.ownMinions.Count - 1].entitiyID;
                    p.ownMinions[p.ownMinions.Count - 1].setMinionTominion(target);
                    p.ownMinions[p.ownMinions.Count - 1].entitiyID = e;
                    p.ownMinions[p.ownMinions.Count - 1].own = true;
                }
            }
            else
            {
                if (p.enemyMinions.Count >= 1 && p.enemyMinions[p.enemyMinions.Count - 1].name == target.handcard.card.name)
                {
                    int e = p.enemyMinions[p.enemyMinions.Count - 1].entitiyID;
                    p.enemyMinions[p.enemyMinions.Count - 1].setMinionTominion(target);
                    p.enemyMinions[p.enemyMinions.Count - 1].entitiyID = e;
                    p.enemyMinions[p.enemyMinions.Count - 1].own = false;
                }
            }
        }

    }


    class Sim_EX1_295 : SimTemplate //iceblock
    {
        //todo secret
        //    geheimnis:/ wenn euer held tödlichen schaden erleidet, wird dieser verhindert und der held wird immun/ in diesem zug.
        public override void onSecretPlay(Playfield p, bool ownplay, Minion target, int number)
        {
            target.Hp += number;
            target.immune = true;
        }

    }


    class Sim_EX1_298 : SimTemplate //ragnarosthefirelord
    {

        //    kann nicht angreifen. fügt am ende eures zuges einem zufälligen feind 8 schaden zu.

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (triggerEffectMinion.own == turnEndOfOwner)
            {
                int count = (turnEndOfOwner) ? p.enemyMinions.Count : p.ownMinions.Count;
                if (count >= 1)
                {
                    List<Minion> temp2 = (turnEndOfOwner) ? new List<Minion>(p.enemyMinions) : new List<Minion>(p.ownMinions);
                    temp2.Sort((a, b) => a.Hp.CompareTo(b.Hp));//damage the lowest
                    foreach (Minion mins in temp2)
                    {
                        p.minionGetDamageOrHeal(mins, 8);
                        break;
                    }
                }
                else
                {
                    p.minionGetDamageOrHeal(turnEndOfOwner ? p.enemyHero : p.ownHero, 8);
                }
                triggerEffectMinion.stealth = false;
            }
        }

    }


    class Sim_EX1_301 : SimTemplate //felguard
    {

        //    spott/. kampfschrei:/ zerstört einen eurer manakristalle.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                p.ownMaxMana--;
            }
            else
            {
                p.enemyMaxMana--;
            }
        }


    }

    class Sim_EX1_302 : SimTemplate //mortalcoil
    {

        //    fügt einem diener $1 schaden zu. zieht eine karte, wenn er dadurch vernichtet wird.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            if (dmg >= target.Hp && !target.divineshild && !target.immune)
            {
                //this.owncarddraw++;
                p.drawACard(CardDB.cardName.unknown, ownplay);
            }
            p.minionGetDamageOrHeal(target, dmg);

        }

    }

    class Sim_EX1_303 : SimTemplate //shadowflame
    {

        //    vernichtet einen befreundeten diener und fügt allen feindlichen dienern schaden zu, der seinem angriff entspricht.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int damage1 = (ownplay) ? p.getSpellDamageDamage(target.Angr) : p.getEnemySpellDamageDamage(target.Angr);

            p.minionGetDestroyed(target);

            p.allMinionOfASideGetDamage(!ownplay, damage1);

        }

    }

    class Sim_EX1_304 : SimTemplate //voidterror
    {

        //    kampfschrei:/ vernichtet die benachbarten diener und verleiht ihm deren angriff und leben.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.ownMinions : p.enemyMinions;

            int angr = 0;
            int hp = 0;
            foreach (Minion m in temp)
            {
                if (m.zonepos == own.zonepos || m.zonepos == own.zonepos - 1)
                {
                    angr += m.Angr;
                    hp += m.Hp;
                    p.minionGetDestroyed(m);
                }
            }
            p.minionGetBuffed(own, angr, hp);
        }


    }

    class Sim_EX1_306 : SimTemplate //succubus
    {

        //    kampfschrei:/ werft eine zufällige karte ab.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                p.owncarddraw -= Math.Min(1, p.owncards.Count);
                p.owncards.RemoveRange(0, Math.Min(1, p.owncards.Count));
                p.triggerCardsChanged(true);
            }
            else
            {
                if (p.enemyAnzCards >= 1)
                {
                    p.enemycarddraw--;
                    p.enemyAnzCards--;
                    p.triggerCardsChanged(false);
                }
            }
        }

    }

    class Sim_EX1_308 : SimTemplate //soulfire
    {

        //    verursacht $4 schaden. werft eine zufällige karte ab.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(4) : p.getEnemySpellDamageDamage(4);
            p.minionGetDamageOrHeal(target, dmg);
            if (ownplay)
            {
                p.owncarddraw -= Math.Min(1, p.owncards.Count);
                p.owncards.RemoveRange(0, Math.Min(1, p.owncards.Count));
                p.triggerCardsChanged(true);
            }
            else
            {
                if (p.enemyAnzCards >= 1)
                {
                    p.enemycarddraw--;
                    p.enemyAnzCards--;
                    p.triggerCardsChanged(false);
                }
            }
        }

    }

    class Sim_EX1_309 : SimTemplate//Siphon Soul
    {
        //Vernichtet einen Diener. Stellt bei Eurem Helden #3 Leben wieder her.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetDestroyed(target);
            int heal = (ownplay) ? p.getSpellHeal(3) : p.getEnemySpellHeal(3);

            p.minionGetDamageOrHeal(ownplay ? p.ownHero : p.enemyHero, -heal);
        }

    }

    class Sim_EX1_310 : SimTemplate //doomguard
    {

        //    ansturm/. kampfschrei:/ werft zwei zufällige karten ab.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                int anz = Math.Min(2, p.owncards.Count);
                p.owncarddraw -= anz;
                p.owncards.RemoveRange(0, anz);
                if (anz >= 1)
                {
                    p.triggerCardsChanged(true);
                }

            }
            else
            {
                if (p.enemyAnzCards >= 1)
                {
                    p.enemycarddraw--;
                    p.enemyAnzCards--;
                    p.triggerCardsChanged(false);
                }
                if (p.enemyAnzCards >= 1)
                {
                    p.enemycarddraw--;
                    p.enemyAnzCards--;
                    p.triggerCardsChanged(false);
                }
            }


        }

    }

    class Sim_EX1_312 : SimTemplate //twistingnether
    {

        //    vernichtet alle diener.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.allMinionsGetDestroyed();
        }

    }

    class Sim_EX1_313 : SimTemplate //pitlord
    {

        //    kampfschrei:/ fügt eurem helden 5 schaden zu.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.minionGetDamageOrHeal(own.own ? p.ownHero : p.enemyHero, 5);
        }


    }

    class Sim_EX1_315 : SimTemplate //summoningportal
    {

        //    eure diener kosten (2) weniger, aber nicht weniger als (1).
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own) p.beschwoerungsportal++;
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            if (m.own) p.beschwoerungsportal--;
        }


    }

    class Sim_EX1_316 : SimTemplate //poweroverwhelming
    {

        //    verleiht einem befreundeten diener bis zum ende des zuges +4/+4. dann stirbt er. auf schreckliche art und weise.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 4, 4);
            if (ownplay)
            {
                target.destroyOnOwnTurnEnd = true;
            }
            else
            {
                target.destroyOnEnemyTurnEnd = true;
            }

        }

    }

    class Sim_EX1_317 : SimTemplate //sensedemons
    {

        //    fügt eurer hand zwei zufällige dämonen aus eurem deck hinzu.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, ownplay);
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_EX1_317t : SimTemplate //worthlessimp
    {

        //    i&gt;euch sind die dämonen ausgegangen! aber zum glück gibt es ja noch wichtel .../i&gt;


    }

    class Sim_EX1_319 : SimTemplate //flameimp
    {

        //    kampfschrei:/ fügt eurem helden 3 schaden zu.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.minionGetDamageOrHeal(own.own ? p.ownHero : p.enemyHero, 3);
        }


    }

    class Sim_EX1_320 : SimTemplate //baneofdoom
    {

        //    fügt einem charakter $2 schaden zu. beschwört einen zufälligen dämon, wenn der schaden tödlich ist.
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_059);//bloodimp
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {


            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);

            bool summondemon = false;

            if (!target.isHero && dmg >= target.Hp && !target.divineshild && !target.immune)
            {
                summondemon = true;
            }

            p.minionGetDamageOrHeal(target, dmg);

            if (summondemon)
            {
                int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;

                p.callKid(kid, posi, ownplay);
            }

        }

    }

    class Sim_EX1_323 : SimTemplate //lordjaraxxus
    {
        CardDB.Card card = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_tk33);
        CardDB.Card weapon = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_323w);

        //    kampfschrei:/ vernichtet euren helden und ersetzt ihn durch lord jaraxxus.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                p.ownHeroAblility.card = card;
                p.ownHeroName = HeroEnum.lordjaraxxus;
                p.ownHero.Hp = own.Hp;
                p.ownHero.maxHp = own.maxHp;

                p.equipWeapon(weapon, own.own);
            }
            else
            {
                p.enemyHeroAblility.card = card;
                p.enemyHeroName = HeroEnum.lordjaraxxus;
                p.enemyHero.Hp = own.Hp;
                p.enemyHero.maxHp = own.maxHp;

                p.equipWeapon(weapon, own.own);
            }
        }

    }

    class Sim_EX1_323h : SimTemplate //lordjaraxxus
    {

        //


    }

    class Sim_EX1_323w : SimTemplate //bloodfury
    {

        //


    }

    class Sim_EX1_332 : SimTemplate //silence
    {

        //    bringt einen diener zum schweigen/.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetSilenced(target);
        }

    }

    class Sim_EX1_334 : SimTemplate //shadowmadness
    {

        //    übernehmt bis zum ende des zuges die kontrolle über einen feindlichen diener mit max. 3 angriff.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            target.shadowmadnessed = true;
            p.minionGetControlled(target, ownplay, true);
        }

    }

    class Sim_EX1_335 : SimTemplate //lightspawn
    {

        //    der angriff dieses dieners entspricht immer seinem leben.
        //todo dont buff this!
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            own.Angr = own.Hp;
        }

    }

    class Sim_EX1_339 : SimTemplate //thoughtsteal
    {

        //    kopiert 2 karten aus dem deck eures gegners und fügt sie eurer hand hinzu.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, ownplay, true);
            p.drawACard(CardDB.cardName.unknown, ownplay, true);
        }

    }

    class Sim_EX1_341 : SimTemplate//lightwell
    {

        // <deDE>Stellt zu Beginn Eures Zuges bei einem verletzten befreundeten Charakter 3 Leben wieder her.</deDE>
        public override void onTurnStartTrigger(Playfield p, Minion triggerEffectMinion, bool turnStartOfOwner)
        {
            if (turnStartOfOwner == triggerEffectMinion.own)
            {
                int heal = (turnStartOfOwner) ? p.getMinionHeal(3) : p.getEnemyMinionHeal(3);
                List<Minion> temp = (turnStartOfOwner) ? p.ownMinions : p.enemyMinions;
                if (temp.Count >= 1)
                {
                    bool healed = false;
                    foreach (Minion mins in temp)
                    {
                        if (mins.wounded)
                        {
                            p.minionGetDamageOrHeal(mins, -heal);
                            healed = true;
                            break;
                        }
                    }

                    if (!healed)
                    {
                        p.minionGetDamageOrHeal(turnStartOfOwner ? p.ownHero : p.enemyHero, -heal);
                    }
                }
                else
                {
                    p.minionGetDamageOrHeal(turnStartOfOwner ? p.ownHero : p.enemyHero, -heal);
                }

            }
        }
    }

    class Sim_EX1_345 : SimTemplate //mindgames
    {

        //    legt eine kopie eines zufälligen dieners aus dem deck eures gegners auf das schlachtfeld.

        CardDB.Card copymin = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_182); // we take a icewindjety :D

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.callKid(copymin, p.ownMinions.Count, true);
        }

    }

    class Sim_EX1_345t : SimTemplate //shadowofnothing
    {

        //    gedankenspiele verpufft! euer gegner hat keine diener!


    }

    class Sim_EX1_349 : SimTemplate //divinefavor
    {

        //    zieht so viele karten, bis ihr genauso viele karten auf eurer hand habt wie euer gegner.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int diff = (ownplay) ? p.enemyAnzCards - p.owncards.Count : p.owncards.Count - p.enemyAnzCards;
            if (diff >= 1)
            {
                for (int i = 0; i < diff; i++)
                {
                    //this.owncarddraw++;
                    p.drawACard(CardDB.cardName.unknown, ownplay);
                }
            }
        }

    }

    class Sim_EX1_350 : SimTemplate //prophetvelen
    {

        //    verdoppelt den schaden und die heilung eurer zauber und heldenfähigkeiten.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.doublepriest++;
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            if (m.own)
            {
                p.doublepriest--;
            }
        }

    }

    class Sim_EX1_354 : SimTemplate//lay on hands
    {

        //Stellt #8 Leben wieder her. Zieht 3 Karten.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int heal = (ownplay) ? p.getSpellHeal(8) : p.getEnemySpellHeal(8);
            p.minionGetDamageOrHeal(target, -heal);
            for (int i = 0; i < 3; i++)
            {
                //this.owncarddraw++;
                p.drawACard(CardDB.cardName.unknown, ownplay);
            }

        }

    }

    class Sim_EX1_355 : SimTemplate //blessedchampion
    {

        //    verdoppelt den angriff eines dieners.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, target.Angr, 0);
        }

    }

    class Sim_EX1_360 : SimTemplate//Humility
    {

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionSetAngrToOne(target);
        }

    }

    class Sim_EX1_362 : SimTemplate //argentprotector
    {

        //    kampfschrei:/ verleiht einem befreundeten diener gottesschild/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) target.divineshild = true;
        }

    }

    class Sim_EX1_363 : SimTemplate //blessingofwisdom
    {

        //    wählt einen diener aus. zieht jedes mal eine karte, wenn er angreift.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                target.ownBlessingOfWisdom++;
            }
            else
            {
                target.enemyBlessingOfWisdom++;
            }

        }

    }

    class Sim_EX1_365 : SimTemplate //holywrath
    {
        // todo ask the posibility manager!
        //    zieht eine karte und verursacht schaden, der ihren kosten entspricht.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, ownplay);

            int dmg = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_EX1_366 : SimTemplate //swordofjustice
    {
        CardDB.Card card = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_366);

        //    jedes mal, wenn ihr einen diener herbeiruft, erhält dieser +1/+1 und diese waffe verliert 1 haltbarkeit.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(card, ownplay);
        }

        public override void onMinionIsSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            if (triggerEffectMinion.own == summonedMinion.own)
            {
                p.minionGetBuffed(summonedMinion, 1, 1);
                p.lowerWeaponDurability(1, triggerEffectMinion.own);
            }
        }
    }

    class Sim_EX1_371 : SimTemplate //handofprotection
    {

        //    verleiht einem diener gottesschild/.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            target.divineshild = true;
        }

    }

    class Sim_EX1_379 : SimTemplate //repentance
    {
        //    geheimnis:/ wenn euer gegner einen diener ausspielt, wird dessen leben auf 1 verringert.

        public override void onSecretPlay(Playfield p, bool ownplay, Minion target, int number)
        {
            target.Hp = 1;
            target.maxHp = 1;
            target.wounded = false;

        }

    }


    class Sim_EX1_382 : SimTemplate //aldorpeacekeeper
    {

        //    kampfschrei:/ setzt den angriff eines feindlichen dieners auf 1.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionSetAngrToOne(target);
        }

    }

    class Sim_EX1_383 : SimTemplate //tirionfordring
    {
        CardDB.Card card = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_383t);
        //    gottesschild/. spott/. todesröcheln:/ legt einen aschenbringer (5/3) an.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.equipWeapon(card, m.own);
        }

    }

    class Sim_EX1_383t : SimTemplate //ashbringer
    {

        //
        CardDB.Card wcard = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_383t);
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(wcard, ownplay);
        }

    }

    class Sim_EX1_384 : SimTemplate //avengingwrath
    {

        //    verursacht $8 schaden, der zufällig auf feindliche charaktere verteilt wird.
        //todo for enemy
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            // optimistic

            int i = 0;
            List<Minion> temp = (ownplay) ? p.enemyMinions : p.ownMinions;
            int times = (ownplay) ? p.getSpellDamageDamage(8) : p.getEnemySpellDamageDamage(8);

            if ((ownplay && p.enemyHero.Hp <= times) || (!ownplay && p.ownHero.Hp <= times))
            {
                if (ownplay) p.minionGetDamageOrHeal(p.enemyHero, p.enemyHero.Hp - 1);
                else p.minionGetDamageOrHeal(p.ownHero, p.ownHero.Hp - 1);
            }
            else
            {
                while (i < times)
                {
                    if (temp.Count >= 1)
                    {
                        //search Minion with lowest hp
                        Minion enemy = temp[0];
                        int minhp = 10000;
                        bool found = false;
                        foreach (Minion m in temp)
                        {
                            if (m.name == CardDB.cardName.nerubianegg && enemy.Hp >= 2) continue; //dont attack nerubianegg!

                            if (m.Hp >= 2 && minhp > m.Hp)
                            {
                                enemy = m;
                                minhp = m.Hp;
                                found = true;
                            }
                        }

                        if (found)
                        {
                            p.minionGetDamageOrHeal(enemy, 1);
                        }
                        else
                        {
                            p.minionGetDamageOrHeal(ownplay ? p.enemyHero : p.ownHero, 1);
                        }

                    }
                    else
                    {
                        p.minionGetDamageOrHeal(ownplay ? p.enemyHero : p.ownHero, 1);
                    }

                    i++;
                }
            }
        }

    }


    class Sim_EX1_390 : SimTemplate //taurenwarrior
    {

        //    spott/, wutanfall:/ +3 angriff

        public override void onEnrageStart(Playfield p, Minion m)
        {
            m.Angr += 3;
        }

        public override void onEnrageStop(Playfield p, Minion m)
        {
            m.Angr -= 3;
        }

    }

    class Sim_EX1_391 : SimTemplate //slam
    {

        //    fügt einem diener $2 schaden zu. zieht eine karte, wenn er überlebt.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {

            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            if (target.Hp > dmg || target.immune || target.divineshild)
            {
                //this.owncarddraw++;
                p.drawACard(CardDB.cardName.unknown, ownplay);
            }
            p.minionGetDamageOrHeal(target, dmg);

        }

    }

    class Sim_EX1_392 : SimTemplate //battlerage
    {

        //    zieht eine karte für jeden verletzten befreundeten charakter.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;
            foreach (Minion mnn in temp)
            {
                if (mnn.wounded)
                {
                    p.drawACard(CardDB.cardName.unknown, ownplay);
                }
            }
            if (ownplay && p.ownHero.Hp < 30) p.drawACard(CardDB.cardName.unknown, true);
            if (!ownplay && p.enemyHero.Hp < 30) p.drawACard(CardDB.cardName.unknown, false);

        }

    }

    class Sim_EX1_393 : SimTemplate //amaniberserker
    {

        //    wutanfall:/ +3 angriff

        public override void onEnrageStart(Playfield p, Minion m)
        {
            m.Angr += 3;
        }

        public override void onEnrageStop(Playfield p, Minion m)
        {
            m.Angr -= 3;
        }

    }

    class Sim_EX1_396 : SimTemplate//mogushan warden
    {


    }

    class Sim_EX1_398 : SimTemplate//Arathi Weaponsmith
    {
        CardDB.Card wcard = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_398t);//battleaxe

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.equipWeapon(wcard, own.own);

        }

    }

    class Sim_EX1_398t : SimTemplate //battleaxe
    {

        //
        CardDB.Card wcard = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_398t);
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(wcard, ownplay);
        }
    }

    class Sim_EX1_399 : SimTemplate //gurubashiberserker
    {

        //    erhält jedes mal +3 angriff, wenn dieser diener schaden erleidet.
        public override void onMinionGotDmgTrigger(Playfield p, Minion triggerEffectMinion, bool ownDmgdmin)
        {
            if (triggerEffectMinion.anzGotDmg >= 1)
            {
                triggerEffectMinion.Angr += 3 * triggerEffectMinion.anzGotDmg;
                triggerEffectMinion.anzGotDmg = 0;
            }
        }

    }

    class Sim_EX1_400 : SimTemplate //whirlwind
    {

        //    fügt allen dienern $1 schaden zu.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            p.allMinionsGetDamage(dmg);
        }

    }

    class Sim_EX1_402 : SimTemplate //armorsmith
    {

        //    erhaltet jedes mal 1 rüstung, wenn ein befreundeter diener schaden erleidet.

        public override void onMinionGotDmgTrigger(Playfield p, Minion triggerEffectMinion, bool ownDmgdmin)
        {
            if (triggerEffectMinion.own == ownDmgdmin)
            {
                if (triggerEffectMinion.own)
                {
                    p.minionGetArmor(p.ownHero, 1);
                }
                else
                {
                    p.minionGetArmor(p.enemyHero, 1);
                }
            }
        }

    }

    class Sim_EX1_405 : SimTemplate //shieldbearer
    {

        //    spott/


    }

    class Sim_EX1_407 : SimTemplate //brawl
    {

        //    vernichtet alle diener bis auf einen. (zufällige auswahl)

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.allMinionsGetDestroyed();
        }

    }

    class Sim_EX1_408 : SimTemplate //mortalstrike
    {

        //    verursacht $4 schaden. verursacht stattdessen $6 schaden, wenn euer held max. 12 leben hat.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = 0;

            if (ownplay)
            {
                dmg = (p.ownHero.Hp <= 12) ? p.getSpellDamageDamage(6) : p.getSpellDamageDamage(4);
            }
            else
            {
                dmg = (p.enemyHero.Hp <= 12) ? p.getEnemySpellDamageDamage(6) : p.getEnemySpellDamageDamage(4);
            }
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_EX1_409 : SimTemplate //upgrade
    {
        CardDB.Card wcard = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_409t);//heavyaxe
        //    wenn ihr eine waffe habt, erhält sie +1/+1. legt anderenfalls eine waffe (1/3) an.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                if (p.ownWeaponName != CardDB.cardName.unknown)
                {
                    p.ownWeaponAttack++;
                    p.ownWeaponDurability++;
                    p.minionGetBuffed(p.ownHero, 1, 0);
                }
                else
                {

                    p.equipWeapon(wcard, true);
                }
            }
            else
            {
                if (p.enemyWeaponName != CardDB.cardName.unknown)
                {
                    p.enemyWeaponAttack++;
                    p.enemyWeaponDurability++;
                    p.minionGetBuffed(p.enemyHero, 1, 0);
                }
                else
                {

                    p.equipWeapon(wcard, false);
                }
            }
        }

    }


    class Sim_EX1_409t : SimTemplate //heavyaxe
    {

        //


    }

    class Sim_EX1_410 : SimTemplate //shieldslam
    {

        //    fügt einem diener für jeden eurer rüstungspunkte 1 schaden zu.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {


            int dmg = (ownplay) ? p.getSpellDamageDamage(p.ownHero.armor) : p.getEnemySpellDamageDamage(p.enemyHero.armor);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_EX1_411 : SimTemplate//Gorehowl
    {
        CardDB.Card wcard = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_411);
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(wcard, ownplay);
        }

    }

    class Sim_EX1_412 : SimTemplate //ragingworgen
    {

        //    wutanfall:/ windzorn/ und +1 angriff
        public override void onEnrageStart(Playfield p, Minion m)
        {
            m.Angr++;
            p.minionGetWindfurry(m);
        }

        public override void onEnrageStop(Playfield p, Minion m)
        {
            m.Angr--;
            m.windfury = false;
            if (m.numAttacksThisTurn == 1) m.Ready = false;
        }


    }

    class Sim_EX1_414 : SimTemplate //grommashhellscream
    {

        //    ansturm/, wutanfall:/ +6 angriff
        public override void onEnrageStart(Playfield p, Minion m)
        {
            m.Angr += 6;
        }

        public override void onEnrageStop(Playfield p, Minion m)
        {
            m.Angr -= 6;
        }

    }

    class Sim_EX1_506 : SimTemplate //murloctidehunter
    {
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_506a);//murlocscout
        //    kampfschrei:/ ruft einen murlocspäher (1/1) herbei.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.callKid(kid, own.zonepos, own.own, true);
        }


    }

    class Sim_EX1_506a : SimTemplate //murlocscout
    {

        //


    }

    class Sim_EX1_507 : SimTemplate //murlocwarleader
    {

        //    alle anderen murlocs haben +2/+1.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            p.anzMurlocWarleader++;
            foreach (Minion m in p.ownMinions)
            {
                if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MURLOC && own.entitiyID != m.entitiyID) p.minionGetBuffed(m, 2, 1);
            }
            foreach (Minion m in p.enemyMinions)
            {
                if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MURLOC && own.entitiyID != m.entitiyID) p.minionGetBuffed(m, 2, 1);
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            p.anzMurlocWarleader--;
            foreach (Minion mn in p.ownMinions)
            {
                if ((TAG_RACE)mn.handcard.card.race == TAG_RACE.MURLOC && mn.entitiyID != m.entitiyID) p.minionGetBuffed(m, -2, -1);
            }
            foreach (Minion mn in p.enemyMinions)
            {
                if ((TAG_RACE)mn.handcard.card.race == TAG_RACE.MURLOC && mn.entitiyID != m.entitiyID) p.minionGetBuffed(m, -2, -1);
            }
        }



    }

    class Sim_EX1_508 : SimTemplate//Grimscale Oracle
    {
        public override void onAuraStarts(Playfield p, Minion own)
        {
            p.anzGrimscaleOracle++;
            foreach (Minion m in p.ownMinions)
            {
                if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MURLOC && own.entitiyID != m.entitiyID) p.minionGetBuffed(m, 1, 0);
            }
            foreach (Minion m in p.enemyMinions)
            {
                if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MURLOC && own.entitiyID != m.entitiyID) p.minionGetBuffed(m, 1, 0);
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            p.anzGrimscaleOracle--;
            foreach (Minion mn in p.ownMinions)
            {
                if ((TAG_RACE)mn.handcard.card.race == TAG_RACE.MURLOC && mn.entitiyID != m.entitiyID) p.minionGetBuffed(m, -1, 0);
            }
            foreach (Minion mn in p.enemyMinions)
            {
                if ((TAG_RACE)mn.handcard.card.race == TAG_RACE.MURLOC && mn.entitiyID != m.entitiyID) p.minionGetBuffed(m, -1, 0);
            }
        }
    }

    class Sim_EX1_509 : SimTemplate //murloctidecaller
    {

        //    erhält jedes mal +1 angriff, wenn ein murloc herbeigerufen wird.
        public override void onMinionIsSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            if ((TAG_RACE)summonedMinion.handcard.card.race == TAG_RACE.MURLOC) p.minionGetBuffed(triggerEffectMinion, 1, 0);
        }

    }

    class Sim_EX1_522 : SimTemplate//patient assasin
    {


    }

    class Sim_EX1_531 : SimTemplate //scavenginghyena
    {

        //    erhält jedes mal +2/+1, wenn ein befreundetes wildtier stirbt.

        public override void onMinionDiedTrigger(Playfield p, Minion triggerEffectMinion, Minion diedMinion)
        {
            if (triggerEffectMinion.own == diedMinion.own && (TAG_RACE)diedMinion.handcard.card.race == TAG_RACE.PET)
            {
                p.minionGetBuffed(triggerEffectMinion, 2, 1);
            }
        }

    }

    class Sim_EX1_533 : SimTemplate//Misdirection
    {
        public override void onSecretPlay(Playfield p, bool ownplay, Minion attacker, Minion target, out int number)
        {
            number = 0;
            Minion newTarget = null;
            if (ownplay)
            {
                foreach (Minion m in p.enemyMinions)
                {
                    if (target.entitiyID != m.entitiyID && attacker.entitiyID != m.entitiyID)
                    {
                        newTarget = m;
                    }
                }

                if (newTarget == null)
                {
                    foreach (Minion m in p.ownMinions)
                    {
                        if (target.entitiyID != m.entitiyID && attacker.entitiyID != m.entitiyID)
                        {
                            newTarget = m;
                        }
                    }
                }

                if (newTarget == null)
                {
                    newTarget = p.enemyHero;
                }
            }

            else
            {
                foreach (Minion m in p.ownMinions)
                {
                    if (target.entitiyID != m.entitiyID && attacker.entitiyID != m.entitiyID)
                    {
                        newTarget = m;
                    }
                }

                if (newTarget == null)
                {
                    foreach (Minion m in p.enemyMinions)
                    {
                        if (target.entitiyID != m.entitiyID && attacker.entitiyID != m.entitiyID)
                        {
                            newTarget = m;
                        }
                    }
                }

                if (newTarget == null)
                {
                    newTarget = p.ownHero;
                }
            }


            if (newTarget != null)
            {
                number = newTarget.entitiyID;
            }
        }

    }


    class Sim_EX1_534 : SimTemplate //savannahhighmane
    {

        //    todesröcheln:/ ruft zwei hyänen (2/2) herbei.#
        CardDB.Card c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_534t);//hyena

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.callKid(c, m.zonepos - 1, m.own);
            p.callKid(c, m.zonepos - 1, m.own);
        }

    }

    class Sim_EX1_534t : SimTemplate //hyena
    {

        //


    }

    class Sim_EX1_536 : SimTemplate //eaglehornbow
    {

        //    erhält jedes mal +1 haltbarkeit, wenn ein eigenes geheimnis/ aufgedeckt wird.

        CardDB.Card weapon = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_536);

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(weapon, ownplay);
        }

    }

    class Sim_EX1_537 : SimTemplate //explosiveshot
    {

        //    fügt einem diener $5 schaden und benachbarten dienern $2 schaden zu.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg1 = (ownplay) ? p.getSpellDamageDamage(5) : p.getEnemySpellDamageDamage(5);
            int dmg2 = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            List<Minion> temp = (target.own) ? p.ownMinions : p.enemyMinions;
            p.minionGetDamageOrHeal(target, dmg1);
            foreach (Minion m in temp)
            {
                if (m.zonepos + 1 == target.zonepos || m.zonepos - 1 == target.zonepos) p.minionGetDamageOrHeal(m, dmg2);
            }
        }

    }

    class Sim_EX1_538 : SimTemplate //unleashthehounds
    {

        //    ruft für jeden feindlichen diener einen jagdhund (1/1) mit ansturm/ herbei.

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_538t);//hound

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int anz = p.enemyMinions.Count;
            int posi = p.ownMinions.Count;

            for (int i = 0; i < anz; i++)
            {
                p.callKid(kid, posi, ownplay);
            }
        }

    }

    class Sim_EX1_538t : SimTemplate //hound
    {

        //    ansturm/


    }

    class Sim_EX1_539 : SimTemplate //killcommand
    {

        //    verursacht $3 schaden. verursacht stattdessen $5 schaden, wenn ihr ein wildtier besitzt.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                bool haspet = false;
                foreach (Minion m in p.ownMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PET)
                    {
                        haspet = true;
                        break;
                    }
                }

                int dmg = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);
                if (haspet) dmg = (ownplay) ? p.getSpellDamageDamage(5) : p.getEnemySpellDamageDamage(5);
                p.minionGetDamageOrHeal(target, dmg);
            }
        }

    }

    class Sim_EX1_543 : SimTemplate //kingkrush
    {

        //    ansturm/


    }

    class Sim_EX1_544 : SimTemplate //flare
    {

        //    alle diener verlieren verstohlenheit/. zerstört alle feindlichen geheimnisse/. zieht eine karte.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            foreach (Minion m in p.ownMinions)
            {
                m.stealth = false;
            }
            foreach (Minion m in p.enemyMinions)
            {
                m.stealth = false;
            }
            if (ownplay)
            {
                p.enemySecretCount = 0;
                p.enemySecretList.Clear();
            }
            else
            {
                p.ownSecretsIDList.Clear();
            }
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }


    class Sim_EX1_549 : SimTemplate //bestialwrath
    {

        //    verleiht einem wildtier +2 angriff und immunität/ in diesem zug.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetTempBuff(target, 2, 0);
            target.immune = true;
        }

    }

    class Sim_EX1_554 : SimTemplate //snaketrap
    {
        //todo secret
        //    geheimnis:/ wenn einer eurer diener angegriffen wird, ruft ihr drei schlangen (1/1) herbei.
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_554t);//snake

        public override void onSecretPlay(Playfield p, bool ownplay, int number)
        {
            if (ownplay)
            {
                int posi = p.ownMinions.Count;
                p.callKid(kid, posi, true);
                p.callKid(kid, posi, true);
                p.callKid(kid, posi, true);
            }
            else
            {
                int posi = p.enemyMinions.Count;
                p.callKid(kid, posi, false);
                p.callKid(kid, posi, false);
                p.callKid(kid, posi, false);
            }
        }

    }


    class Sim_EX1_554t : SimTemplate //snake
    {

        //


    }

    class Sim_EX1_556 : SimTemplate //harvestgolem
    {

        //    todesröcheln:/ ruft einen beschädigten golem (2/1) herbei.

        CardDB.Card card = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.skele21);

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.callKid(card, m.zonepos - 1, m.own);
        }

    }

    class Sim_EX1_557 : SimTemplate //natpagle
    {

        //    zu beginn eures zuges besteht eine chance von 50%, dass ihr eine zusätzliche karte zieht.
        public override void onTurnStartTrigger(Playfield p, Minion triggerEffectMinion, bool turnStartOfOwner)
        {
            if (triggerEffectMinion.own == turnStartOfOwner)
            {
                p.drawACard(CardDB.cardName.unknown, turnStartOfOwner);
            }
        }

    }

    class Sim_EX1_558 : SimTemplate //harrisonjones
    {
        //    kampfschrei:/ zerstört die waffe eures gegners. zieht ihrer haltbarkeit entsprechend karten.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                //this.owncarddraw += enemyWeaponDurability;
                for (int i = 0; i < p.enemyWeaponDurability; i++)
                {
                    p.drawACard(CardDB.cardName.unknown, true);
                }
                p.lowerWeaponDurability(1000, false);
            }
            else
            {
                for (int i = 0; i < p.enemyWeaponDurability; i++)
                {
                    p.drawACard(CardDB.cardName.unknown, false);
                }
                p.lowerWeaponDurability(1000, true);
            }
        }


    }

    class Sim_EX1_559 : SimTemplate //archmageantonidas
    {

        //    erhaltet jedes mal einen „feuerball“-zauber auf eure hand, wenn ihr einen zauber wirkt.

        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (wasOwnCard == triggerEffectMinion.own && c.type == CardDB.cardtype.SPELL)
            {
                p.drawACard(CardDB.cardName.fireball, wasOwnCard, true);
            }
        }

    }

    class Sim_EX1_560 : SimTemplate //nozdormu
    {

        //    spieler haben nur jeweils 15 sekunden für ihren zug.

        //todo

    }

    class Sim_EX1_561 : SimTemplate //alexstrasza
    {

        //    kampfschrei:/ setzt das verbleibende leben eines helden auf 15.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            target.Hp = 15;
        }


    }

    class Sim_EX1_562 : SimTemplate //onyxia
    {

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_116t);//whelp

        //    kampfschrei:/ ruft welplinge (1/1) herbei, bis eure seite des schlachtfelds voll ist.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int kids = 7 - p.ownMinions.Count;

            for (int i = 0; i < kids; i++)
            {
                p.callKid(kid, own.zonepos, own.own, true);
            }

        }


    }

    class Sim_EX1_563 : SimTemplate //malygos
    {

        //    zauberschaden +5/
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.spellpower += 5;
            }
            else
            {
                p.enemyspellpower += 5;
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            if (m.own)
            {
                p.spellpower -= 5;
            }
            else
            {
                p.enemyspellpower -= 5;
            }
        }

    }

    class Sim_EX1_564 : SimTemplate //facelessmanipulator
    {

        //    kampfschrei:/ wählt einen diener aus, um gesichtsloser manipulator in eine kopie desselben zu verwandeln.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null)
            {
                //p.copyMinion(own, target);
                bool source = own.own;
                own.setMinionTominion(target);
                own.own = source;
                own.handcard.card.sim_card.onAuraStarts(p, own);
            }
        }


    }

    class Sim_EX1_565 : SimTemplate//Flametongue Totem
    {
        // note buff and debuff is handled by playfield (faster)
        /*
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                foreach (Minion m in p.ownMinions)
                {
                    if (m.zonepos - 1 == own.zonepos || m.zonepos + 1 == own.zonepos)
                    {
                        p.minionGetAdjacentBuff(m, 2, 0);
                    }
                }
            }
            else
            {
                foreach (Minion m in p.enemyMinions)
                {
                    if (m.zonepos - 1 == own.zonepos || m.zonepos + 1 == own.zonepos)
                    {
                        p.minionGetAdjacentBuff(m, 2, 0);
                    }
                }
            }

        }


        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own)
            {
                foreach (Minion m in p.ownMinions)
                {
                    if (m.zonepos - 1 == own.zonepos || m.zonepos + 1 == own.zonepos)
                    {
                        p.minionGetAdjacentBuff(m, -2, 0);
                    }
                }
            }
            else
            {
                foreach (Minion m in p.enemyMinions)
                {
                    if (m.zonepos - 1 == own.zonepos || m.zonepos + 1 == own.zonepos)
                    {
                        p.minionGetAdjacentBuff(m, -2, 0);
                    }
                }
            }
        }
        */


    }

    class Sim_EX1_567 : SimTemplate //doomhammer
    {

        //    windzorn/, überladung:/ (2)
        CardDB.Card card = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_567);

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay) p.ueberladung += 2;
            p.equipWeapon(card, ownplay);
        }

    }

    class Sim_EX1_570 : SimTemplate //bite
    {

        //    verleiht eurem helden +4 angriff in diesem zug und 4 rüstung.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                p.minionGetTempBuff(p.ownHero, 4, 0);
                p.minionGetArmor(p.ownHero, 4);
            }
            else
            {
                p.minionGetTempBuff(p.enemyHero, 4, 0);
                p.minionGetArmor(p.enemyHero, 4);

            }
        }

    }

    class Sim_EX1_571 : SimTemplate //forceofnature
    {

        //    ruft drei treants (2/2) mit ansturm/ herbei, die am ende des zuges sterben.
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_tk9);//Treant

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;

            p.callKid(kid, posi, ownplay);
            p.callKid(kid, posi, ownplay);
            p.callKid(kid, posi, ownplay);
        }

    }

    class Sim_EX1_572 : SimTemplate //ysera
    {

        //    zieht am ende eures zuges eine traumkarte.

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (triggerEffectMinion.own == turnEndOfOwner)
            {
                p.drawACard(CardDB.cardName.yseraawakens, turnEndOfOwner, true);
            }
        }

    }

    class Sim_EX1_573 : SimTemplate //cenarius
    {

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_573t); //special treant
        //    wählt aus:/ verleiht euren anderen dienern +2/+2; oder ruft zwei treants (2/2) mit spott/ herbei.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (choice == 1)
            {
                List<Minion> temp = (own.own) ? p.ownMinions : p.enemyMinions;
                foreach (Minion m in temp)
                {
                    p.minionGetBuffed(m, 2, 2);
                }
            }
            if (choice == 2)
            {

                int pos = (own.own) ? p.ownMinions.Count : p.enemyMinions.Count;
                p.callKid(kid, pos, own.own, true);
                p.callKid(kid, pos, own.own, true);
            }
        }



    }

    class Sim_EX1_573a : SimTemplate //demigodsfavor
    {

        //    verleiht euren anderen dienern +2/+2.


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;
            foreach (Minion m in temp)
            {
                p.minionGetBuffed(m, 2, 2);
            }
        }

    }

    class Sim_EX1_573b : SimTemplate //shandoslesson
    {

        //    ruft zwei treants (2/2) mit spott/ herbei.
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_573t); //special treant
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int pos = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;
            p.callKid(kid, pos, ownplay, true);
            p.callKid(kid, pos, ownplay, true);
        }

    }

    class Sim_EX1_573t : SimTemplate //treant
    {

        //    spott/


    }

    class Sim_EX1_575 : SimTemplate //manatidetotem
    {

        //    zieht am ende eures zuges eine karte.
        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (turnEndOfOwner == triggerEffectMinion.own)
            {
                p.drawACard(CardDB.cardName.unknown, turnEndOfOwner);
            }
        }

    }

    class Sim_EX1_577 : SimTemplate //thebeast
    {

        //    todesröcheln:/ ruft finkle einhorn (3/3) für euren gegner herbei.
        CardDB.Card c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_finkle);//finkleeinhorn
        public override void onDeathrattle(Playfield p, Minion m)
        {

            int place = (m.own) ? p.enemyMinions.Count : p.ownMinions.Count;
            p.callKid(c, place, !m.own);
        }

    }

    class Sim_EX1_578 : SimTemplate //savagery
    {

        //    fügt einem diener schaden zu, der dem angriff eures helden entspricht.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(p.ownHero.Angr) : p.getEnemySpellDamageDamage(p.enemyHero.Angr);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_EX1_581 : SimTemplate //sap
    {

        //    lasst einen feindlichen diener auf die hand eures gegners zurückkehren.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionReturnToHand(target, !ownplay, 0);
        }

    }

    class Sim_EX1_582 : SimTemplate //dalaranmage
    {

        //    zauberschaden +1/
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.spellpower++;
            }
            else
            {
                p.enemyspellpower++;
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            if (m.own)
            {
                p.spellpower--;
            }
            else
            {
                p.enemyspellpower--;
            }
        }

    }

    class Sim_EX1_583 : SimTemplate //priestessofelune
    {

        //    kampfschrei:/ stellt bei eurem helden 4 leben wieder her.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int heal = (own.own) ? p.getMinionHeal(4) : p.getEnemyMinionHeal(4);
            p.minionGetDamageOrHeal(own.own ? p.ownHero : p.enemyHero, -heal);
        }


    }

    class Sim_EX1_584 : SimTemplate //ancientmage
    {
        //    kampfschrei:/ verleiht benachbarten dienern zauberschaden +1/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.ownMinions : p.enemyMinions;
            foreach (Minion m in temp)
            {
                if (m.zonepos == own.zonepos || m.zonepos + 1 == own.zonepos)
                {
                    m.spellpower++;
                    if (own.own)
                    {
                        p.spellpower++;
                    }
                    else
                    {
                        p.enemyspellpower++;
                    }
                }
            }
        }


    }

    class Sim_EX1_586 : SimTemplate //seagiant
    {

        //    kostet (1) weniger für jeden anderen diener auf dem schlachtfeld.

    }

    class Sim_EX1_587 : SimTemplate //windspeaker
    {

        //    kampfschrei:/ verleiht einem befreundeten diener windzorn/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionGetWindfurry(target);
        }


    }

    class Sim_EX1_590 : SimTemplate //bloodknight
    {

        //    kampfschrei:/ alle diener verlieren gottesschild/. erhält +3/+3 für jeden verlorenen schild.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int shilds = 0;
            foreach (Minion m in p.ownMinions)
            {
                if (m.divineshild)
                {
                    m.divineshild = false;
                    shilds++;
                }
            }
            foreach (Minion m in p.enemyMinions)
            {
                if (m.divineshild)
                {
                    m.divineshild = false;
                    shilds++;
                }
            }
            p.minionGetBuffed(own, 3 * shilds, 3 * shilds);
        }


    }

    class Sim_EX1_591 : SimTemplate //auchenaisoulpriest
    {

        //    eure karten und fähigkeiten, die leben wiederherstellen, verursachen stattdessen nun schaden.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnAuchenaiSoulpriest++;
            }
            else
            {
                p.anzEnemyAuchenaiSoulpriest++;
            }

        }

        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnAuchenaiSoulpriest--;
            }
            else
            {
                p.anzEnemyAuchenaiSoulpriest--;
            }
        }


    }

    class Sim_EX1_593 : SimTemplate //nightblade
    {

        //    kampfschrei: /fügt dem feindlichen helden 3 schaden zu.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.minionGetDamageOrHeal(own.own ? p.enemyHero : p.ownHero, 3);
        }

    }

    class Sim_EX1_594 : SimTemplate //vaporize
    {
        //todo secret
        //    geheimnis:/ wenn ein diener euren helden angreift, wird er vernichtet.
        public override void onSecretPlay(Playfield p, bool ownplay, Minion target, int number)
        {
            p.minionGetDestroyed(target);
        }

    }


    class Sim_EX1_595 : SimTemplate //cultmaster
    {

        //    zieht jedes mal eine karte, wenn einer eurer anderen diener stirbt.

        public override void onMinionDiedTrigger(Playfield p, Minion triggerEffectMinion, Minion diedMinion)
        {
            if (triggerEffectMinion.own == diedMinion.own)
            {
                p.drawACard(CardDB.cardName.unknown, triggerEffectMinion.own);
            }
        }

    }

    class Sim_EX1_596 : SimTemplate //demonfire
    {

        //    fügt einem diener $2 schaden zu. wenn das ziel ein verbündeter dämon ist, erhält er stattdessen +2/+2.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (target.handcard.card.race == 15 && ownplay == target.own)
            {
                p.minionGetBuffed(target, 2, 2);
            }
            else
            {
                int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
                p.minionGetDamageOrHeal(target, dmg);
            }
        }


    }

    class Sim_EX1_597 : SimTemplate //impmaster
    {

        //    fügt am ende eures zuges diesem diener 1 schaden zu und beschwört einen wichtel (1/1).

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_598);//imp

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (triggerEffectMinion.own == turnEndOfOwner)
            {
                int posi = triggerEffectMinion.zonepos;
                if (triggerEffectMinion.Hp == 1) posi--;
                p.minionGetDamageOrHeal(triggerEffectMinion, 1);
                p.callKid(kid, posi, triggerEffectMinion.own);
                triggerEffectMinion.stealth = false;
            }
        }

    }

    class Sim_EX1_598 : SimTemplate //imp
    {

        //


    }

    class Sim_EX1_603 : SimTemplate //crueltaskmaster
    {

        //    kampfschrei:/ fügt einem diener 1 schaden zu und verleiht ihm +2 angriff.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null)
            {
                p.minionGetDamageOrHeal(target, 1);
                p.minionGetTempBuff(target, 2, 0);
            }

        }

    }

    class Sim_EX1_604 : SimTemplate //frothingberserker
    {

        //    erhält jedes mal +1 angriff, wenn ein diener schaden erleidet.

        public override void onMinionGotDmgTrigger(Playfield p, Minion triggerEffectMinion, bool ownDmgdmin)
        {
            p.minionGetBuffed(triggerEffectMinion, 1, 0);
        }

    }

    class Sim_EX1_606 : SimTemplate //shieldblock
    {

        //    erhaltet 5 rüstung. zieht eine karte.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                p.minionGetArmor(p.ownHero, 5);
            }
            else
            {
                p.minionGetArmor(p.enemyHero, 5);
            }
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_EX1_607 : SimTemplate //innerrage
    {

        //    fügt einem diener $1 schaden zu. der diener erhält +2 angriff.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);
            p.minionGetDamageOrHeal(target, dmg);
            p.minionGetTempBuff(target, 2, 0);
        }

    }

    class Sim_EX1_608 : SimTemplate //sorcerersapprentice
    {

        //    eure zauber kosten (1) weniger.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnsorcerersapprentice++;
            }
            else
            {
                p.anzEnemysorcerersapprentice++;

            }

        }

        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnsorcerersapprentice--;
            }
            else
            {
                p.anzEnemysorcerersapprentice--;
            }
        }
    }

    class Sim_EX1_609 : SimTemplate //snipe
    {
        //todo secret
        //    geheimnis:/ wenn euer gegner einen diener ausspielt, werden diesem $4 schaden zugefügt.

        public override void onSecretPlay(Playfield p, bool ownplay, Minion target, int number)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(4) : p.getEnemySpellDamageDamage(4);

            p.minionGetDamageOrHeal(target, dmg);
        }

    }


    class Sim_EX1_610 : SimTemplate //explosivetrap
    {
        //todo secret
        //    geheimnis:/ wenn euer held angegriffen wird, erleiden alle feinde $2 schaden.
        public override void onSecretPlay(Playfield p, bool ownplay, int number)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            p.allMinionOfASideGetDamage(!ownplay, dmg);
        }

    }


    class Sim_EX1_611 : SimTemplate //freezingtrap
    {
        //todo secret
        //    geheimnis:/ wenn ein feindlicher diener angreift, lasst ihn auf die hand seines besitzers zurückkehren. zusätzlich kostet er (2) mehr.

        public override void onSecretPlay(Playfield p, bool ownplay, Minion target, int number)
        {
            p.minionReturnToHand(target, !ownplay, 2);
            target.Hp = -100;
        }

    }

    class Sim_EX1_612 : SimTemplate //kirintormage
    {

        //    kampfschrei:/ das nächste geheimnis/, das ihr in diesem zug ausspielt, kostet (0).

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own) p.playedmagierinderkirintor = true;
        }


    }

    class Sim_EX1_613 : SimTemplate//edwin van cleefe
    {
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {

            if (own.own) p.minionGetBuffed(own, p.cardsPlayedThisTurn * 2, p.cardsPlayedThisTurn * 2);
            else p.minionGetBuffed(own, p.enemyAnzCards * 2, p.enemyAnzCards * 2);
        }

    }

    class Sim_EX1_614 : SimTemplate //illidanstormrage
    {
        CardDB.Card d = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_614t);//flameofazzinoth
        //    beschwört jedes mal eine flamme von azzinoth (2/1), wenn ihr eine karte ausspielt.

        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (wasOwnCard == triggerEffectMinion.own)
            {
                p.callKid(d, triggerEffectMinion.zonepos, triggerEffectMinion.own);

            }
        }

    }

    class Sim_EX1_614t : SimTemplate //flameofazzinoth
    {

        //


    }

    class Sim_EX1_616 : SimTemplate //manawraith
    {

        //    alle diener kosten (1) mehr.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            p.managespenst++;
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            p.managespenst--;
        }

    }

    class Sim_EX1_617 : SimTemplate //deadlyshot
    {
        //    vernichtet einen zufälligen feindlichen diener.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            List<Minion> temp2 = (ownplay) ? new List<Minion>(p.enemyMinions) : new List<Minion>(p.ownMinions);
            temp2.Sort((a, b) => a.Angr.CompareTo(b.Angr));
            foreach (Minion enemy in temp2)
            {
                p.minionGetDestroyed(enemy);
                break;
            }
        }

    }

    class Sim_EX1_619 : SimTemplate //equality
    {

        //    setzt das leben aller diener auf 1.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            foreach (Minion m in p.ownMinions)
            {
                p.minionSetLifetoOne(m);
            }
            foreach (Minion m in p.enemyMinions)
            {
                p.minionSetLifetoOne(m);
            }
        }

    }

    class Sim_EX1_620 : SimTemplate //moltengiant
    {

        //    kostet (1) weniger für jeden schadenspunkt, den euer held erlitten hat.


    }

    class Sim_EX1_621 : SimTemplate //circleofhealing
    {

        //    stellt bei allen dienern #4 leben wieder her.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int heal = (ownplay) ? p.getSpellHeal(4) : p.getEnemySpellHeal(4);
            p.allMinionsGetDamage(-heal);
        }

    }

    class Sim_EX1_622 : SimTemplate //shadowworddeath
    {

        //    vernichtet einen diener mit mind. 5 angriff.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetDestroyed(target);
        }

    }

    class Sim_EX1_623 : SimTemplate //templeenforcer
    {

        //    kampfschrei:/ verleiht einem befreundeten diener +3 leben.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) p.minionGetBuffed(target, 0, 3);
        }

    }

    class Sim_EX1_624 : SimTemplate //holyfire
    {

        //    verursacht $5 schaden. stellt bei eurem helden #5 leben wieder her.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(5) : p.getEnemySpellDamageDamage(5);
            p.minionGetDamageOrHeal(target, dmg);
            int heal = (ownplay) ? p.getSpellHeal(5) : p.getEnemySpellHeal(5);

            p.minionGetDamageOrHeal(ownplay ? p.ownHero : p.enemyHero, -heal);
        }

    }

    class Sim_EX1_625 : SimTemplate //shadowform
    {

        //    eure heldenfähigkeit wird zu „verursacht 2 schaden“. wenn euer held bereits schattengestalt angenommen hat: 3 schaden.

        CardDB.Card mindspike = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_625t);
        CardDB.Card shatter = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_625t2);
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                if (p.ownHeroAblility.card.cardIDenum == CardDB.cardIDEnum.CS1h_001) // lesser heal becomes mind spike
                {
                    p.ownHeroAblility.card = mindspike;
                    p.ownAbilityReady = true;
                }
                else
                {
                    p.ownHeroAblility.card = shatter;  // mindspike becomes mind shatter
                    p.ownAbilityReady = true;
                }
            }
            else
            {
                p.enemyHeroAblility.card = p.enemyHeroAblility.card.cardIDenum == CardDB.cardIDEnum.CS1h_001 ? this.mindspike : this.shatter;
            }
        }

    }

    class Sim_EX1_625t : SimTemplate //mindspike
    {

        //    heldenfähigkeit/\nverursacht 2 schaden.


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = 2;
            if (ownplay)
            {
                if (p.doublepriest >= 1) dmg *= (2 * p.doublepriest);
            }
            else
            {
                if (p.enemydoublepriest >= 1) dmg *= (2 * p.enemydoublepriest);
            }
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_EX1_625t2 : SimTemplate //mindshatter
    {

        //    heldenfähigkeit/\nverursacht 3 schaden.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = 3;
            if (ownplay)
            {
                if (p.doublepriest >= 1) dmg *= (2 * p.doublepriest);
            }
            else
            {
                if (p.enemydoublepriest >= 1) dmg *= (2 * p.enemydoublepriest);
            }
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_EX1_626 : SimTemplate //massdispel
    {

        //    bringt alle feindlichen diener zum schweigen/. zieht eine karte.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.allMinionsGetSilenced(!ownplay);
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_EX1_finkle : SimTemplate //finkleeinhorn
    {

        //


    }

    class Sim_EX1_tk11 : SimTemplate //spiritwolf
    {

        //    spott/


    }

    class Sim_EX1_tk28 : SimTemplate //squirrel
    {

        //


    }

    class Sim_EX1_tk29 : SimTemplate //devilsaur
    {

        //    teufelssaurier


    }

    class Sim_EX1_tk33 : SimTemplate //inferno
    {

        //    heldenfähigkeit/\nbeschwört eine höllenbestie (6/6).
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_tk34);//infernal

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;
            p.callKid(kid, posi, ownplay);
        }

    }

    class Sim_EX1_tk34 : SimTemplate //infernal
    {

        //


    }

    class Sim_EX1_tk9 : SimTemplate //treant
    {

        //    ansturm/. vernichtet diesen diener am ende des zuges.


        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (turnEndOfOwner == triggerEffectMinion.own)
            {
                p.minionGetDestroyed(triggerEffectMinion);
            }
        }

    }

    class Sim_FP1_001 : SimTemplate //zombiechow
    {

        //    todesröcheln:/ stellt beim feindlichen helden 5 leben wieder her.
        public override void onDeathrattle(Playfield p, Minion m)
        {
            int heal = (m.own) ? p.getMinionHeal(5) : p.getEnemyMinionHeal(5);

            p.minionGetDamageOrHeal(m.own ? p.enemyHero : p.ownHero, -heal);
        }

    }

    class Sim_FP1_002 : SimTemplate //hauntedcreeper
    {
        CardDB.Card c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.FP1_002t);
        //    todesröcheln:/ ruft zwei spektrale spinnen (1/1) herbei.


        public override void onDeathrattle(Playfield p, Minion m)
        {

            p.callKid(c, m.zonepos - 1, m.own);
            p.callKid(c, m.zonepos - 1, m.own);
        }

    }

    class Sim_FP1_002t : SimTemplate //spectralspider
    {

        //


    }

    class Sim_FP1_003 : SimTemplate //echoingooze
    {

        //    kampfschrei:/ beschwört am ende des zuges eine exakte kopie dieses dieners.
        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (triggerEffectMinion.playedThisTurn && triggerEffectMinion.own == turnEndOfOwner)
            {
                p.callKid(triggerEffectMinion.handcard.card, triggerEffectMinion.zonepos, turnEndOfOwner);
                List<Minion> temp = (turnEndOfOwner) ? p.ownMinions : p.enemyMinions;
                foreach (Minion mnn in temp)
                {
                    if (mnn.name == CardDB.cardName.echoingooze && triggerEffectMinion.entitiyID != mnn.entitiyID)
                    {
                        mnn.setMinionTominion(triggerEffectMinion);
                        break;
                    }
                }
            }
        }

    }

    class Sim_FP1_004 : SimTemplate//Mad Scientist
    {
        //<deDE>TodesrÃ¶cheln: Legt ein Geheimnis aus Eurem Deck auf das Schlachtfeld.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            if (m.own)
            {
                if (p.ownHeroName == HeroEnum.mage)
                {
                    p.ownSecretsIDList.Add(CardDB.cardIDEnum.EX1_289);
                }
                if (p.ownHeroName == HeroEnum.hunter)
                {
                    p.ownSecretsIDList.Add(CardDB.cardIDEnum.EX1_554);
                }
                if (p.ownHeroName == HeroEnum.pala)
                {
                    p.ownSecretsIDList.Add(CardDB.cardIDEnum.EX1_130);
                }
            }
            else
            {
                if (p.enemyHeroName == HeroEnum.mage || p.enemyHeroName == HeroEnum.hunter || p.enemyHeroName == HeroEnum.pala)
                {
                    if (p.enemySecretCount <= 4)
                    {
                        p.enemySecretCount++;
                        SecretItem si = Probabilitymaker.Instance.getNewSecretGuessedItem(p.getNextEntity(), p.enemyHeroName);
                        if (p.enemyHeroName == HeroEnum.pala)
                        {
                            si.canBe_redemption = false;
                        }
                        if (Settings.Instance.useSecretsPlayArround)
                        {
                            p.enemySecretList.Add(si);
                        }
                    }
                }
            }

        }
    }


    class Sim_FP1_005 : SimTemplate //shadeofnaxxramas
    {

        //    verstohlenheit/. erhält zu beginn eures zuges +1/+1.

        public override void onTurnStartTrigger(Playfield p, Minion triggerEffectMinion, bool turnStartOfOwner)
        {
            if (triggerEffectMinion.own == turnStartOfOwner)
            {
                p.minionGetBuffed(triggerEffectMinion, 1, 1);
            }
        }

    }

    class Sim_FP1_006 : SimTemplate //deathcharger
    {

        //    ansturm. todesröcheln:/ fügt eurem helden 3 schaden zu.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.minionGetDamageOrHeal(m.own ? p.ownHero : p.enemyHero, 3);
        }

    }

    class Sim_FP1_007 : SimTemplate //nerubianegg
    {
        CardDB.Card c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.FP1_007t);//nerubian
        //    todesröcheln:/ ruft einen neruber (4/4) herbei.
        public override void onDeathrattle(Playfield p, Minion m)
        {

            p.callKid(c, m.zonepos - 1, m.own);
        }

    }

    class Sim_FP1_007t : SimTemplate//Nerubian
    {

    }

    class Sim_FP1_008 : SimTemplate //spectralknight
    {

        //    kann nicht als ziel von zaubern oder heldenfähigkeiten gewählt werden.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            own.cantBeTargetedBySpellsOrHeroPowers = true;
        }
    }

    class Sim_FP1_009 : SimTemplate //deathlord
    {
        CardDB.Card c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_017);//nerubian
        //    spott. todesröcheln:/ euer gegner legt einen diener aus seinem deck auf das schlachtfeld.
        public override void onDeathrattle(Playfield p, Minion m)
        {
            int place = (m.own) ? p.enemyMinions.Count : p.ownMinions.Count;
            p.callKid(c, place, !m.own);
        }

    }

    class Sim_FP1_010 : SimTemplate //maexxna
    {

        //    vernichtet jeden diener, der von diesem diener verletzt wurde.


    }

    class Sim_FP1_011 : SimTemplate //webspinner
    {

        //    todesröcheln:/ fügt eurer hand ein zufälliges wildtier hinzu.
        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.drawACard(CardDB.cardName.rivercrocolisk, m.own, true);
        }

    }

    class Sim_FP1_012 : SimTemplate //sludgebelcher
    {
        CardDB.Card c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.FP1_012t);
        //    spott.\ntodesröcheln:/ ruft einen schleim (1/2) mit spott/ herbei.
        public override void onDeathrattle(Playfield p, Minion m)
        {

            p.callKid(c, m.zonepos - 1, m.own);
        }

    }

    class Sim_FP1_012t : SimTemplate //slime
    {

        //    spott/


    }

    class Sim_FP1_013 : SimTemplate //kelthuzad
    {

        //    ruft am ende jedes zuges alle befreundeten diener herbei, die in diesem zug gestorben sind.
        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            foreach (GraveYardItem m in p.diedMinions.ToArray()) // toArray() because a knifejuggler could kill a minion due to the summon :D
            {
                if (triggerEffectMinion.own == m.own)
                {
                    CardDB.Card card = CardDB.Instance.getCardDataFromID(m.cardid);
                    p.callKid(card, p.ownMinions.Count, m.own);
                }
            }
        }

    }


    class Sim_FP1_014 : SimTemplate //stalagg
    {

        CardDB.Card thaddius = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.FP1_014t);
        //    todesröcheln:/ ruft thaddius herbei, wenn feugen in diesem duell bereits gestorben ist.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            if (p.feugenDead)
            {
                p.callKid(thaddius, m.zonepos - 1, m.own);
            }
        }

    }

    class Sim_FP1_014t : SimTemplate //thaddius
    {

        //


    }

    class Sim_FP1_015 : SimTemplate //feugen
    {

        //    todesröcheln:/ ruft thaddius herbei, wenn stalagg in diesem duell bereits gestorben ist.
        CardDB.Card thaddius = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.FP1_014t);
        //    todesröcheln:/ ruft thaddius herbei, wenn feugen in diesem duell bereits gestorben ist.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            if (p.stalaggDead)
            {
                p.callKid(thaddius, m.zonepos - 1, m.own);
            }
        }

    }

    class Sim_FP1_016 : SimTemplate //wailingsoul
    {

        //    kampfschrei:/ bringt eure anderen diener zum schweigen/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.ownMinions : p.enemyMinions;
            foreach (Minion m in temp)
            {
                p.minionGetSilenced(m);
            }
        }


    }

    class Sim_FP1_017 : SimTemplate //nerubarweblord
    {

        //    diener mit kampfschrei/ kosten (2) mehr.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            p.nerubarweblord++;
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            p.nerubarweblord--;
        }


    }

    class Sim_FP1_018 : SimTemplate //duplicate
    {
        //todo secret
        //    geheimnis:/ wenn ein befreundeter diener stirbt, erhaltet ihr 2 kopien dieses dieners auf eure hand.

        public override void onSecretPlay(Playfield p, bool ownplay, int number)
        {
            if (ownplay)
            {
                p.drawACard(p.revivingOwnMinion, ownplay, true);
                p.drawACard(p.revivingOwnMinion, ownplay, true);
            }
            else
            {
                p.drawACard(p.revivingEnemyMinion, ownplay, true);
                p.drawACard(p.revivingEnemyMinion, ownplay, true);
            }

        }

    }


    class Sim_FP1_019 : SimTemplate //poisonseeds
    {
        CardDB.Card d = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_158t);
        //    vernichtet alle diener und ruft für jeden einen treant (2/2) als ersatz herbei.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int ownanz = p.ownMinions.Count;
            int enemanz = p.enemyMinions.Count;
            p.allMinionsGetDestroyed();
            for (int i = 0; i < ownanz; i++)
            {
                p.callKid(d, 1, true);
            }
            for (int i = 0; i < enemanz; i++)
            {
                p.callKid(d, 1, false);
            }
        }

    }

    class Sim_FP1_019t : SimTemplate //treant
    {

        //


    }

    class Sim_FP1_020 : SimTemplate //avenge
    {
        //todo secret
        //    geheimnis:/ wenn einer eurer diener stirbt, erhält ein zufälliger befreundeter diener +3/+2.

        public override void onSecretPlay(Playfield p, bool ownplay, int number)
        {
            List<Minion> temp = new List<Minion>();


            if (ownplay)
            {
                List<Minion> temp2 = new List<Minion>(p.ownMinions);
                temp2.Sort((a, b) => -a.Angr.CompareTo(b.Angr));
                temp.AddRange(temp2);
            }
            else
            {
                List<Minion> temp2 = new List<Minion>(p.enemyMinions);
                temp2.Sort((a, b) => a.Angr.CompareTo(b.Angr));
                temp.AddRange(temp2);
            }

            if (temp.Count >= 1)
            {
                if (ownplay)
                {
                    Minion trgt = temp[0];
                    if (temp.Count >= 2 && trgt.taunt && !temp[1].taunt) trgt = temp[1];
                    p.minionGetBuffed(trgt, 3, 2);
                }
                else
                {

                    Minion trgt = temp[0];
                    if (temp.Count >= 2 && !trgt.taunt && temp[1].taunt) trgt = temp[1];
                    p.minionGetBuffed(trgt, 3, 2);
                }
            }


        }
    }


    class Sim_FP1_021 : SimTemplate//Death's Bite
    {
        CardDB.Card w = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.FP1_021);

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(w, ownplay);
        }

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.allMinionsGetDamage(1);
        }

    }

    class Sim_FP1_022 : SimTemplate //voidcaller
    {
        CardDB.Card c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_301);//felguard
        //    todesröcheln:/ legt einen zufälligen dämon aus eurer hand auf das schlachtfeld.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            if (m.own)
            {
                List<Handmanager.Handcard> temp = new List<Handmanager.Handcard>();
                foreach (Handmanager.Handcard hc in p.owncards)
                {
                    if ((TAG_RACE)hc.card.race == TAG_RACE.DEMON)
                    {
                        temp.Add(hc);
                    }
                }

                temp.Sort((x, y) => x.card.Attack.CompareTo(y.card.Attack));

                foreach (Handmanager.Handcard mnn in temp)
                {
                    p.callKid(mnn.card, p.ownMinions.Count, true);
                    p.removeCard(mnn);
                    break;
                }

            }
            else
            {
                if (p.enemyAnzCards >= 1)
                {
                    p.callKid(c, p.enemyMinions.Count, false);
                }
            }
        }

    }

    class Sim_FP1_023 : SimTemplate// dark cultist
    {
        //todo list
        public override void onDeathrattle(Playfield p, Minion m)
        {
            List<Minion> temp = new List<Minion>();

            if (m.own)
            {
                List<Minion> temp2 = new List<Minion>(p.ownMinions);
                temp2.Sort((a, b) => -a.Angr.CompareTo(b.Angr));
                temp.AddRange(temp2);
            }
            else
            {
                List<Minion> temp2 = new List<Minion>(p.enemyMinions);
                temp2.Sort((a, b) => a.Angr.CompareTo(b.Angr));
                temp.AddRange(temp2);
            }

            if (temp.Count >= 1)
            {
                if (m.own)
                {
                    Minion target = temp[0];
                    if (temp.Count >= 2 && target.taunt && !temp[1].taunt) target = temp[1];
                    p.minionGetBuffed(target, 0, 3);
                }
                else
                {

                    Minion target = temp[0];
                    if (temp.Count >= 2 && !target.taunt && temp[1].taunt) target = temp[1];
                    p.minionGetBuffed(target, 0, 3);
                }
            }

        }



    }

    class Sim_FP1_024 : SimTemplate //unstableghoul
    {

        //    spott/. todesröcheln:/ fügt allen dienern 1 schaden zu.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.allMinionsGetDamage(1);
        }


    }

    class Sim_FP1_025 : SimTemplate //reincarnate
    {

        //    vernichtet einen diener und bringt ihn dann mit vollem leben wieder auf das schlachtfeld zurück.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            bool own = target.own;
            int place = target.zonepos;
            CardDB.Card d = target.handcard.card;
            p.minionGetDestroyed(target);
            p.callKid(d, place, own);
        }

    }

    class Sim_FP1_026 : SimTemplate //anubarambusher
    {

        //    todesröcheln:/ lasst einen zufälligen befreundeten diener auf eure hand zurückkehren.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            List<Minion> temp = new List<Minion>();

            if (m.own)
            {
                List<Minion> temp2 = new List<Minion>(p.ownMinions);
                temp2.Sort((a, b) => -a.Angr.CompareTo(b.Angr));
                temp.AddRange(temp2);
            }
            else
            {
                List<Minion> temp2 = new List<Minion>(p.enemyMinions);
                temp2.Sort((a, b) => a.Angr.CompareTo(b.Angr));
                temp.AddRange(temp2);
            }

            if (temp.Count >= 1)
            {
                if (m.own)
                {
                    Minion target = new Minion();
                    target = temp[0];
                    if (temp.Count >= 2 && !target.taunt && temp[1].taunt) target = temp[1];
                    p.minionReturnToHand(target, m.own, 0);
                }
                else
                {
                    Minion target = new Minion();

                    target = temp[0];
                    if (temp.Count >= 2 && target.taunt && !temp[1].taunt) target = temp[1];
                    p.minionReturnToHand(target, m.own, 0);
                }
            }
        }

    }

    class Sim_FP1_027 : SimTemplate //stoneskingargoyle
    {

        //    stellt zu beginn eures zuges das volle leben dieses dieners wieder her.

        public override void onTurnStartTrigger(Playfield p, Minion triggerEffectMinion, bool turnStartOfOwner)
        {
            if (triggerEffectMinion.own == turnStartOfOwner)
            {
                int heal = (triggerEffectMinion.own) ? p.getMinionHeal(triggerEffectMinion.maxHp - triggerEffectMinion.Hp) : p.getEnemyMinionHeal(triggerEffectMinion.maxHp - triggerEffectMinion.Hp);
                p.minionGetDamageOrHeal(triggerEffectMinion, -heal);
            }
        }

    }

    class Sim_FP1_028 : SimTemplate //undertaker
    {

        //    erhält jedes mal +1/+1, wenn ihr einen diener mit todesröcheln/ herbeiruft.

        public override void onMinionIsSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            if (triggerEffectMinion.own == summonedMinion.own)
            {
                if (summonedMinion.handcard.card.deathrattle) p.minionGetBuffed(triggerEffectMinion, 1, 1);
            }
        }

    }

    class Sim_FP1_029 : SimTemplate //dancingswords
    {

        //    todesröcheln:/ euer gegner zieht eine karte.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.drawACard(CardDB.cardName.unknown, !m.own);
        }

    }

    class Sim_FP1_030 : SimTemplate //loatheb
    {

        //    kampfschrei:/ im nächsten zug kosten zauber für euren gegner (5) mehr.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.loatheb = true;
        }



    }

    class Sim_FP1_031 : SimTemplate //baronrivendare
    {

        //    die todesröcheln/-effekte eurer diener werden 2-mal ausgelöst.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own) p.ownBaronRivendare++;
            else p.enemyBaronRivendare++;
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            if (m.own)
            {
                p.ownBaronRivendare--;
            }
            else
            {
                p.enemyBaronRivendare--;
            }
        }

    }

    class Sim_GAME_002 : SimTemplate //avatarofthecoin
    {

        //    i&gt;ihr habt den münzwurf verloren, aber einen freund gewonnen./i&gt;


    }

    class Sim_GAME_005 : SimTemplate //thecoin
    {

        //    erhaltet 1 manakristall nur für diesen zug.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                p.mana++;
            }
            else
            {
                p.mana++;
            }
        }

    }

    class Sim_GAME_006 : SimTemplate //noooooooooooo
    {

        //    leider wurde die karte, die ihr einst besaßt, entfernt. aber nehmt doch diese hier!


    }

    class Sim_GVG_001 : SimTemplate //Flamecannon
    {

        //    Deal $4 damage to a random enemy minion.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            // optimistic

            List<Minion> temp = (ownplay) ? p.enemyMinions : p.ownMinions;
            int times = (ownplay) ? p.getSpellDamageDamage(4) : p.getEnemySpellDamageDamage(4);

            if (temp.Count >= 1)
            {
                //search Minion with lowest hp
                Minion enemy = temp[0];
                int minhp = 10000;
                foreach (Minion m in temp)
                {
                    if (m.Hp >= times + 1 && minhp > m.Hp)
                    {
                        enemy = m;
                        minhp = m.Hp;
                    }
                }

                p.minionGetDamageOrHeal(enemy, times);

            }
        }

    }


    class Sim_GVG_002 : SimTemplate //Snowchugger
    {

        //    Freeze any character damaged by this minion.

    }


    class Sim_GVG_003 : SimTemplate //Unstable Portal
    {

        //    Add a random minion to your hand. It costs (3) less.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, ownplay, true);
        }

    }


    class Sim_GVG_004 : SimTemplate //Goblin Blastmage
    {

        //    Battlecry: If you have a Mech, deal 4 damage randomly split among all enemies.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            // optimistic
            bool ownplay = own.own;
            List<Minion> temp1 = (ownplay) ? p.ownMinions : p.enemyMinions;
            bool haveAMech = false;
            foreach (Minion m in temp1)
            {
                if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL) haveAMech = true;
            }
            if (!haveAMech) return;

            int i = 0;
            List<Minion> temp = (ownplay) ? p.enemyMinions : p.ownMinions;
            int times = (ownplay) ? p.getSpellDamageDamage(4) : p.getEnemySpellDamageDamage(4);

            if ((ownplay && p.enemyHero.Hp <= times) || (!ownplay && p.ownHero.Hp <= times))
            {
                if (ownplay) p.minionGetDamageOrHeal(p.enemyHero, p.enemyHero.Hp - 1);
                else p.minionGetDamageOrHeal(p.ownHero, p.ownHero.Hp - 1);
            }
            else
            {
                while (i < times)
                {
                    if (temp.Count >= 1)
                    {
                        //search Minion with lowest hp
                        Minion enemy = temp[0];
                        int minhp = 10000;
                        bool found = false;
                        foreach (Minion m in temp)
                        {
                            if (m.name == CardDB.cardName.nerubianegg && enemy.Hp >= 2) continue; //dont attack nerubianegg!

                            if (m.Hp >= 2 && minhp > m.Hp)
                            {
                                enemy = m;
                                minhp = m.Hp;
                                found = true;
                            }
                        }

                        if (found)
                        {
                            p.minionGetDamageOrHeal(enemy, 1);
                        }
                        else
                        {
                            p.minionGetDamageOrHeal(ownplay ? p.enemyHero : p.ownHero, 1);
                        }

                    }
                    else
                    {
                        p.minionGetDamageOrHeal(ownplay ? p.enemyHero : p.ownHero, 1);
                    }

                    i++;
                }
            }
        }


    }


    class Sim_GVG_005 : SimTemplate //Echo of Medivh
    {

        //    Put a copy of each friendly minion into your hand.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            // optimistic
            List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;

            foreach (Minion m in temp)
            {
                p.drawACard(m.handcard.card.name, ownplay, true);
            }

        }


    }


    class Sim_GVG_006 : SimTemplate //Mechwarper
    {

        //    Your Mechs cost (1) less.

        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnMechwarper++;
            }
            else
            {
                p.anzEnemyMechwarper++;

            }

        }

        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnMechwarper--;
            }
            else
            {
                p.anzEnemyMechwarper--;
            }
        }


    }


    class Sim_GVG_007 : SimTemplate //Flame Leviathan
    {

        //    When you draw this, deal 2 damage to all characters.
        // todo simulate this (but not if we dont know our deck :D)

    }


    class Sim_GVG_008 : SimTemplate //Lightbomb
    {

        //    Deal damage to each minion equal to its Attack.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            foreach (Minion m in p.ownMinions)
            {
                p.minionGetDamageOrHeal(m, m.Angr, true);
            }

            foreach (Minion m in p.enemyMinions)
            {
                p.minionGetDamageOrHeal(m, m.Angr, true);
            }
        }


    }


    class Sim_GVG_009 : SimTemplate //Shadowbomber
    {

        //   Battlecry: Deal 3 damage to each hero.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = 3;
            p.minionGetDamageOrHeal(p.enemyHero, dmg, true);
            p.minionGetDamageOrHeal(p.ownHero, dmg, true);
        }


    }


    class Sim_GVG_010 : SimTemplate //Velen's Chosen
    {

        //    Give a minion +2/+4 and Spell Damage +1.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 2, 4);
            target.spellpower++;
            if (target.own) p.spellpower++;
            else p.enemyspellpower++;

        }


    }


    class Sim_GVG_011 : SimTemplate //Shrinkmeister
    {

        //    Your Mechs cost (1) less.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null)
            {
                p.minionGetTempBuff(target, -2, 0);
            }
        }


    }


    class Sim_GVG_012 : SimTemplate //Light of the Naaru
    {

        //    Restore #3 Health. If the target is still damaged, summon a Lightwarden.

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_001);

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int heal = (ownplay) ? p.getSpellHeal(3) : p.getEnemySpellHeal(3);
            p.minionGetDamageOrHeal(target, -heal);
            if (target.Hp < target.maxHp)
            {
                int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;
                p.callKid(kid, posi, ownplay);
            }
        }


    }


    class Sim_GVG_013 : SimTemplate //Cogmaster
    {

        //    Has +2 Attack while you have a Mech.

        public override void onMinionIsSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            if ((TAG_RACE)summonedMinion.handcard.card.race == TAG_RACE.MECHANICAL)
            {
                List<Minion> temp = (triggerEffectMinion.own) ? p.ownMinions : p.enemyMinions;

                foreach (Minion m in temp)
                {
                    //if we have allready a mechanical, we are buffed
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL) return;
                }

                //we had no mechanical, but now!
                p.minionGetBuffed(triggerEffectMinion, 2, 0);
            }
        }


        //on minon died is handled in playfield


    }


    class Sim_GVG_014 : SimTemplate //Vol'jin
    {
        //todo: what happens if the target is damaged?
        //Battlecry: Swap Health with another minion.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target == null) return;

            int volMHp = own.maxHp;
            int tarMHp = target.maxHp;


            target.maxHp = volMHp;
            if (tarMHp < volMHp)//minion has lower maxHp as his card -> heal his hp
            {
                target.Hp += volMHp - tarMHp; //heal minion
            }
            if (target.Hp > target.maxHp)
            {
                target.Hp = target.maxHp;
            }

            own.maxHp = tarMHp;
            if (volMHp < tarMHp)//minion has lower maxHp as his card -> heal his hp
            {
                own.Hp += tarMHp - volMHp; //heal minion
            }
            if (own.Hp > own.maxHp)
            {
                own.Hp = own.maxHp;
            }



        }

    }


    class Sim_GVG_015
        : SimTemplate //Darkbomb
    {

        //   Deal $3 damage.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);
            p.minionGetDamageOrHeal(target, dmg);
        }


    }


    class Sim_GVG_016 : SimTemplate //Fel Reaver
    {

        //    Whenever your opponent plays a card, discard the top 3 cards of your deck.

        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (wasOwnCard == triggerEffectMinion.own) return; //owner of card = owner of minion -> no effect

            if (triggerEffectMinion.own)
            {
                p.ownDeckSize = Math.Max(0, p.ownDeckSize - 3);
            }
            else
            {
                p.enemyDeckSize = Math.Max(0, p.enemyDeckSize - 3);
            }
        }


    }


    class Sim_GVG_017 : SimTemplate //Call Pet
    {

        //    Draw a card. If it's a Beast, it costs (4) less.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, ownplay);
            p.evaluatePenality += (ownplay) ? -10 : 10;
        }


    }


    class Sim_GVG_018 : SimTemplate //Mistress of Pain
    {

        //    Whenever this minion deals damage, restore that much Health to your hero.

        //done in triggerAMinionDealedDmg (Playfield) (cause its the only minion with such an trigger)


    }


    class Sim_GVG_019 : SimTemplate //Demonheart
    {

        //    Deal $5 damage to a minion.  If it's a friendly Demon, give it +5/+5 instead.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (target.own == ownplay && (TAG_RACE)target.handcard.card.race == TAG_RACE.DEMON)
            {
                //give it +5/+5
                p.minionGetBuffed(target, 5, 5);
            }
            else
            {
                int dmg = (ownplay) ? p.getSpellDamageDamage(5) : p.getEnemySpellDamageDamage(5);

                p.minionGetDamageOrHeal(target, dmg);
            }
        }


    }


    class Sim_GVG_020 : SimTemplate //Fel Cannon
    {

        //    At the end of your turn, deal 2 damage to a non-Mech minion.

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            //count non-mechs
            int ownNonMechs = 0;
            Minion ownTemp = null;
            foreach (Minion m in p.ownMinions)
            {
                if ((TAG_RACE)m.handcard.card.race != TAG_RACE.MECHANICAL)
                {
                    if (ownTemp == null) ownTemp = m;
                    ownNonMechs++;
                }
            }

            int enemyNonMechs = 0;
            Minion enemyTemp = null;
            foreach (Minion m in p.enemyMinions)
            {
                if ((TAG_RACE)m.handcard.card.race != TAG_RACE.MECHANICAL)
                {
                    if (enemyTemp == null) enemyTemp = m;
                    enemyNonMechs++;
                }
            }

            // dmg own minion if we have more than the enemy, in the other case dmg him!
            if (ownNonMechs >= 1 && enemyNonMechs >= 1)
            {
                if (ownNonMechs >= enemyNonMechs)
                {
                    p.minionGetDamageOrHeal(ownTemp, 2, true);
                    return;
                }
                p.minionGetDamageOrHeal(enemyTemp, 2, true);
                return;
            }

            if (ownNonMechs >= 1)
            {
                p.minionGetDamageOrHeal(ownTemp, 2, true);
                return;
            }


            if (enemyNonMechs >= 1)
            {
                p.minionGetDamageOrHeal(enemyTemp, 2, true);
                return;
            }
        }

    }


    class Sim_GVG_021 : SimTemplate //Mal'Ganis
    {

        //    Your other Demons have +2/+2.Your hero is Immune;

        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnMalGanis++;
                p.ownHero.immune = true;
                foreach (Minion m in p.ownMinions)
                {
                    if (own.entitiyID != m.entitiyID && (TAG_RACE)m.handcard.card.race == TAG_RACE.DEMON) p.minionGetBuffed(m, 2, 2);
                }
            }
            else
            {
                p.anzEnemyMalGanis++;
                p.enemyHero.immune = true;
                foreach (Minion m in p.enemyMinions)
                {
                    if (own.entitiyID != m.entitiyID && (TAG_RACE)m.handcard.card.race == TAG_RACE.DEMON) p.minionGetBuffed(m, 2, 2);
                }
            }

        }

        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnMalGanis--;
                p.ownHero.immune = false;
                foreach (Minion m in p.ownMinions)
                {
                    if (own.entitiyID != m.entitiyID && (TAG_RACE)m.handcard.card.race == TAG_RACE.DEMON) p.minionGetBuffed(m, -2, -2);
                }
            }
            else
            {
                p.anzEnemyMalGanis--;
                p.enemyHero.immune = false;
                foreach (Minion m in p.enemyMinions)
                {
                    if (own.entitiyID != m.entitiyID && (TAG_RACE)m.handcard.card.race == TAG_RACE.DEMON) p.minionGetBuffed(m, -2, -2);
                }
            }
        }


    }


    class Sim_GVG_022 : SimTemplate //Tinker's Sharpsword Oil
    {

        //    Give your weapon +3 Attack. Combo: Give a random friendly minion +3 Attack.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                if (p.ownWeaponDurability >= 1)
                {
                    p.ownWeaponAttack += 3;
                    p.minionGetBuffed(p.ownHero, 3, 0);
                }
                if (p.cardsPlayedThisTurn >= 1)
                {
                    p.minionGetBuffed(p.searchRandomMinion(p.ownMinions, Playfield.searchmode.searchLowestAttack), 3, 0);
                }
            }
            else
            {
                if (p.enemyWeaponDurability >= 1)
                {
                    p.enemyWeaponAttack += 3;
                    p.minionGetBuffed(p.enemyHero, 3, 0);
                }
                if (p.cardsPlayedThisTurn >= 1)
                {
                    p.minionGetBuffed(p.searchRandomMinion(p.enemyMinions, Playfield.searchmode.searchLowestAttack), 3, 0);
                }
            }
        }


    }


    class Sim_GVG_023 : SimTemplate //Goblin Auto-Barber
    {

        //    Battlecry: Give your weapon +1 Attack.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                if (p.ownWeaponDurability >= 1)
                {
                    p.ownWeaponAttack += 1;
                    p.minionGetBuffed(p.ownHero, 1, 0);
                }

            }
            else
            {
                if (p.enemyWeaponDurability >= 1)
                {
                    p.enemyWeaponAttack += 1;
                    p.minionGetBuffed(p.enemyHero, 1, 0);
                }

            }
        }


    }


    class Sim_GVG_024 : SimTemplate //Cogmaster's Wrench
    {

        //    Has +2 Attack while you have a Mech.

        CardDB.Card w = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.GVG_024);
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(w, ownplay);

            List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;
            bool hasmech = false;
            foreach (Minion m in temp)
            {
                //if we have allready a mechanical, we are buffed
                if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL) hasmech = true;
            }
            if (hasmech)
            {
                if (ownplay)
                {
                    p.ownWeaponAttack += 2;
                    p.minionGetBuffed(p.ownHero, 2, 0);
                }
                else
                {
                    p.enemyWeaponAttack += 2;
                    p.minionGetBuffed(p.enemyHero, 2, 0);
                }
            }


        }

        public override void onMinionIsSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            if ((TAG_RACE)summonedMinion.handcard.card.race == TAG_RACE.MECHANICAL)
            {
                List<Minion> temp = (triggerEffectMinion.own) ? p.ownMinions : p.enemyMinions;

                foreach (Minion m in temp)
                {
                    //if we have allready a mechanical, we are buffed
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL) return;
                }

                //we had no mechanical, but now!
                if (triggerEffectMinion.own)
                {
                    p.ownWeaponAttack += 2;
                    p.minionGetBuffed(p.ownHero, 2, 0);
                }
                else
                {
                    p.enemyWeaponAttack += 2;
                    p.minionGetBuffed(p.enemyHero, 2, 0);
                }
            }
        }


        //on minon died is handled in playfield


    }


    class Sim_GVG_025 : SimTemplate //One-eyed Cheat
    {

        //    Whenever you summon a Pirate, gain Stealth.

        public override void onMinionIsSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            if ((TAG_RACE)summonedMinion.handcard.card.race == TAG_RACE.PIRATE)
            {
                triggerEffectMinion.stealth = true;
            }
        }


    }


    class Sim_GVG_026 : SimTemplate //Feign Death
    {

        //   Trigger all Deathrattles on your minions.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                p.doDeathrattles(new List<Minion>(p.ownMinions));
            }
            else
            {
                p.doDeathrattles(new List<Minion>(p.enemyMinions));
            }
        }


    }


    class Sim_GVG_027 : SimTemplate //Iron Sensei
    {

        //   At the end of your turn, give another friendly Mech +2/+2.

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (turnEndOfOwner == triggerEffectMinion.own)
            {
                List<Minion> temp = (turnEndOfOwner) ? p.ownMinions : p.enemyMinions;
                p.minionGetBuffed(p.searchRandomMinion(temp, Playfield.searchmode.searchHighestAttack), 2, 2);
            }
        }


    }


    class Sim_GVG_028 : SimTemplate //Trade Prince Gallywix
    {

        //    Whenever your opponent casts a spell, gain a copy of it and give them a Coin.

        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (c.type == CardDB.cardtype.SPELL && c.name != CardDB.cardName.gallywixscoin && wasOwnCard != triggerEffectMinion.own)
            {
                p.drawACard(c.cardIDenum, triggerEffectMinion.own, true);
                p.drawACard(CardDB.cardName.gallywixscoin, wasOwnCard, true);
            }
        }


    }


    class Sim_GVG_028t : SimTemplate //Gallywix's Coin
    {

        //    Gain 1 Mana Crystal this turn only.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.mana++;
        }


    }


    class Sim_GVG_029 : SimTemplate //Ancestor's Call
    {

        //    Put a random minion from each player's hand into the battlefield.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            Handmanager.Handcard c = null;
            int sum = 10000;
            foreach (Handmanager.Handcard hc in p.owncards)
            {
                if (hc.card.type == CardDB.cardtype.MOB)
                {
                    int s = hc.card.Health + hc.card.Attack + ((hc.card.tank) ? 1 : 0) + ((hc.card.Shield) ? 1 : 0);
                    if (s < sum)
                    {
                        c = hc;
                        sum = s;
                    }
                }
            }
            if (sum < 9999)
            {
                p.callKid(c.card, p.ownMinions.Count, true);
                p.removeCard(c);
                p.triggerCardsChanged(true);
            }


            if (p.enemyAnzCards >= 2)
            {
                p.callKid(c.card, p.enemyMinions.Count, false);
                p.enemyAnzCards--;
                p.triggerCardsChanged(false);
            }
        }


    }


    class Sim_GVG_030 : SimTemplate //Anodized Robo Cub
    {

        //    Taunt. Choose One - +1 Attack; or +1 Health.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (choice == 1)
            {
                p.minionGetBuffed(own, 1, 0);
            }
            if (choice == 2)
            {
                p.minionGetBuffed(own, 0, 1);
            }
        }


    }


    class Sim_GVG_030a : SimTemplate //Attack Mode
    {

        //    +1 Attack.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.minionGetBuffed(own, 1, 0);
        }



    }

    class Sim_GVG_030b : SimTemplate //Tank Mode
    {

        //   +1 Health.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.minionGetBuffed(own, 0, 1);
        }


    }

    class Sim_GVG_031 : SimTemplate //Recycle
    {

        //   Shuffle an enemy minion into your opponent's deck.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            bool own = ownplay;
            List<Minion> temp = (own) ? p.ownMinions : p.enemyMinions;
            target.handcard.card.sim_card.onAuraEnds(p, target);
            temp.Remove(target);

            if (own)
            {
                p.tempTrigger.ownMinionsChanged = true;
                p.ownDeckSize++;
            }
            else
            {
                p.tempTrigger.enemyMininsChanged = true;
                p.enemyDeckSize++;
            }
        }


    }


    class Sim_GVG_032 : SimTemplate //Grove Tender
    {

        //    Choose One - Give each player a Mana Crystal; or Each player draws a card.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (choice == 1)
            {
                p.mana++;
                p.ownMaxMana++;
                p.enemyMaxMana++;
            }

            if (choice == 2)
            {
                p.drawACard(CardDB.cardName.unknown, true);
                p.drawACard(CardDB.cardName.unknown, false);
            }
        }


    }


    class Sim_GVG_032a : SimTemplate //Grove Tender
    {

        //   Give each player a Mana Crystal.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {

            p.mana++;
            p.ownMaxMana++;
            p.enemyMaxMana++;

        }


    }


    class Sim_GVG_032b : SimTemplate //Grove Tender
    {

        //    Give each player a Mana Crystal.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {

            p.drawACard(CardDB.cardName.unknown, true);
            p.drawACard(CardDB.cardName.unknown, false);

        }


    }


    class Sim_GVG_033 : SimTemplate //Tree of Life
    {

        //    Restore all characters to full Health.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            foreach (Minion m in p.ownMinions)
            {
                int heal = (ownplay) ? p.getSpellHeal(m.maxHp) : p.getEnemySpellHeal(m.maxHp);
                p.minionGetDamageOrHeal(m, -heal);
            }
            foreach (Minion m in p.enemyMinions)
            {
                int heal = (ownplay) ? p.getSpellHeal(m.maxHp) : p.getEnemySpellHeal(m.maxHp);
                p.minionGetDamageOrHeal(m, -heal);
            }

            int heal2 = (ownplay) ? p.getSpellHeal(p.enemyHero.maxHp) : p.getEnemySpellHeal(p.enemyHero.maxHp);
            p.minionGetDamageOrHeal(p.enemyHero, -heal2);

            heal2 = (ownplay) ? p.getSpellHeal(p.ownHero.maxHp) : p.getEnemySpellHeal(p.ownHero.maxHp);
            p.minionGetDamageOrHeal(p.ownHero, -heal2);
        }


    }


    class Sim_GVG_034 : SimTemplate //Mech-Bear-Cat
    {

        //    Whenever this minion takes damage, add a Spare Part card to your hand.

        //handled in triggerAMinionGotDmg() (to few minions have this to do it here)

    }


    class Sim_GVG_035 : SimTemplate //Malorne
    {

        //    Deathrattle:&lt;/b&gt; Shuffle this minion into your deck.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            if (m.own)
            {
                p.ownDeckSize++;
            }
            else
            {
                p.enemyDeckSize++;
            }
        }


    }


    class Sim_GVG_036 : SimTemplate //Powermace
    {
        CardDB.Card w = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.GVG_036);

        //    &gt;Deathrattle&lt;/b&gt;: Give a random friendly Mech +2/+2.</Tag>
        // DR handled in lowerWeaponDurability()

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(w, ownplay);
        }


    }


    class Sim_GVG_037 : SimTemplate //Whirling Zap-o-matic
    {

        //    Windfury



    }


    class Sim_GVG_038 : SimTemplate //Crackle
    {

        //    Deal $3-$6 damage.Overload: (1)

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(4) : p.getEnemySpellDamageDamage(4);
            p.minionGetDamageOrHeal(target, dmg);
            if (ownplay) p.ueberladung += 1;
        }


    }


    class Sim_GVG_039 : SimTemplate //Vitality Totem
    {

        //    At the end of your turn, restore 4 Health to your hero.

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (triggerEffectMinion.own == turnEndOfOwner)
            {

                if (triggerEffectMinion.own)
                {
                    int heal = p.getMinionHeal(4);
                    p.minionGetDamageOrHeal(p.ownHero, -heal, true);
                }
                else
                {
                    int heal = p.getEnemyMinionHeal(4);
                    p.minionGetDamageOrHeal(p.enemyHero, -heal, true);
                }

            }
        }


    }


    class Sim_GVG_040 : SimTemplate //Siltfin Spiritwalker
    {

        //    Whenever another friendly Murloc dies, draw a card. Overload: (1)

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own) p.ueberladung++;
        }
        // death-effect is handled in playfield -> triggerAMinionDied

    }


    class Sim_GVG_041 : SimTemplate //Dark Wispers
    {

        //   Choose One - Summon 5 Wisps; or Give a minion +5/+5 and Taunt.

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_231);
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (choice == 1)
            {
                for (int i = 0; i < 5; i++)
                {
                    int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;
                    p.callKid(kid, posi, ownplay);
                }
            }
            if (choice == 2)
            {
                p.minionGetBuffed(target, 5, 5);
                target.taunt = true;
            }
        }


    }


    class Sim_GVG_041a : SimTemplate //Dark Wispers
    {

        //   Summon 5 Wisps;

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_231);
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            for (int i = 0; i < 5; i++)
            {
                int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;
                p.callKid(kid, posi, ownplay);
            }

        }


    }


    class Sim_GVG_041b : SimTemplate //Dark Wispers
    {

        //   Give a minion +5/+5 and Taunt&lt.


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 5, 5);
            target.taunt = true;
        }


    }


    class Sim_GVG_042 : SimTemplate //Neptulon
    {

        // Battlecry: Add 4 random Murlocs to your hand. Overload: (3)
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_168);

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own) p.ueberladung += 3;
            for (int i = 0; i < 4; i++)
            {
                int posi = (own.own) ? p.ownMinions.Count : p.enemyMinions.Count;
                p.callKid(kid, posi, own.own);
            }
        }


    }


    class Sim_GVG_043 : SimTemplate //Glaivezooka
    {

        //   Battlecry: Give a random friendly minion +1 Attack.

        CardDB.Card w = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.GVG_043);
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(w, ownplay);
            List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;
            p.minionGetBuffed(p.searchRandomMinion(temp, Playfield.searchmode.searchLowestAttack), 1, 0);

        }

    }


    class Sim_GVG_044 : SimTemplate //Spider Tank
    {

        //   just a spider tank :D




    }


    class Sim_GVG_045 : SimTemplate //Imp-losion
    {

        //   Deal $2-$4 damage to a minion. Summon a 1/1 Imp for each damage dealt.

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.GVG_045t);

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            p.minionGetDamageOrHeal(target, dmg);

            int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;
            p.callKid(kid, posi, ownplay);
            posi++;
            p.callKid(kid, posi, ownplay);
        }


    }


    class Sim_GVG_045t : SimTemplate //Imp
    {

        //   just an imp




    }


    class Sim_GVG_046 : SimTemplate //King of Beasts
    {

        //   Taunt Battlecry: Gain +1 Attack for each other Beast you have.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {

            int bonusattack = 0;
            List<Minion> temp = (own.own) ? p.ownMinions : p.enemyMinions;
            foreach (Minion m in temp)
            {
                if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PET) bonusattack++;
            }
            p.minionGetBuffed(own, bonusattack, 0);

        }


    }


    class Sim_GVG_047 : SimTemplate //Sabotage
    {

        //   Destroy a random enemy minion. Combo: And your opponent's weapon.


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            List<Minion> temp = (ownplay) ? p.enemyMinions : p.ownMinions;
            p.minionGetDestroyed(p.searchRandomMinion(temp, Playfield.searchmode.searchLowestHP));
            if (p.cardsPlayedThisTurn >= 1) p.lowerWeaponDurability(1000, !ownplay);
        }


    }


    class Sim_GVG_048 : SimTemplate //Metaltooth Leaper
    {

        //   Battlecry: Give your other Mechs +2 Attack.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.enemyMinions : p.ownMinions;
            foreach (Minion m in temp)
            {
                if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL)
                {
                    p.minionGetBuffed(m, 2, 0);
                }
            }

        }



    }


    class Sim_GVG_049 : SimTemplate //Gahz'rilla
    {

        //   Whenever this minion takes damage, double its Attack.




    }


    class Sim_GVG_050 : SimTemplate //Bouncing Blade
    {

        //   Deal $1 damage to a random minion. Repeat until a minion dies.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(1) : p.getEnemySpellDamageDamage(1);

            int minHp = 100000;
            foreach (Minion m in p.ownMinions)
            {
                if (m.Hp < minHp) minHp = m.Hp;
            }
            foreach (Minion m in p.enemyMinions)
            {
                if (m.Hp < minHp) minHp = m.Hp;
            }

            int dmgdone = (int)Math.Ceiling((double)minHp / (double)dmg) * dmg;

            p.allMinionsGetDamage(dmgdone);
        }


    }


    class Sim_GVG_051 : SimTemplate //Warbot
    {

        //   Enrage:&lt;/b&gt; +1 Attack.

        public override void onEnrageStart(Playfield p, Minion m)
        {
            p.minionGetBuffed(m, 1, 0);
        }

        public override void onEnrageStop(Playfield p, Minion m)
        {
            p.minionGetBuffed(m, -1, 0);
        }


    }


    class Sim_GVG_052 : SimTemplate //Crush
    {

        //   Destroy a minion. If you have a damaged minion, this costs (4) less.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetDestroyed(target);
        }


    }


    class Sim_GVG_053 : SimTemplate //Shieldmaiden
    {

        //   Battlecry:&lt;/b&gt; Gain 5 Armor.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                p.minionGetArmor(p.ownHero, 5);
            }
            else
            {
                p.minionGetArmor(p.enemyHero, 5);
            }
        }

    }


    class Sim_GVG_054 : SimTemplate //Ogre Warmaul
    {

        //   50% chance to attack the wrong enemy.
        // yolo!?
        CardDB.Card w = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.GVG_054);
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(w, ownplay);
        }



    }

    class Sim_GVG_055 : SimTemplate //Screwjank Clunker
    {

        //   Battlecry&lt;/b&gt;: Give a friendly Mech +2/+2.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {

            if (target == null) return;
            p.minionGetBuffed(target, 2, 2);
        }


    }


    class Sim_GVG_056 : SimTemplate //Iron Juggernaut
    {

        //   Battlecry:&lt;/b&gt; Shuffle a Mine into your opponent's deck. When drawn, it explodes for 10 damage.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                p.enemyDeckSize++;
                if (p.enemyDeckSize <= 6)
                {
                    p.minionGetDamageOrHeal(p.enemyHero, Math.Min(10, p.enemyHero.Hp - 1), true);
                    p.evaluatePenality -= 6;
                }
                else
                {
                    if (p.enemyDeckSize <= 16)
                    {
                        p.minionGetDamageOrHeal(p.enemyHero, Math.Min(5, p.enemyHero.Hp - 1), true);
                        p.evaluatePenality -= 8;
                    }
                    else
                    {
                        if (p.enemyDeckSize <= 26)
                        {
                            p.minionGetDamageOrHeal(p.enemyHero, Math.Min(2, p.enemyHero.Hp - 1), true);
                            p.evaluatePenality -= 10;
                        }
                    }
                }
            }
            else
            {
                p.ownDeckSize++;
            }
        }


    }


    class Sim_GVG_056t : SimTemplate //burrowing mine
    {

        //  explode



    }


    class Sim_GVG_057 : SimTemplate //Seal of Light
    {

        //   Restore #4 Health to your hero and gain +2 Attack this turn.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (ownplay)
            {
                int heal = p.getSpellHeal(4);
                p.minionGetDamageOrHeal(p.ownHero, -heal);
                p.minionGetTempBuff(p.ownHero, 2, 0);
            }
            else
            {
                int heal = p.getEnemySpellHeal(4);
                p.minionGetDamageOrHeal(p.enemyHero, -heal);
                p.minionGetTempBuff(p.enemyHero, 2, 0);
            }

        }


    }


    class Sim_GVG_058 : SimTemplate //Shielded Minibot
    {

        //   Divine Shield



    }


    class Sim_GVG_059 : SimTemplate //Coghammer
    {

        //   Battlecry: Give a random friendly minion Divine Shield and Taunt;.
        CardDB.Card w = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.GVG_059);
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.equipWeapon(w, ownplay);
            List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;
            Minion m = p.searchRandomMinion(temp, Playfield.searchmode.searchLowestHP);
            m.divineshild = true;
            m.taunt = true;
        }


    }


    class Sim_GVG_060 : SimTemplate //Quartermaster
    {

        //   Battlecry: Give your Silver Hand Recruits +2/+2.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.ownMinions : p.enemyMinions;
            foreach (Minion m in temp)
            {
                if (m.name == CardDB.cardName.silverhandrecruit) p.minionGetBuffed(m, 2, 2);
            }
        }


    }


    class Sim_GVG_061 : SimTemplate //Muster for Battle
    {

        //   Summon three 1/1 Silver Hand Recruits. Equip a 1/4 Weapon.
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_101t);
        CardDB.Card w = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_091);

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            for (int i = 0; i < 3; i++)
            {
                int pos = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;
                p.callKid(kid, pos, ownplay);
            }
            p.equipWeapon(w, ownplay);
        }


    }


    class Sim_GVG_062 : SimTemplate //Cobalt Guardian
    {

        //   Whenever you summon a Mech, gain Divine Shield.

        public override void onMinionIsSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            if (triggerEffectMinion.own == summonedMinion.own && (TAG_RACE)summonedMinion.handcard.card.race == TAG_RACE.MECHANICAL)
            {
                triggerEffectMinion.divineshild = true;
            }
        }



    }


    class Sim_GVG_063 : SimTemplate //Bolvar Fordragon
    {

        //   Whenever a friendly minion dies while this is in your hand, gain +1 Attack.


    }


    class Sim_GVG_064 : SimTemplate //Puddlestomper
    {

        //   just a murloc


    }


    class Sim_GVG_065 : SimTemplate //Ogre Brute
    {

        //   50% chance to attack the wrong enemy.

    }


    class Sim_GVG_066 : SimTemplate //Dunemaul Shaman
    {

        //   Windfury, Overload: (1)&lt;/b&gt

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own) p.ueberladung++;
        }


    }


    class Sim_GVG_067 : SimTemplate //Stonesplinter Trogg
    {

        //   Whenever your opponent casts a spell, gain +1 Attack.

        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (c.type == CardDB.cardtype.SPELL && wasOwnCard != triggerEffectMinion.own)
            {
                p.minionGetBuffed(triggerEffectMinion, 1, 0);
            }
        }


    }


    class Sim_GVG_068 : SimTemplate //Burly Rockjaw Trogg
    {

        //   Whenever your opponent casts a spell, gain +2 Attack.

        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (c.type == CardDB.cardtype.SPELL && wasOwnCard != triggerEffectMinion.own)
            {
                p.minionGetBuffed(triggerEffectMinion, 2, 0);
            }
        }


    }


    class Sim_GVG_069 : SimTemplate //Antique Healbot
    {

        //   Battlecry: Restore 8 Health to your hero.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                int heal = p.getMinionHeal(8);
                p.minionGetDamageOrHeal(p.ownHero, -heal, true);
            }
            else
            {
                int heal = p.getEnemyMinionHeal(8);
                p.minionGetDamageOrHeal(p.enemyHero, -heal, true);
            }
        }

    }


    class Sim_GVG_070 : SimTemplate //Salty Dog
    {

        //   just a pirate



    }


    class Sim_GVG_071 : SimTemplate //Lost Tallstrider
    {

        //   a tallstrider




    }


    class Sim_GVG_072 : SimTemplate //Shadowboxer
    {

        // Whenever a character is healed, deal 1 damage to a random enemy.  

        // done in playfield -> triggerACharGotHealed

    }


    class Sim_GVG_073 : SimTemplate //Cobra Shot
    {

        //   Deal $3 damage to a minion and the enemy hero.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(3) : p.getEnemySpellDamageDamage(3);

            p.minionGetDamageOrHeal(target, dmg);

            if (ownplay) p.minionGetDamageOrHeal(p.enemyHero, dmg);
            else p.minionGetDamageOrHeal(p.ownHero, dmg);
        }


    }


    class Sim_GVG_074 : SimTemplate //Kezan Mystic
    {
        //todo better!
        //  Battlecry: Take control of a random enemy Secret;. 

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                if (p.enemySecretList.Count >= 1)
                {
                    if (p.enemyHeroName == HeroEnum.hunter) p.ownSecretsIDList.Add(CardDB.cardIDEnum.EX1_610);
                    if (p.enemyHeroName == HeroEnum.mage) p.ownSecretsIDList.Add(CardDB.cardIDEnum.EX1_594);
                    if (p.enemyHeroName == HeroEnum.pala) p.ownSecretsIDList.Add(CardDB.cardIDEnum.EX1_130);

                    if (p.enemyHeroName != HeroEnum.hunter && p.enemyHeroName != HeroEnum.mage && p.enemyHeroName != HeroEnum.pala) p.ownSecretsIDList.Add(CardDB.cardIDEnum.EX1_130);

                    p.enemySecretList.RemoveAt(0);
                }
            }
            else
            {
                if (p.ownSecretsIDList.Count >= 1)
                {
                    p.ownSecretsIDList.RemoveAt(0);
                    SecretItem s = new SecretItem();
                    s.canBe_avenge = false;
                    s.canBe_counterspell = false;
                    s.canBe_duplicate = false;
                    s.canBe_explosive = false;
                    s.canBe_eyeforaneye = false;
                    s.canBe_freezing = false;
                    s.canBe_icebarrier = false;
                    s.canBe_iceblock = false;
                    s.canBe_mirrorentity = false;
                    s.canBe_missdirection = false;
                    s.canBe_noblesacrifice = false;
                    s.canBe_redemption = false;
                    s.canBe_repentance = false;
                    s.canBe_snaketrap = false;
                    s.canBe_snipe = false;
                    s.canBe_spellbender = false;
                    s.canBe_vaporize = false;

                    s.entityId = 1050;
                    s.canBe_explosive = true;

                    p.enemySecretList.Add(s);
                }
            }
        }


    }


    class Sim_GVG_075 : SimTemplate //Ship's Cannon
    {

        //   Whenever you summon a Pirate, deal 2 damage to a random enemy.

        public override void onMinionIsSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            if (triggerEffectMinion.own == summonedMinion.own)
            {
                List<Minion> temp = (triggerEffectMinion.own) ? p.enemyMinions : p.ownMinions;
                Minion m = p.searchRandomMinion(temp, Playfield.searchmode.searchHighestHP);
                if (m == null) return;
                p.minionGetDamageOrHeal(m, 2, true);
            }
        }


    }


    class Sim_GVG_076 : SimTemplate //Explosive Sheep
    {

        //  Deathrattle: Deal 2 damage to all minions. 

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.allMinionsGetDamage(2);
        }


    }


    class Sim_GVG_077 : SimTemplate //Anima Golem
    {

        //  At the end of each turn, destroy this minion if it's your only one. 

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (triggerEffectMinion.own)
            {
                if (p.ownMinions.Count == 1)
                {
                    p.minionGetDestroyed(triggerEffectMinion);
                }
            }
            else
            {
                if (p.enemyMinions.Count == 1)
                {
                    p.minionGetDestroyed(triggerEffectMinion);
                }
            }
        }


    }


    class Sim_GVG_078 : SimTemplate //Mechanical Yeti
    {

        //   Deathrattle: Give each player a Spare Part

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.drawACard(CardDB.cardName.armorplating, false, true);
            p.drawACard(CardDB.cardName.armorplating, true, true);
        }


    }


    class Sim_GVG_079 : SimTemplate //Force-Tank MAX
    {

        //  Divine Shield 



    }


    class Sim_GVG_080 : SimTemplate //Druid of the Fang
    {

        //   Battlecry:If you have a Beast, transform this minion into a 7/7.
        CardDB.Card betterguy = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.GVG_080t);
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.ownMinions : p.enemyMinions;
            bool hasbeast = false;
            foreach (Minion m in temp)
            {
                if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PET)
                {
                    hasbeast = true;
                }
            }
            if (hasbeast) p.minionTransform(own, betterguy);
        }


    }


    class Sim_GVG_080t : SimTemplate //Druid of the Fang better form :D
    {

        // 7/7 minion

    }


    class Sim_GVG_081 : SimTemplate //Gilblin Stalker
    {

        //  Stealth 




    }


    class Sim_GVG_082 : SimTemplate //Clockwork Gnome
    {

        //   Deathrattle: Add a Spare Part card to your hand.

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.drawACard(CardDB.cardName.armorplating, m.own, true);
        }

    }


    class Sim_GVG_083 : SimTemplate //Upgraded Repair Bot
    {

        //   Battlecry:&lt;/b&gt; Give a friendly Mech +4 Health.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null)
            {
                p.minionGetBuffed(target, 0, 4);
            }
        }




    }


    class Sim_GVG_084 : SimTemplate //Flying Machine<
    {

        //   Windfury


    }


    class Sim_GVG_085 : SimTemplate //Annoy-o-Tron
    {

        //   Taunt Divine Shield




    }


    class Sim_GVG_086 : SimTemplate //Siege Engine
    {

        //  Whenever you gain Armor, give this minion +1 Attack. 

        // done in triggerAHeroGotArmor()


    }


    class Sim_GVG_087 : SimTemplate //Steamwheedle Sniper
    {

        //  Your Hero Power can target minions. 

        public override void onAuraStarts(Playfield p, Minion m)
        {
            if (m.own)
            {
                if (p.ownHeroName == HeroEnum.hunter) p.weHaveSteamwheedleSniper = true;
            }
            else
            {
                if (p.enemyHeroName == HeroEnum.hunter) p.enemyHaveSteamwheedleSniper = true;
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {
            if (m.own && p.ownHeroName == HeroEnum.hunter)
            {
                bool hasss = false;
                foreach (Minion mnn in p.ownMinions)
                {
                    if (!mnn.silenced && m.name == CardDB.cardName.steamwheedlesniper)
                    {
                        hasss = true;
                    }
                }
                p.weHaveSteamwheedleSniper = hasss;

            }
            if (!m.own && p.enemyHeroName == HeroEnum.hunter)
            {
                bool hasss = false;
                foreach (Minion mnn in p.enemyMinions)
                {
                    if (!mnn.silenced && m.name == CardDB.cardName.steamwheedlesniper)
                    {
                        hasss = true;
                    }
                }
                p.enemyHaveSteamwheedleSniper = hasss;
            }
        }


    }


    class Sim_GVG_088 : SimTemplate //Ogre Ninja
    {

        //  Stealth 



    }


    class Sim_GVG_089 : SimTemplate //Illuminator
    {

        //  if you control a Secret at the end of your turn, restore 4 health to your hero. 

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (turnEndOfOwner == triggerEffectMinion.own)
            {
                if (((turnEndOfOwner) ? p.ownSecretsIDList.Count : p.enemySecretList.Count) >= 1)
                {
                    int heal = (turnEndOfOwner) ? p.getMinionHeal(4) : p.getEnemyMinionHeal(4);
                    p.minionGetDamageOrHeal(((turnEndOfOwner) ? p.ownHero : p.enemyHero), -heal, true);
                }
            }
        }

    }


    class Sim_GVG_090 : SimTemplate //Madder Bomber
    {

        //   Battlecry: Deal 6 damage randomly split between all other characters.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int anz = 6;
            for (int i = 0; i < anz; i++)
            {
                if (p.ownHero.Hp <= anz)
                {
                    p.minionGetDamageOrHeal(p.ownHero, 1);
                    continue;
                }
                List<Minion> temp = new List<Minion>(p.enemyMinions);
                if (temp.Count == 0)
                {
                    temp.AddRange(p.ownMinions);
                }
                temp.Sort((a, b) => a.Hp.CompareTo(b.Hp));//destroys the weakest

                foreach (Minion m in temp)
                {
                    p.minionGetDamageOrHeal(m, 1);
                    break;
                }
                p.minionGetDamageOrHeal(p.enemyHero, 1);
            }
        }


    }


    class Sim_GVG_091 : SimTemplate //Arcane Nullifier X-21
    {

        //   Taunt  can't be targeted by spells or Hero Powers.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            own.cantBeTargetedBySpellsOrHeroPowers = true;
        }

    }


    class Sim_GVG_092 : SimTemplate //Gnomish Experimenter
    {

        //  Battlecry: Draw a card. If it's a minion, transform it into a Chicken. 

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, own.own);
        }

    }


    class Sim_GVG_093 : SimTemplate //Target Dummy
    {

        //   Taunt

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {

        }

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {

        }


    }


    class Sim_GVG_094 : SimTemplate //Jeeves
    {

        //   At the end of each player's turn, that player draws until they have 3 cards.

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {

            int cardstodraw = 0;
            if (p.owncards.Count <= 2)
            {
                cardstodraw = 3 - p.owncards.Count;
            }

            for (int i = 0; i < cardstodraw; i++)
            {
                p.drawACard(CardDB.cardName.unknown, true);
            }
            cardstodraw = 0;

            //draw enemys cards...
            if (p.enemyAnzCards <= 2)
            {
                cardstodraw = 3 - p.enemyAnzCards;
            }

            for (int i = 0; i < cardstodraw; i++)
            {
                p.drawACard(CardDB.cardName.unknown, false);
            }

        }


    }


    class Sim_GVG_095 : SimTemplate //Goblin Sapper
    {

        //  Has +4 Attack while your opponent has 6 or more cards in hand. 

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int anz = (own.own) ? p.enemyAnzCards : p.owncards.Count;
            if (anz >= 6)
            {
                p.minionGetBuffed(own, 4, 0);
            }
        }

    }


    class Sim_GVG_096 : SimTemplate //Piloted Shredder
    {

        //   Deathrattle: Summon a random 2-Cost minion.

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_172);

        public override void onDeathrattle(Playfield p, Minion m)
        {

            int pos = (m.own) ? p.ownMinions.Count : p.enemyMinions.Count;
            p.callKid(kid, pos, m.own);
        }


    }


    class Sim_GVG_097 : SimTemplate //Lil' Exorcist
    {

        //   Taunt Battlecry: Gain +1/+1 for each enemy Deathrattle minion.
        //todo does silenced count?
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.enemyMinions : p.ownMinions;

            int gain = 0;
            foreach (Minion m in temp)
            {
                if (m.handcard.card.deathrattle) gain++;
            }
            if (gain >= 1) p.minionGetBuffed(own, gain, gain);
        }



    }


    class Sim_GVG_098 : SimTemplate //Gnomeregan Infantry
    {

        //   Charge Taunt




    }


    class Sim_GVG_099 : SimTemplate //Bomb Lobber
    {

        // Battlecry: Deal 4 damage to a random enemy minion.  

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.enemyMinions : p.ownMinions;
            int times = (own.own) ? p.getSpellDamageDamage(4) : p.getEnemySpellDamageDamage(4);

            if (temp.Count >= 1)
            {
                //search Minion with lowest hp
                Minion enemy = temp[0];
                int minhp = 10000;
                foreach (Minion m in temp)
                {
                    if (m.Hp >= times + 1 && minhp > m.Hp)
                    {
                        enemy = m;
                        minhp = m.Hp;
                    }
                }

                p.minionGetDamageOrHeal(enemy, times);

            }
        }

    }


    class Sim_GVG_100 : SimTemplate //Floating Watcher
    {

        // Whenever your hero takes damage on your turn, gain +2/+2.  
        // done in triggerAMinionGotDmg


    }


    class Sim_GVG_101 : SimTemplate //Scarlet Purifier
    {

        //   Battlecry: Deal 2 damage to all minions with Deathrattle.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {

            foreach (Minion m in p.ownMinions)
            {
                if (m.handcard.card.deathrattle) p.minionGetDamageOrHeal(m, 2);
            }
            foreach (Minion m in p.enemyMinions)
            {
                if (m.handcard.card.deathrattle) p.minionGetDamageOrHeal(m, 2);
            }

        }


    }


    class Sim_GVG_102 : SimTemplate //Tinkertown Technician
    {

        // Battlecry: If you have a Mech, gain +1/+1 and add a Spare Part to your hand.  

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.ownMinions : p.enemyMinions;

            foreach (Minion m in temp)
            {
                if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL)
                {
                    p.minionGetBuffed(own, 1, 1);
                    p.drawACard(CardDB.cardName.armorplating, own.own, true);
                    return;
                }
            }
        }

    }


    class Sim_GVG_103 : SimTemplate //Micro Machine
    {

        //   At the start of each turn, gain +1 Attack.

        public override void onTurnStartTrigger(Playfield p, Minion triggerEffectMinion, bool turnStartOfOwner)
        {
            p.minionGetBuffed(triggerEffectMinion, 1, 0);
        }


    }


    class Sim_GVG_104 : SimTemplate //Hobgoblin
    {

        //  Whenever you play a 1-Attack minion, give it +2/+2 

        // done in triggerACardWillBePlayed

    }


    class Sim_GVG_105 : SimTemplate //Piloted Sky Golem
    {

        // Deathrattle: Summon a random 4-Cost minion.  

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_182);//chillwind

        public override void onDeathrattle(Playfield p, Minion m)
        {

            int pos = (m.own) ? p.ownMinions.Count : p.enemyMinions.Count;
            p.callKid(kid, pos, m.own);
        }


    }


    class Sim_GVG_106 : SimTemplate //Junkbot
    {

        //   Whenever a friendly Mech dies, gain +2/+2.

        // done in triggerAMinionDied


    }


    class Sim_GVG_107 : SimTemplate //Enhance-o Mechano
    {

        //  Battlecry: Give your other minions Windfury Taunt or Divine Shield

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            List<Minion> temp = (own.own) ? p.ownMinions : p.enemyMinions;

            foreach (Minion m in temp)
            {
                m.taunt = true;
            }

        }


    }


    class Sim_GVG_108 : SimTemplate //Recombobulator
    {

        //   Battlecry: Transform a friendly minion into a random minion with the same Cost.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target == null) return;
            p.minionTransform(target, target.handcard.card);
        }

    }


    class Sim_GVG_109 : SimTemplate //Mini-Mage
    {

        //   Stealth Spell Damage +1
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.spellpower++;
            }
            else
            {
                p.enemyspellpower++;
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {

            if (m.own)
            {
                p.spellpower--;
            }
            else
            {
                p.enemyspellpower--;
            }
        }



    }


    class Sim_GVG_110 : SimTemplate //Dr. Boom
    {

        //  Battlecry: Summon two 1/1 Boom Bots. WARNING: Bots may explode. 

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.GVG_110t);//chillwind

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int pos = (own.own) ? p.ownMinions.Count : p.enemyMinions.Count;
            p.callKid(kid, pos, own.own);
            pos = (own.own) ? p.ownMinions.Count : p.enemyMinions.Count;
            p.callKid(kid, pos, own.own);
        }


    }


    class Sim_GVG_110t : SimTemplate //Boom Bot
    {

        //  Deathrattle: Deal 1-4 damage to a random enemy.



        public override void onDeathrattle(Playfield p, Minion m)
        {
            List<Minion> temp = (m.own) ? p.enemyMinions : p.ownMinions;
            if (temp.Count >= 1)
            {
                p.minionGetDamageOrHeal(p.searchRandomMinion(temp, Playfield.searchmode.searchHighestHP), 2);
            }
            else
            {
                p.minionGetDamageOrHeal(((m.own) ? p.enemyHero : p.ownHero), 2);
            }

        }


    }


    class Sim_GVG_111 : SimTemplate //Mimiron's Head
    {

        //   At the start of your turn, if you have at least 3 Mechs, destroy them all and form V-07-TR-0N.
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.GVG_111t);

        public override void onTurnStartTrigger(Playfield p, Minion triggerEffectMinion, bool turnStartOfOwner)
        {
            if (turnStartOfOwner != triggerEffectMinion.own) return;
            List<Minion> temp = (turnStartOfOwner) ? p.ownMinions : p.enemyMinions;
            int anz = 0;
            foreach (Minion m in temp)
            {
                if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL && m.Hp >= 1)
                {
                    anz++;
                }
            }
            if (anz >= 3)
            {
                foreach (Minion m in temp)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.MECHANICAL)
                    {
                        p.minionGetDestroyed(m);
                    }
                }

                int pos = (triggerEffectMinion.own) ? p.ownMinions.Count : p.enemyMinions.Count;
                p.callKid(kid, pos, triggerEffectMinion.own, false, true); // we allow to summon one minion more (because 3 are destroyed)
            }
        }

    }


    class Sim_GVG_111t : SimTemplate //V-07-TR-0N
    {

        //   Charge Mega-Windfury(Can attack four times a turn.)


    }


    class Sim_GVG_112 : SimTemplate //Mogor the Ogre
    {

        //   All minions have a 50% chance to attack the wrong enemy.

        //yolo?


    }


    class Sim_GVG_113 : SimTemplate //Foe Reaper 4000
    {

        //  Also damages the minions next to whomever he attacks. 
        //done in minionAttacksMinion

    }


    class Sim_GVG_114 : SimTemplate //Sneed's Old Shredder
    {

        //   Deathrattle: Summon a random legendary minion.
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_014);

        public override void onDeathrattle(Playfield p, Minion m)
        {
            int pos = (m.own) ? p.ownMinions.Count : p.enemyMinions.Count;
            p.callKid(kid, pos, m.own);
        }


    }


    class Sim_GVG_115 : SimTemplate //Toshley
    {

        //   Battlecry Deathrattle: Add a Spare Part card to your hand.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.armorplating, own.own, true);
        }

        public override void onDeathrattle(Playfield p, Minion m)
        {
            p.drawACard(CardDB.cardName.armorplating, m.own, true);
        }


    }


    class Sim_GVG_116 : SimTemplate //Mekgineer Thermaplugg
    {

        //   Whenever an enemy minion dies, summon a Leper Gnome.
        //done in trigger a minion died


    }


    class Sim_GVG_117 : SimTemplate //Gazlowe
    {

        //   Whenever you cast a 1-mana spell, add a random Mech to your hand.
        //todo: do it right (not card.cost, we have to use current cost)
        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (triggerEffectMinion.own == wasOwnCard)
            {
                if (c.type == CardDB.cardtype.SPELL && c.cost == 1)
                {
                    p.drawACard(CardDB.cardName.shieldedminibot, wasOwnCard, true);
                }
            }
        }


    }


    class Sim_GVG_118 : SimTemplate //Troggzor the Earthinator
    {

        // Whenever your opponent casts a spell, summon a Burly Rockjaw Trogg.

        //done in triggerACardWillBePlayed





    }

    class Sim_GVG_119 : SimTemplate //Blingtron 3000
    {

        //   Battlecry: Equip a random weapon for each player.
        CardDB.Card w = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.CS2_080);

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.equipWeapon(w, true);
            p.equipWeapon(w, false);
        }


    }

    class Sim_GVG_120 : SimTemplate //Hemet Nesingwary
    {

        //   Battlecry: Destroy a Beast.

        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target == null) return;

            p.minionGetDestroyed(target);
        }



    }

    class Sim_GVG_121 : SimTemplate //Clockwork Giant
    {

        //   Costs (1) less for each card in your opponent's hand.



    }

    class Sim_GVG_122 : SimTemplate //Wee Spellstopper
    {

        //   Adjacent minions can't be targeted by spells or Hero Powers.




    }

    class Sim_GVG_123 : SimTemplate //Soot Spewer
    {

        //   Spell Damage +1

        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.spellpower++;
            }
            else
            {
                p.enemyspellpower++;
            }
        }

        public override void onAuraEnds(Playfield p, Minion m)
        {

            if (m.own)
            {
                p.spellpower--;
            }
            else
            {
                p.enemyspellpower--;
            }
        }

    }

    class Sim_HERO_01 : SimTemplate //garroshhellscream
    {

        //


    }

    class Sim_HERO_02 : SimTemplate //thrall
    {

        //


    }

    class Sim_HERO_03 : SimTemplate //valeerasanguinar
    {

        //


    }

    class Sim_HERO_04 : SimTemplate //utherlightbringer
    {

        //


    }

    class Sim_HERO_05 : SimTemplate //rexxar
    {

        //


    }

    class Sim_HERO_06 : SimTemplate //malfurionstormrage
    {

        //


    }

    class Sim_HERO_07 : SimTemplate //guldan
    {

        //


    }

    class Sim_HERO_08 : SimTemplate //jainaproudmoore
    {

        //

    }

    class Sim_HERO_09 : SimTemplate //anduinwrynn
    {

        //

    }

    class Sim_hexfrog : SimTemplate //frog
    {

        //    spott/


    }

    class Sim_Mekka1 : SimTemplate //homingchicken
    {

        //    vernichtet zu beginn eures zuges diesen diener und zieht 3 karten.

        public override void onTurnStartTrigger(Playfield p, Minion triggerEffectMinion, bool turnStartOfOwner)
        {
            if (turnStartOfOwner == triggerEffectMinion.own)
            {
                p.minionGetDestroyed(triggerEffectMinion);
                p.drawACard(CardDB.cardName.unknown, turnStartOfOwner);
                p.drawACard(CardDB.cardName.unknown, turnStartOfOwner);
                p.drawACard(CardDB.cardName.unknown, turnStartOfOwner);
            }
        }

    }

    class Sim_Mekka2 : SimTemplate //repairbot
    {

        //    stellt am ende eures zuges bei einem verletzten charakter 6 leben wieder her.

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (turnEndOfOwner == triggerEffectMinion.own)
            {

                Minion tm = null;
                int hl = (triggerEffectMinion.own) ? p.getMinionHeal(6) : p.getEnemyMinionHeal(6);
                int heal = 0;
                foreach (Minion m in p.ownMinions)
                {
                    if (m.maxHp - m.Hp > heal)
                    {
                        tm = m;
                        heal = m.maxHp - m.Hp;
                    }
                }
                foreach (Minion m in p.enemyMinions)
                {
                    if (m.maxHp - m.Hp > heal)
                    {
                        tm = m;
                        heal = m.maxHp - m.Hp;
                    }
                }
                if (heal >= 1)
                {
                    p.minionGetDamageOrHeal(tm, -hl);
                }
                else
                {
                    p.minionGetDamageOrHeal(p.ownHero.Hp < 30 ? p.ownHero : p.enemyHero, -hl);
                }

            }
        }

    }

    class Sim_Mekka3 : SimTemplate //emboldener3000
    {

        //    verleiht am ende eures zuges einem zufälligen diener +1/+1.

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (triggerEffectMinion.own == turnEndOfOwner)
            {
                Minion tm = null;
                int ges = 1000;
                foreach (Minion m in p.ownMinions)
                {
                    if (m.Angr + m.Hp < ges)
                    {
                        tm = m;
                        ges = m.Angr + m.Hp;
                    }
                }
                foreach (Minion m in p.enemyMinions)
                {
                    if (m.Angr + m.Hp < ges)
                    {
                        tm = m;
                        ges = m.Angr + m.Hp;
                    }
                }
                if (ges <= 999)
                {
                    p.minionGetBuffed(tm, 1, 1);
                }
            }
        }

    }

    class Sim_Mekka4 : SimTemplate //poultryizer
    {
        CardDB.Card c = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.Mekka4t);

        //    verwandelt zu beginn eures zuges einen zufälligen diener in ein huhn (1/1).

        public override void onTurnStartTrigger(Playfield p, Minion triggerEffectMinion, bool turnStartOfOwner)
        {
            if (triggerEffectMinion.own == turnStartOfOwner)
            {
                Minion tm = null;
                int ges = 1000;
                foreach (Minion m in p.ownMinions)
                {
                    if (m.Angr + m.Hp < ges)
                    {
                        tm = m;
                        ges = m.Angr + m.Hp;
                    }
                }
                foreach (Minion m in p.enemyMinions)
                {
                    if (m.Angr + m.Hp < ges)
                    {
                        tm = m;
                        ges = m.Angr + m.Hp;
                    }
                }
                if (ges <= 999)
                {
                    p.minionTransform(tm, c);
                }
            }
        }



    }

    class Sim_Mekka4t : SimTemplate //chicken
    {

        //    i&gt;put, put, put!/i&gt;


    }

    class Sim_NEW1_003 : SimTemplate //sacrificialpact
    {

        //    vernichtet einen dämon. stellt bei eurem helden #5 leben wieder her.
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetDestroyed(target);
            int heal = (ownplay) ? p.getSpellHeal(5) : p.getEnemySpellHeal(5);
            p.minionGetDamageOrHeal(ownplay ? p.ownHero : p.enemyHero, -heal);
        }

    }

    class Sim_NEW1_004 : SimTemplate //vanish
    {

        //    lasst alle diener auf die hand ihrer besitzer zurückkehren.
        //todo clear playfield
        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.anzOwnRaidleader = 0;
            p.anzEnemyRaidleader = 0;
            p.anzOwnStormwindChamps = 0;
            p.anzEnemyStormwindChamps = 0;
            p.anzOwnTundrarhino = 0;
            p.anzEnemyTundrarhino = 0;
            p.anzOwnTimberWolfs = 0;
            p.anzEnemyTimberWolfs = 0;
            p.anzMurlocWarleader = 0;
            p.anzGrimscaleOracle = 0;
            p.anzOwnAuchenaiSoulpriest = 0;
            p.anzEnemyAuchenaiSoulpriest = 0;
            p.anzOwnsorcerersapprentice = 0;
            p.anzOwnsorcerersapprenticeStarted = 0;
            p.anzEnemysorcerersapprentice = 0;
            p.anzEnemysorcerersapprenticeStarted = 0;
            p.anzOwnSouthseacaptain = 0;
            p.anzEnemySouthseacaptain = 0;
            p.doublepriest = 0;
            p.enemydoublepriest = 0;
            p.ownBaronRivendare = 0;
            p.enemyBaronRivendare = 0;

            p.spellpower = 0;
            p.enemyspellpower = 0;



            p.winzigebeschwoererin = 0;
            p.managespenst = 0;
            p.soeldnerDerVenture = 0;
            p.beschwoerungsportal = 0;
            p.nerubarweblord = 0;

            foreach (Minion m in p.ownMinions)
            {
                p.drawACard(m.name, true, true);
            }
            foreach (Minion m in p.enemyMinions)
            {
                p.drawACard(m.name, false, true);
            }
            p.ownMinions.Clear();
            p.enemyMinions.Clear();

        }

    }

    class Sim_NEW1_005 : SimTemplate //kidnapper
    {

        //    combo:/ lasst einen diener auf die hand seines besitzers zurückkehren.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (p.cardsPlayedThisTurn >= 1) p.minionReturnToHand(target, target.own, 0);
        }


    }

    class Sim_NEW1_006 : SimTemplate //adrenalinerush
    {

        //    draw a card. combo:/ draw 2 cards instead.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, ownplay);
            if (p.cardsPlayedThisTurn >= 1) p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_NEW1_007 : SimTemplate //starfall
    {

        //    wählt aus:/ fügt einem diener $5 schaden zu; oder fügt allen feindlichen dienern $2 schaden zu.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            if (choice == 1)
            {
                int dmg = (ownplay) ? p.getSpellDamageDamage(5) : p.getEnemySpellDamageDamage(5);
                p.minionGetDamageOrHeal(target, dmg);
            }
            if (choice == 2)
            {
                int damage = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
                p.allMinionOfASideGetDamage(!ownplay, damage);
            }

        }

    }

    class Sim_NEW1_007a : SimTemplate //starfall choice left
    {

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(2) : p.getEnemySpellDamageDamage(2);
            p.allMinionOfASideGetDamage(!ownplay, dmg);
        }

    }

    class Sim_NEW1_007b : SimTemplate //starfall choice left
    {

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(5) : p.getEnemySpellDamageDamage(5);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_NEW1_008 : SimTemplate//ancient of lore
    {

        //Zieht 2 Karten; oder stellt 5 Leben wieder her
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (choice == 2)
            {
                int heal = (own.own) ? p.getMinionHeal(5) : p.getEnemyMinionHeal(5);
                p.minionGetDamageOrHeal(target, -heal);
            }
            else
            {
                p.drawACard(CardDB.cardName.unknown, own.own);
                p.drawACard(CardDB.cardName.unknown, own.own);
            }
        }

    }

    class Sim_NEW1_008a : SimTemplate //ancientteachings
    {

        //    zieht 2 karten.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, own.own);
            p.drawACard(CardDB.cardName.unknown, own.own);
        }
    }

    class Sim_NEW1_008b : SimTemplate //ancientsecrets
    {

        //    stellt 5 leben wieder her.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            int heal = (own.own) ? p.getMinionHeal(5) : p.getEnemyMinionHeal(5);
            p.minionGetDamageOrHeal(target, -heal);
        }

    }

    class Sim_NEW1_009 : SimTemplate //healingtotem
    {

        //    stellt am ende eures zuges bei allen befreundeten dienern 1 leben wieder her.

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (triggerEffectMinion.own == turnEndOfOwner)
            {
                int heal = (triggerEffectMinion.own) ? p.getMinionHeal(1) : p.getEnemyMinionHeal(1);
                p.allMinionOfASideGetDamage(turnEndOfOwner, -heal);
            }
        }

    }

    class Sim_NEW1_010 : SimTemplate //alakirthewindlord
    {

        //    windzorn/, ansturm/, gottesschild/, spott/


    }

    class Sim_NEW1_011 : SimTemplate //korkronelite
    {

        //    ansturm/


    }

    class Sim_NEW1_012 : SimTemplate //manawyrm
    {

        //    erhält jedes mal +1 angriff, wenn ihr einen zauber wirkt.
        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (triggerEffectMinion.own == wasOwnCard && c.type == CardDB.cardtype.SPELL)
            {
                triggerEffectMinion.Angr++;
            }
        }
    }

    class Sim_NEW1_014 : SimTemplate //masterofdisguise
    {

        //    kampfschrei:/ verleiht einem befreundeten diener verstohlenheit/.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null) target.stealth = true;
        }


    }

    class Sim_NEW1_016 : SimTemplate //captainsparrot
    {

        //    kampfschrei:/ fügt eurer hand einen zufälligen piraten aus eurem deck hinzu.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.unknown, true, true);
        }


    }

    class Sim_NEW1_017 : SimTemplate//Hungry Crab
    {
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (target != null)
            {
                p.minionGetDestroyed(target);
                p.minionGetBuffed(own, 2, 2);
            }
        }
    }

    class Sim_NEW1_018 : SimTemplate//bloodsail raider
    {
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            own.Angr += p.ownWeaponAttack;
        }

    }

    class Sim_NEW1_019 : SimTemplate //knifejuggler
    {

        //    fügt einem zufälligen feind 1 schaden zu, nachdem ihr einen diener herbeigerufen habt.
        public override void onMinionWasSummoned(Playfield p, Minion triggerEffectMinion, Minion summonedMinion)
        {
            if (triggerEffectMinion.entitiyID != summonedMinion.entitiyID && triggerEffectMinion.own == summonedMinion.own)
            {
                List<Minion> temp = (triggerEffectMinion.own) ? p.enemyMinions : p.ownMinions;

                if (temp.Count >= 1)
                {
                    //search Minion with lowest hp
                    Minion enemy = temp[0];
                    int minhp = 10000;
                    bool found = false;
                    foreach (Minion m in temp)
                    {
                        if (m.name == CardDB.cardName.nerubianegg && m.Hp >= 2) continue; //dont attack nerubianegg!
                        if (m.handcard.card.isToken && m.Hp == 1) continue;
                        if (m.name == CardDB.cardName.defender) continue;
                        if (m.name == CardDB.cardName.spellbender) continue;
                        if (m.Hp >= 2 && minhp > m.Hp)
                        {
                            enemy = m;
                            minhp = m.Hp;
                            found = true;
                        }
                    }

                    if (found)
                    {
                        p.minionGetDamageOrHeal(enemy, 1);
                    }
                    else
                    {
                        p.minionGetDamageOrHeal(triggerEffectMinion.own ? p.enemyHero : p.ownHero, 1);
                    }

                }
                else
                {
                    p.minionGetDamageOrHeal(triggerEffectMinion.own ? p.enemyHero : p.ownHero, 1);
                }

                triggerEffectMinion.stealth = false;
            }
        }

    }

    class Sim_NEW1_020 : SimTemplate //wildpyromancer
    {

        //    fügt allen dienern 1 schaden zu, nachdem ihr einen zauber gewirkt habt.
        //we do this manually (because there are only 2 minions which have this trigger)
        /*public override void onCardWasPlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (triggerEffectMinion.own == wasOwnCard)
            {
                p.allMinionsGetDamage(1);
            }
        }
        */
    }

    class Sim_NEW1_021 : SimTemplate //doomsayer
    {

        //    vernichtet zu beginn eures zuges alle diener.

        public override void onTurnStartTrigger(Playfield p, Minion triggerEffectMinion, bool turnStartOfOwner)
        {
            if (turnStartOfOwner == triggerEffectMinion.own)
            {
                p.allMinionsGetDestroyed();
            }
        }

    }

    class Sim_NEW1_022 : SimTemplate //dreadcorsair
    {

        //    spott./ kostet (1) weniger für jeden angriffspunkt eurer waffe.


    }

    class Sim_NEW1_023 : SimTemplate //faeriedragon
    {

        //    kann nicht als ziel von zaubern oder heldenfähigkeiten gewählt werden.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            own.cantBeTargetedBySpellsOrHeroPowers = true;
        }

    }

    class Sim_NEW1_024 : SimTemplate //captaingreenskin
    {
        //    kampfschrei:/ verleiht eurer waffe +1/+1.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own)
            {
                if (p.ownWeaponDurability >= 1)
                {
                    p.ownWeaponDurability++;
                    p.ownWeaponAttack++;
                    p.minionGetBuffed(p.ownHero, 1, 0);
                }
            }
            else
            {
                if (p.enemyWeaponDurability >= 1)
                {
                    p.enemyWeaponDurability++;
                    p.enemyWeaponAttack++;
                    p.minionGetBuffed(p.enemyHero, 1, 0);
                }
            }
        }

    }

    class Sim_NEW1_025 : SimTemplate //bloodsailcorsair
    {

        //    kampfschrei:/ zieht 1 haltbarkeit von der waffe eures gegners ab.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.lowerWeaponDurability(1, !own.own);
        }


    }

    class Sim_NEW1_026 : SimTemplate//Violet Teacher
    {
        public CardDB.Card card = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.NEW1_026t);

        public override void onCardIsGoingToBePlayed(Playfield p, CardDB.Card c, bool wasOwnCard, Minion triggerEffectMinion)
        {
            if (wasOwnCard == triggerEffectMinion.own && c.type == CardDB.cardtype.SPELL)
            {
                int place = (wasOwnCard) ? p.ownMinions.Count : p.enemyMinions.Count;
                p.callKid(card, place, wasOwnCard);
            }
        }

    }

    class Sim_NEW1_026t : SimTemplate //violetapprentice
    {

        //


    }

    class Sim_NEW1_027 : SimTemplate //southseacaptain
    {

        //    eure anderen piraten haben +1/+1.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnSouthseacaptain++;
                foreach (Minion m in p.ownMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PIRATE && own.entitiyID != m.entitiyID) p.minionGetBuffed(m, 1, 1);
                }
            }
            else
            {
                p.anzEnemySouthseacaptain++;
                foreach (Minion m in p.enemyMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PIRATE && own.entitiyID != m.entitiyID) p.minionGetBuffed(m, 1, 1);
                }
            }

        }

        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnSouthseacaptain--;
                foreach (Minion m in p.ownMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PIRATE && own.entitiyID != m.entitiyID) p.minionGetBuffed(m, -1, -1);
                }
            }
            else
            {
                p.anzEnemySouthseacaptain--;
                foreach (Minion m in p.enemyMinions)
                {
                    if ((TAG_RACE)m.handcard.card.race == TAG_RACE.PIRATE && own.entitiyID != m.entitiyID) p.minionGetBuffed(m, -1, -1);
                }
            }
        }


    }

    class Sim_NEW1_029 : SimTemplate //millhousemanastorm
    {

        //    kampfschrei:/ im nächsten zug kosten zauber für euren gegner (0) mana.
        //todo implement the nomanacosts for the enemyturn
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            if (own.own) p.weHavePlayedMillhouseManastorm = true;
        }


    }

    class Sim_NEW1_030 : SimTemplate //deathwing
    {

        //    kampfschrei:/ vernichtet alle anderen diener und werft eure hand ab.
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.allMinionsGetDestroyed();
            if (own.own)
            {
                p.owncards.Clear();
                p.triggerCardsChanged(true);
            }
            else
            {
                p.enemycarddraw = 0;
                p.enemyAnzCards = 0;
                p.triggerCardsChanged(false);
            }
        }



    }

    class Sim_NEW1_031 : SimTemplate //animalcompanion
    {

        //    ruft einen zufälligen wildtierbegleiter herbei.
        CardDB.Card c2 = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.NEW1_032);//misha

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int placeoffather = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;
            p.callKid(c2, placeoffather, ownplay);
        }

    }

    class Sim_NEW1_032 : SimTemplate //misha
    {

        //    spott/


    }

    class Sim_NEW1_033 : SimTemplate //leokk
    {

        //    andere befreundete diener haben +1 angriff.
        public override void onAuraStarts(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnRaidleader++;
                foreach (Minion m in p.ownMinions)
                {
                    if (own.entitiyID != m.entitiyID) p.minionGetBuffed(m, 1, 0);
                }
            }
            else
            {
                p.anzEnemyRaidleader++;
                foreach (Minion m in p.enemyMinions)
                {
                    if (own.entitiyID != m.entitiyID) p.minionGetBuffed(m, 1, 0);
                }
            }

        }

        public override void onAuraEnds(Playfield p, Minion own)
        {
            if (own.own)
            {
                p.anzOwnRaidleader--;
                foreach (Minion m in p.ownMinions)
                {
                    if (own.entitiyID != m.entitiyID) p.minionGetBuffed(m, -1, 0);
                }
            }
            else
            {
                p.anzEnemyRaidleader--;
                foreach (Minion m in p.enemyMinions)
                {
                    if (own.entitiyID != m.entitiyID) p.minionGetBuffed(m, -1, 0);
                }
            }
        }

    }

    class Sim_NEW1_034 : SimTemplate //huffer
    {

        //    ansturm/


    }

    class Sim_NEW1_036 : SimTemplate//commanding shout
    {

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            List<Minion> temp = (ownplay) ? p.ownMinions : p.enemyMinions;
            foreach (Minion t in temp)
            {
                t.cantLowerHPbelowONE = true;
            }
            p.drawACard(CardDB.cardName.unknown, ownplay);
        }

    }

    class Sim_NEW1_037 : SimTemplate //masterswordsmith
    {

        //    verleiht am ende eures zuges einem anderen zufälligen befreundeten diener +1 angriff.
        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (turnEndOfOwner == triggerEffectMinion.own)
            {
                List<Minion> temp2 = new List<Minion>(p.ownMinions);
                temp2.Sort((a, b) => a.Angr.CompareTo(b.Angr));//buff the weakest
                foreach (Minion mins in temp2)
                {
                    if (triggerEffectMinion.zonepos == mins.zonepos) continue;
                    p.minionGetBuffed(mins, 1, 0);
                    break;
                }
            }
        }

    }

    class Sim_NEW1_038 : SimTemplate//Gruul
    {
        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            p.minionGetBuffed(triggerEffectMinion, 1, 1);
        }


    }

    class Sim_NEW1_040 : SimTemplate //hogger
    {
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.NEW1_040t);//gnoll
        //    ruft am ende eures zuges einen gnoll (2/2) mit spott/ herbei.

        public override void onTurnEndsTrigger(Playfield p, Minion triggerEffectMinion, bool turnEndOfOwner)
        {
            if (triggerEffectMinion.own == turnEndOfOwner)
            {
                int posi = triggerEffectMinion.zonepos;

                p.callKid(kid, posi, triggerEffectMinion.own);
            }
        }

    }

    class Sim_NEW1_040t : SimTemplate //gnoll
    {

        //    spott/


    }

    class Sim_NEW1_041 : SimTemplate//Stampeding Kodo
    {
        //todo list
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {

            List<Minion> temp2 = (own.own) ? new List<Minion>(p.enemyMinions) : new List<Minion>(p.ownMinions);
            temp2.Sort((a, b) => a.Hp.CompareTo(b.Hp));//destroys the weakest
            foreach (Minion enemy in temp2)
            {
                if (enemy.Angr <= 2)
                {
                    p.minionGetDestroyed(enemy);
                    break;
                }
            }

        }


    }

    class Sim_PART_001 : SimTemplate //Armor Plating
    {

        //   Give a minion +1 Health.


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 0, 1);
        }


    }

    class Sim_PART_002 : SimTemplate //Time Rewinder
    {

        //   Return a friendly minion to your hand.


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionReturnToHand(target, target.own, 0);
        }


    }

    class Sim_PART_003 : SimTemplate //Rusty Horn
    {

        // Give a minion Taunt.   


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            target.taunt = true;
        }


    }

    class Sim_PART_004 : SimTemplate //Finicky Cloakfield
    {

        //   Give a friendly minion Stealth until your next turn.


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            target.stealth = true;
            target.concedal = true;
        }


    }

    class Sim_PART_005 : SimTemplate //Emergency Coolant
    {

        //  Freeze a minion. 


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            target.frozen = true;
        }


    }

    class Sim_PART_006 : SimTemplate //Reversing Switch
    {

        //   Swap a minion's Attack and Health.


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionSwapAngrAndHP(target);
        }


    }

    class Sim_PART_007 : SimTemplate //Whirling Blades
    {

        //Give a minion +1 Attack.   


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            p.minionGetBuffed(target, 1, 0);
        }


    }

    class Sim_PlaceholderCard : SimTemplate //placeholdercard
    {

        //


    }

    class Sim_PRO_001 : SimTemplate //elitetaurenchieftain
    {

        //    kampfschrei:/ verleiht beiden spielern die macht des rock! (durch eine powerakkordkarte)
        public override void getBattlecryEffect(Playfield p, Minion own, Minion target, int choice)
        {
            p.drawACard(CardDB.cardName.roguesdoit, true, true);
            p.drawACard(CardDB.cardName.roguesdoit, false, true);
        }

    }

    class Sim_PRO_001a : SimTemplate//I Am Murloc
    {
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.PRO_001at);

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;

            p.callKid(kid, posi, ownplay);
            p.callKid(kid, posi, ownplay);
            p.callKid(kid, posi, ownplay);
            p.callKid(kid, posi, ownplay);
        }

    }

    class Sim_PRO_001at : SimTemplate //murloc
    {

        //


    }

    class Sim_PRO_001b : SimTemplate//Rogues Do It...
    {


        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int dmg = (ownplay) ? p.getSpellDamageDamage(4) : p.getEnemySpellDamageDamage(4);
            p.minionGetDamageOrHeal(target, dmg);
        }

    }

    class Sim_PRO_001c : SimTemplate //powerofthehorde
    {
        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.EX1_390);
        //    beschwört einen zufälligen krieger der horde.

        public override void onCardPlay(Playfield p, bool ownplay, Minion target, int choice)
        {
            int posi = (ownplay) ? p.ownMinions.Count : p.enemyMinions.Count;

            p.callKid(kid, posi, ownplay);
        }

    }

    class Sim_skele11 : SimTemplate //skeleton
    {

        //    /


    }

    class Sim_skele21 : SimTemplate //damagedgolem
    {

        //


    }

    class Sim_tt_004 : SimTemplate //flesheatingghoul
    {

        //    erhält jedes mal +1 angriff, wenn ein diener stirbt.
        public override void onMinionDiedTrigger(Playfield p, Minion triggerEffectMinion, Minion diedMinion)
        {
            p.minionGetBuffed(triggerEffectMinion, 1, 0);
        }

    }

    class Sim_tt_010 : SimTemplate //spellbender
    {
        //todo secret
        //    geheimnis:/ wenn ein feind einen zauber auf einen diener wirkt, ruft ihr einen diener (1/3) als neues ziel herbei.

        CardDB.Card kid = CardDB.Instance.getCardDataFromID(CardDB.cardIDEnum.tt_010a);

        public override void onSecretPlay(Playfield p, bool ownplay, Minion attacker, Minion target, out int number)
        {
            number = 0;
            if (ownplay)
            {
                int posi = p.ownMinions.Count;
                p.callKid(kid, posi, true);
                if (p.ownMinions.Count >= 1)
                {
                    if (p.ownMinions[p.ownMinions.Count - 1].name == CardDB.cardName.spellbender)
                    {
                        number = p.ownMinions[p.ownMinions.Count - 1].entitiyID;
                    }
                }
            }
            else
            {
                int posi = p.enemyMinions.Count;
                p.callKid(kid, posi, false);

                if (p.enemyMinions.Count >= 1)
                {
                    if (p.enemyMinions[p.enemyMinions.Count - 1].name == CardDB.cardName.spellbender)
                    {
                        number = p.enemyMinions[p.enemyMinions.Count - 1].entitiyID;
                    }
                }
            }

        }

    }

    class Sim_tt_010a : SimTemplate //spellbender
    {

        //    zauberformerin


    }

}